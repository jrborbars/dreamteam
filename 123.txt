APACHE_LOCK_DIR=/home/ubuntu/lib/apache2/lock
APACHE_LOG_DIR=/home/ubuntu/lib/apache2/log
APACHE_PID_FILE=/home/ubuntu/lib/apache2/run/apache2.pid
APACHE_RUN_DIR=/home/ubuntu/lib/apache2/run
APACHE_RUN_GROUP=ubuntu
APACHE_RUN_USER=ubuntu
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="3" [2]="11" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.3.11(1)-release'
C9_EMAIL=jrborba.rs@ig.com.br
C9_FULLNAME='Jose Ricardo Borba'
C9_HOSTNAME=sirpa-jrborba.c9users.io
C9_IP=0.0.0.0
C9_PID=6162200
C9_PORT=8080
C9_PROJECT=sirpa
C9_SHARED=/mnt/shared
C9_SH_EXECUTED=1
C9_UID=769193
C9_USER=jrborba
COLUMNS=172
DIRSTACK=()
EMAIL=jrborba.rs@ig.com.br
EUID=1000
EXIT_CODE=0
FLASK_APP=run.py
FLASK_CONFIG=development
GEM_HOME=/usr/local/rvm/gems/ruby-2.4.0
GEM_PATH=/usr/local/rvm/gems/ruby-2.4.0:/usr/local/rvm/gems/ruby-2.4.0@global
GOPATH=/home/ubuntu/workspace
GOROOT=/opt/go
GROUPS=()
HGUSER='Jose Ricardo Borba'
HISTCONTROL=ignoreboth
HISTFILE=/home/ubuntu/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/ubuntu
HOSTNAME=jrborba-sirpa-6162200
HOSTTYPE=x86_64
IFS=$' \t\n'
IP=0.0.0.0
IRBRC=/usr/local/rvm/rubies/ruby-2.4.0/.irbrc
ISOUTPUTPANE=0
LANG=C
LANGUAGE=C.UTF-8
LC_ALL=C.UTF-8
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=16
LOGNAME=ubuntu
MACHTYPE=x86_64-pc-linux-gnu
MAILCHECK=60
MANPATH=/home/ubuntu/.nvm/versions/node/v6.11.2/share/man:/usr/local/rvm/rubies/ruby-2.4.0/share/man:/usr/local/man:/usr/local/share/man:/usr/share/man:/usr/local/rvm/man
METEOR_IP=0.0.0.0
METEOR_PORT=8080
MY_RUBY_HOME=/usr/local/rvm/rubies/ruby-2.4.0
NODE_PATH=/mnt/shared/lib/node_modules
NVM_BIN=/home/ubuntu/.nvm/versions/node/v6.11.2/bin
NVM_CD_FLAGS=
NVM_DIR=/home/ubuntu/.nvm
NVM_IOJS_ORG_MIRROR=https://iojs.org/dist
NVM_NODEJS_ORG_MIRROR=https://nodejs.org/dist
NVM_PATH=/home/ubuntu/.nvm/versions/node/v6.11.2/lib/node
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/home/ubuntu/.virtualenvs/workspace/bin:/home/ubuntu/.nvm/versions/node/v6.11.2/bin:/usr/local/rvm/gems/ruby-2.4.0/bin:/usr/local/rvm/gems/ruby-2.4.0@global/bin:/usr/local/rvm/rubies/ruby-2.4.0/bin:/mnt/shared/bin:/home/ubuntu/workspace/node_modules/.bin:/home/ubuntu/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/mnt/shared/sbin:/opt/gitl:/opt/go/bin:/mnt/shared/c9/app.nw/bin:/usr/local/rvm/bin
PHPRC=/home/ubuntu/workspace
PIPESTATUS=([0]="0")
PORT=8080
PPID=769
PS1='(workspace) \[\033[01;32m\]${C9_USER}\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$(__git_ps1 " (%s)") $ '
PS2='> '
PS4='+ '
PWD=/home/ubuntu/workspace
RC=0
RUBY_VERSION=ruby-2.4.0
SECRET_KEY='p9Bv<3Eid9%'
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=4
SSH_CLIENT='::ffff:10.240.0.186 38912 22'
SSH_CONNECTION='::ffff:10.240.0.186 38912 ::ffff:172.17.0.6 22'
TERM=screen
TMUX=/tmp/tmux-1000/cloud92.2,768,0
TMUX_PANE=%0
UID=1000
USER=ubuntu
USE_FULL=no
VIRTUALENVWRAPPER_ENV_BIN_DIR=bin
VIRTUALENVWRAPPER_HOOK_DIR=/home/ubuntu/.virtualenvs
VIRTUALENVWRAPPER_PROJECT_FILENAME=.project
VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
VIRTUALENVWRAPPER_SCRIPT=/usr/share/virtualenvwrapper/virtualenvwrapper.sh
VIRTUALENVWRAPPER_VIRTUALENV=virtualenv
VIRTUALENVWRAPPER_VIRTUALENV_CLONE=virtualenv-clone
VIRTUAL_ENV=/home/ubuntu/.virtualenvs/workspace
WORKON_HOME=/home/ubuntu/.virtualenvs
_=set
_OLD_VIRTUAL_PATH=/home/ubuntu/.nvm/versions/node/v6.11.2/bin:/usr/local/rvm/gems/ruby-2.4.0/bin:/usr/local/rvm/gems/ruby-2.4.0@global/bin:/usr/local/rvm/rubies/ruby-2.4.0/bin:/mnt/shared/bin:/home/ubuntu/workspace/node_modules/.bin:/home/ubuntu/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/mnt/shared/sbin:/opt/gitl:/opt/go/bin:/mnt/shared/c9/app.nw/bin:/usr/local/rvm/bin
_OLD_VIRTUAL_PS1='\[\033[01;32m\]${C9_USER}\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$(__git_ps1 " (%s)") $ '
_VIRTUALENVWRAPPER_API=' mkvirtualenv rmvirtualenv lsvirtualenv showvirtualenv workon add2virtualenv cdsitepackages cdvirtualenv lssitepackages toggleglobalsitepackages cpvirtualenv setvirtualenvproject mkproject cdproject mktmpenv mkvirtualenv rmvirtualenv lsvirtualenv showvirtualenv workon add2virtualenv cdsitepackages cdvirtualenv lssitepackages toggleglobalsitepackages cpvirtualenv setvirtualenvproject mkproject cdproject mktmpenv'
__git_printf_supports_v=yes
__mvnall_plugin_and_goals=$'clean:clean\n\t clean:help\n\t compiler:compile\n\t compiler:testCompile\n\t compiler:help\n\t deploy:deploy\n\t deploy:deploy-file\n\t deploy:help\n\t install:install\n\t install:install-file\n\t install:help\n\t resources:resources\n\t resources:testResources\n\t resources:copy-resources\n\t resources:help\n\t site:site\n\t site:deploy\n\t site:run\n\t site:stage\n\t site:stage-deploy\n\t site:attach-descriptor\n\t site:jar\n\t site:help\n\t surefire:test\n\t surefire:help\n\t verifier:verify\n\t verifier:help ear:ear\n\t ear:generate-application-xml\n\t ear:help\n\t jar:jar\n\t jar:test-jar\n\t jar:sign\n\t jar:sign-verify\n\t jar:help\n\t rar:rar\n\t rar:help\n\t war:war\n\t war:exploded\n\t war:inplace\n\t war:manifest\n\t war:help\n\t shade:shade\n\t shade:help changelog:changelog\n\t changelog:dev-activity\n\t changelog:file-activity\n\t changelog:help\n\t changes:announcement-mail\n\t changes:announcement-generate\n\t changes:changes-report\n\t changes:jira-report\n\t changes:changes-validate\n\t changes:help\n\t checkstyle:checkstyle\n\t checkstyle:check\n\t checkstyle:help\n\t doap:generate\n\t doap:help\n\t docck:check\n\t docck:help\n\t javadoc:javadoc\n\t javadoc:test-javadoc\n\t javadoc:aggregate\n\t javadoc:test-aggregate\n\t javadoc:jar\n\t javadoc:test-jar\n\t javadoc:help\n\t jxr:jxr\n\t jxr:test-jxr\n\t jxr:help\n\t pmd:pmd\n\t pmd:cpd\n\t pmd:check\n\t pmd:cpd-check\n\t pmd:help\n\t project-info-reports:cim\n\t project-info-reports:dependencies\n\t project-info-reports:dependency-convergence\n\t project-info-reports:dependency-management\n\t project-info-reports:index\n\t project-info-reports:issue-tracking\n\t project-info-reports:license\n\t project-info-reports:mailing-list\n\t project-info-reports:plugin-management\n\t project-info-reports:project-team\n\t project-info-reports:scm\n\t project-info-reports:summary\n\t project-info-reports:help\n\t surefire-report:report\n\t surefire-report:report-only\n\t surefire-report:help ant:ant\n\t ant:clean\n\t ant:help\n\t antrun:run\n\t antrun:help\n\t archetype:create\n\t archetype:generate\n\t archetype:create-from-project\n\t archetype:crawl\n\t archetype:help\n\t assembly:assembly\n\t assembly:directory\n\t assembly:directory-single\n\t assembly:single\n\t assembly:help\n\t dependency:copy\n\t dependency:copy-dependencies\n\t dependency:unpack\n\t dependency:unpack-dependencies\n\t dependency:resolve\n\t dependency:list\n\t dependency:sources\n\t dependency:resolve-plugins\n\t dependency:go-offline\n\t dependency:purge-local-repository\n\t dependency:build-classpath\n\t dependency:analyze\n\t dependency:analyze-dep-mgt\n\t dependency:tree\n\t dependency:help\n\t enforcer:enforce\n\t enforcer:display-info\n\t enforcer:help\n\t gpg:sign\n\t gpg:sign-and-deploy-file\n\t gpg:help\n\t help:active-profiles\n\t help:all-profiles\n\t help:describe\n\t help:effective-pom\n\t help:effective-settings\n\t help:evaluate\n\t help:expressions\n\t help:system\n\t invoker:install\n\t invoker:run\n\t invoker:help\n\t one:convert\n\t one:deploy-maven-one-repository\n\t one:install-maven-one-repository\n\t one:maven-one-plugin\n\t one:help\n\t patch:apply\n\t patch:help\n\t pdf:pdf\n\t pdf:help\n\t plugin:descriptor\n\t plugin:report\n\t plugin:updateRegistry\n\t plugin:xdoc\n\t plugin:addPluginArtifactMetadata\n\t plugin:helpmojo\n\t plugin:help\n\t release:clean\n\t release:prepare\n\t release:rollback\n\t release:perform\n\t release:stage\n\t release:branch\n\t release:help\n\t reactor:resume\n\t reactor:make\n\t reactor:make-dependents\n\t reactor:make-scm-changes\n\t reactor:help\n\t remote-resources:bundle\n\t remote-resources:process\n\t remote-resources:help\n\t repository:bundle-create\n\t repository:bundle-pack\n\t repository:help\n\t scm:branch\n\t scm:validate\n\t scm:add\n\t scm:unedit\n\t scm:export\n\t scm:bootstrap\n\t scm:changelog\n\t scm:list\n\t scm:checkin\n\t scm:checkout\n\t scm:status\n\t scm:update\n\t scm:diff\n\t scm:update-subprojects\n\t scm:edit\n\t scm:tag\n\t scm:help\n\t source:aggregate\n\t source:jar\n\t source:test-jar\n\t source:jar-no-fork\n\t source:test-jar-no-fork\n\t source:help\n\t stage:copy\n\t stage:help \n  eclipse:clean\n\t eclipse:configure-workspace\n\t eclipse:eclipse\n\t eclipse:help\n\t eclipse:install-plugins\n\t eclipse:m2eclipse\n\t eclipse:make-artifacts\n\t eclipse:myeclipse\n\t eclipse:myeclipse-clean\n\t eclipse:rad\n\t eclipse:rad-clean\n\t eclipse:remove-cache\n\t eclipse:to-maven\n\t idea:clean\n\t idea:help\n\t idea:idea\n\t idea:module\n\t idea:project\n\t idea:workspace \n\t plexus:app plexus:bundle-application plexus:bundle-runtime plexus:descriptor plexus:runtime plexus:service\n\t jetty:run-war jetty:run\n\t cargo:start cargo:stop\n\t dbunit:export dbunit:operation\n\t exec:exec exec:java exec:help\n\t hibernate3:hbm2cfgxml hibernate3:hbm2ddl hibernate3:hbm2doc hibernate3:hbm2hbmxml hibernate3:hbm2java hibernate3:schema-export\n\t   hibernate3:schema-update\n\t groovy:compile groovy:console groovy:execute groovy:generateStubs groovy:generateTestStubs groovy:help groovy:providers groovy:shell\n\t   groovy:testCompile\n\t gwt:compile gwt:eclipse gwt:eclipseTest gwt:generateAsync gwt:help gwt:i18n gwt:test\n\t javacc:help javacc:javacc javacc:jjdoc javacc:jjtree javacc:jjtree-javacc javacc:jtb javacc:jtb-javacc\n\t jboss:configure jboss:deploy jboss:harddeploy jboss:start jboss:stop jboss:undeploy\n\t jboss-packaging:esb jboss-packaging:esb-exploded jboss-packaging:har jboss-packaging:har-exploded jboss-packaging:sar jboss-packaging:sar-exploded\n\t   jboss-packaging:sar-inplace jboss-packaging:spring\n\t jpox:enhance jpox:schema-create jpox:schema-dbinfo jpox:schema-delete jpox:schema-info jpox:schema-validate\n\t make:autoreconf make:chmod make:chown make:compile make:configure make:help make:make-clean make:make-dist make:make-install make:test\n\t   make:validate-pom\n\t nbm:autoupdate nbm:branding nbm:cluster nbm:directory nbm:jar nbm:nbm nbm:populate-repository nbm:run-ide nbm:run-platform\n\t tomcat:deploy tomcat:exploded tomcat:info tomcat:inplace tomcat:list tomcat:redeploy tomcat:resources tomcat:roles tomcat:run tomcat:run-war\n\t   tomcat:sessions tomcat:start tomcat:stop tomcat:undeploy\n\t wagon:copy wagon:download wagon:download-single wagon:help wagon:list wagon:merge-maven-repos wagon:upload wagon:upload-single\n\t was6:clean was6:ejbdeploy was6:help was6:installApp was6:wsAdmin was6:wsDefaultBindings was6:wsListApps was6:wsStartApp was6:wsStartServer\n\t   was6:wsStopApp was6:wsStopServer was6:wsUninstallApp\n\t weblogic:appc weblogic:clientgen weblogic:clientgen9 weblogic:deploy weblogic:jwsc weblogic:listapps weblogic:redeploy weblogic:servicegen\n\t   weblogic:start weblogic:stop weblogic:undeploy weblogic:wsdlgen '
__mvnclassifiers='sources test-jar'
__mvnclean_phases=$'pre-clean\n\t clean\n\t post-clean'
__mvncore_plugins=$'clean:clean\n\t clean:help\n\t compiler:compile\n\t compiler:testCompile\n\t compiler:help\n\t deploy:deploy\n\t deploy:deploy-file\n\t deploy:help\n\t install:install\n\t install:install-file\n\t install:help\n\t resources:resources\n\t resources:testResources\n\t resources:copy-resources\n\t resources:help\n\t site:site\n\t site:deploy\n\t site:run\n\t site:stage\n\t site:stage-deploy\n\t site:attach-descriptor\n\t site:jar\n\t site:help\n\t surefire:test\n\t surefire:help\n\t verifier:verify\n\t verifier:help'
__mvncustom_plugins=
__mvndefault_phases=$'validate \n\t initialize \n\t generate-sources \n\t process-sources \n\t generate-resources \n\t process-resources \n\t compile \n\t process-classes \n\t generate-test-sources \n\t process-test-sources \n\t generate-test-resources \n\t process-test-resources \n\t test-compile \n\t process-test-classes \n\t test \n\t package \n\t pre-integration-test \n\t integration-test \n\t post-integration-test \n\t verify \n\t install \n\t deploy'
__mvnide_plugins=$'eclipse:clean\n\t eclipse:configure-workspace\n\t eclipse:eclipse\n\t eclipse:help\n\t eclipse:install-plugins\n\t eclipse:m2eclipse\n\t eclipse:make-artifacts\n\t eclipse:myeclipse\n\t eclipse:myeclipse-clean\n\t eclipse:rad\n\t eclipse:rad-clean\n\t eclipse:remove-cache\n\t eclipse:to-maven\n\t idea:clean\n\t idea:help\n\t idea:idea\n\t idea:module\n\t idea:project\n\t idea:workspace'
__mvnopts=$'--also-make --also-make-dependents --file --debug --batch-mode --lax-checksums --strict-checksums --check-plugin-updates --define \n  --errors --encrypt-master-password --encrypt-password --fail-at-end --fail-fast --fail-never --help --non-recursive --no-plugin-registry \n  --no-plugin-updates --offline --activate-profiles --projects --quiet --reactor --resume-from --settings --global-settings --update-snapshots \n  --update-plugins --version --show-version'
__mvnoptsWithArg='--file|--define|--encrypt-master-password|--encrypt-password|--resume-from|--settings|--global-settings|--activate-profiles|--projects'
__mvnother_plugins=$'\n\t plexus:app plexus:bundle-application plexus:bundle-runtime plexus:descriptor plexus:runtime plexus:service\n\t jetty:run-war jetty:run\n\t cargo:start cargo:stop\n\t dbunit:export dbunit:operation\n\t exec:exec exec:java exec:help\n\t hibernate3:hbm2cfgxml hibernate3:hbm2ddl hibernate3:hbm2doc hibernate3:hbm2hbmxml hibernate3:hbm2java hibernate3:schema-export\n\t   hibernate3:schema-update\n\t groovy:compile groovy:console groovy:execute groovy:generateStubs groovy:generateTestStubs groovy:help groovy:providers groovy:shell\n\t   groovy:testCompile\n\t gwt:compile gwt:eclipse gwt:eclipseTest gwt:generateAsync gwt:help gwt:i18n gwt:test\n\t javacc:help javacc:javacc javacc:jjdoc javacc:jjtree javacc:jjtree-javacc javacc:jtb javacc:jtb-javacc\n\t jboss:configure jboss:deploy jboss:harddeploy jboss:start jboss:stop jboss:undeploy\n\t jboss-packaging:esb jboss-packaging:esb-exploded jboss-packaging:har jboss-packaging:har-exploded jboss-packaging:sar jboss-packaging:sar-exploded\n\t   jboss-packaging:sar-inplace jboss-packaging:spring\n\t jpox:enhance jpox:schema-create jpox:schema-dbinfo jpox:schema-delete jpox:schema-info jpox:schema-validate\n\t make:autoreconf make:chmod make:chown make:compile make:configure make:help make:make-clean make:make-dist make:make-install make:test\n\t   make:validate-pom\n\t nbm:autoupdate nbm:branding nbm:cluster nbm:directory nbm:jar nbm:nbm nbm:populate-repository nbm:run-ide nbm:run-platform\n\t tomcat:deploy tomcat:exploded tomcat:info tomcat:inplace tomcat:list tomcat:redeploy tomcat:resources tomcat:roles tomcat:run tomcat:run-war\n\t   tomcat:sessions tomcat:start tomcat:stop tomcat:undeploy\n\t wagon:copy wagon:download wagon:download-single wagon:help wagon:list wagon:merge-maven-repos wagon:upload wagon:upload-single\n\t was6:clean was6:ejbdeploy was6:help was6:installApp was6:wsAdmin was6:wsDefaultBindings was6:wsListApps was6:wsStartApp was6:wsStartServer\n\t   was6:wsStopApp was6:wsStopServer was6:wsUninstallApp\n\t weblogic:appc weblogic:clientgen weblogic:clientgen9 weblogic:deploy weblogic:jwsc weblogic:listapps weblogic:redeploy weblogic:servicegen\n\t   weblogic:start weblogic:stop weblogic:undeploy weblogic:wsdlgen'
__mvnpackaging='pom jar maven-plugin ejb war ear rar par'
__mvnpackaging_plugins=$'ear:ear\n\t ear:generate-application-xml\n\t ear:help\n\t jar:jar\n\t jar:test-jar\n\t jar:sign\n\t jar:sign-verify\n\t jar:help\n\t rar:rar\n\t rar:help\n\t war:war\n\t war:exploded\n\t war:inplace\n\t war:manifest\n\t war:help\n\t shade:shade\n\t shade:help'
__mvnparams=$'-Dmaven.test.skip=true -Dsurefire.useFile=false -Dmaven.surefire.debug -Xdebug -Xnoagent -Djava.compiler=NONE \n  -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y -Dverbose -Dmaven.test.failure.ignore=true'
__mvnphases=$'validate \n\t initialize \n\t generate-sources \n\t process-sources \n\t generate-resources \n\t process-resources \n\t compile \n\t process-classes \n\t generate-test-sources \n\t process-test-sources \n\t generate-test-resources \n\t process-test-resources \n\t test-compile \n\t process-test-classes \n\t test \n\t package \n\t pre-integration-test \n\t integration-test \n\t post-integration-test \n\t verify \n\t install \n\t deploy pre-clean\n\t clean\n\t post-clean pre-site\n\t site\n\t post-site\n\t site-deploy'
__mvnplugins=$'\n ant:\n antrun:\n archetype:\n aembly:\n cargo:\n changelog:\n change:\n checktyle:\n clean:\n compiler:\n dbunit:\n dependency:\n deploy:\n doap:\n docck:\n ear:\n eclipe:\n enforcer:\n exec:\n gpg:\n groovy:\n gwt:\n help:\n hibernate3:\n idea:\n intall:\n invoker:\n jar:\n javacc:\n javadoc:\n jbo-packaging:\n jbo:\n jetty:\n jpox:\n jxr:\n make:\n nbm:\n one:\n patch:\n pdf:\n plexu:\n plugin:\n pmd:\n project-info-report:\n rar:\n reactor:\n releae:\n remote-reource:\n repoitory:\n reource:\n cm:\n hade:\n ite:\n ource:\n tage:\n urefire-report:\n urefire:\n tomcat:\n verifier:\n wagon:\n war:\n wa6:\n weblogic:\nclean:'
__mvnreporting_plugins=$'changelog:changelog\n\t changelog:dev-activity\n\t changelog:file-activity\n\t changelog:help\n\t changes:announcement-mail\n\t changes:announcement-generate\n\t changes:changes-report\n\t changes:jira-report\n\t changes:changes-validate\n\t changes:help\n\t checkstyle:checkstyle\n\t checkstyle:check\n\t checkstyle:help\n\t doap:generate\n\t doap:help\n\t docck:check\n\t docck:help\n\t javadoc:javadoc\n\t javadoc:test-javadoc\n\t javadoc:aggregate\n\t javadoc:test-aggregate\n\t javadoc:jar\n\t javadoc:test-jar\n\t javadoc:help\n\t jxr:jxr\n\t jxr:test-jxr\n\t jxr:help\n\t pmd:pmd\n\t pmd:cpd\n\t pmd:check\n\t pmd:cpd-check\n\t pmd:help\n\t project-info-reports:cim\n\t project-info-reports:dependencies\n\t project-info-reports:dependency-convergence\n\t project-info-reports:dependency-management\n\t project-info-reports:index\n\t project-info-reports:issue-tracking\n\t project-info-reports:license\n\t project-info-reports:mailing-list\n\t project-info-reports:plugin-management\n\t project-info-reports:project-team\n\t project-info-reports:scm\n\t project-info-reports:summary\n\t project-info-reports:help\n\t surefire-report:report\n\t surefire-report:report-only\n\t surefire-report:help'
__mvnscopes='compile test runtime system'
__mvnsite_phases=$'pre-site\n\t site\n\t post-site\n\t site-deploy'
__mvntools_plugins=$'ant:ant\n\t ant:clean\n\t ant:help\n\t antrun:run\n\t antrun:help\n\t archetype:create\n\t archetype:generate\n\t archetype:create-from-project\n\t archetype:crawl\n\t archetype:help\n\t assembly:assembly\n\t assembly:directory\n\t assembly:directory-single\n\t assembly:single\n\t assembly:help\n\t dependency:copy\n\t dependency:copy-dependencies\n\t dependency:unpack\n\t dependency:unpack-dependencies\n\t dependency:resolve\n\t dependency:list\n\t dependency:sources\n\t dependency:resolve-plugins\n\t dependency:go-offline\n\t dependency:purge-local-repository\n\t dependency:build-classpath\n\t dependency:analyze\n\t dependency:analyze-dep-mgt\n\t dependency:tree\n\t dependency:help\n\t enforcer:enforce\n\t enforcer:display-info\n\t enforcer:help\n\t gpg:sign\n\t gpg:sign-and-deploy-file\n\t gpg:help\n\t help:active-profiles\n\t help:all-profiles\n\t help:describe\n\t help:effective-pom\n\t help:effective-settings\n\t help:evaluate\n\t help:expressions\n\t help:system\n\t invoker:install\n\t invoker:run\n\t invoker:help\n\t one:convert\n\t one:deploy-maven-one-repository\n\t one:install-maven-one-repository\n\t one:maven-one-plugin\n\t one:help\n\t patch:apply\n\t patch:help\n\t pdf:pdf\n\t pdf:help\n\t plugin:descriptor\n\t plugin:report\n\t plugin:updateRegistry\n\t plugin:xdoc\n\t plugin:addPluginArtifactMetadata\n\t plugin:helpmojo\n\t plugin:help\n\t release:clean\n\t release:prepare\n\t release:rollback\n\t release:perform\n\t release:stage\n\t release:branch\n\t release:help\n\t reactor:resume\n\t reactor:make\n\t reactor:make-dependents\n\t reactor:make-scm-changes\n\t reactor:help\n\t remote-resources:bundle\n\t remote-resources:process\n\t remote-resources:help\n\t repository:bundle-create\n\t repository:bundle-pack\n\t repository:help\n\t scm:branch\n\t scm:validate\n\t scm:add\n\t scm:unedit\n\t scm:export\n\t scm:bootstrap\n\t scm:changelog\n\t scm:list\n\t scm:checkin\n\t scm:checkout\n\t scm:status\n\t scm:update\n\t scm:diff\n\t scm:update-subprojects\n\t scm:edit\n\t scm:tag\n\t scm:help\n\t source:aggregate\n\t source:jar\n\t source:test-jar\n\t source:jar-no-fork\n\t source:test-jar-no-fork\n\t source:help\n\t stage:copy\n\t stage:help'
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_system_arch=x86_64
_system_info='Linux jrborba-sirpa-6162200 4.9.80-c9 #1 SMP Wed Feb 7 08:47:46 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux'
_system_name=Ubuntu
_system_name_lowercase=ubuntu
_system_type=Linux
_system_version=14.04
_xspecs=([freeamp]="!*.@(mp3|og[ag]|pls|m3u)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [bibtex]="!*.aux" [rgview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm)" [chromium-browser]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [makeinfo]="!*.texi*" [kwrite]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [lrunzip]="!*.lrz" [bzcat]="!*.?(t)bz?(2)" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [rpm2cpio]="!*.[rs]pm" [view]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [ly2dvi]="!*.ly" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [lzgrep]="!*.@(tlz|lzma)" [pyflakes]="!*.py" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [dvipdfmx]="!*.dvi" [advi]="!*.dvi" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [lzmore]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [poedit]="!*.po" [firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [madplay]="!*.mp3" [lbzcat]="!*.?(t)bz?(2)" [lilypond]="!*.ly" [gtranslator]="!*.po" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [sxemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [epdfview]="!*.pdf" [gpdf]="!*.[pf]df" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [pbzcat]="!*.?(t)bz?(2)" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [lzcat]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [vim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [ps2pdf14]="!*.@(?(e)ps|pdf)" [dvips]="!*.dvi" [lzfgrep]="!*.@(tlz|lzma)" [hbrun]="!*.[Hh][Rr][Bb]" [kbabel]="!*.po" [rview]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [xv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [rgvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvitype]="!*.dvi" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [playmidi]="!*.@(mid?(i)|cmf)" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [xpdf]="!*.@(pdf|fdf)?(.@(gz|xz|Z|bz2))" [gqmpeg]="!*.@(mp3|og[ag]|pls|m3u)" [lzegrep]="!*.@(tlz|lzma)" [aviplay]="!*.@(avi|asf|wmv)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [bunzip2]="!*.?(t)bz?(2)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [znew]="*.Z" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lokalize]="!*.po" [kate]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.part)" [unlzma]="!*.@(tlz|lzma)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [vi]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [mozilla-firefox]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [gvim]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [uncompress]="!*.Z" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [unpigz]="!*.@(Z|[gGd]z|t[ag]z)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [emacs]="*.@(o|so|so.!(conf|*/*)|a|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wma|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|wmv|mp[234]|MP[234]|m4[pv]|M4[PV]|mkv|MKV|og[agmvx]|OG[AGMVX]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.part)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [ps2pdf]="!*.@(?(e)ps|pdf)" [kpdf]="!*.@(?(e)ps|pdf)" [oomath]="!*.@(sxm|smf|mml|odf)" [compress]="*.Z" [iceweasel]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [mpg321]="!*.mp3" [mpg123]="!*.mp3" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [unzip]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [pbunzip2]="!*.?(t)bz?(2)" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [dvipdf]="!*.dvi" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|okta|p[st]m|s[3t]m|ult|umx|wav|xm)" [dvipdfm]="!*.dvi" [oobase]="!*.odb" [texi2html]="!*.texi*" [zipinfo]="!*.@(zip|[ejsw]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|do[ct][xm]|p[op]t[mx]|xl[st][xm])" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [google-chrome]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2)))" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [bzme]="!*.@(zip|z|gz|tgz)" [xfig]="!*.fig" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [dviselect]="!*.dvi" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" )
a=workspace
activate=/home/ubuntu/.virtualenvs/workspace/bin/activate
chpwd_functions=([0]="__rvm_cd_functions_set")
entry=list
file=/home/ubuntu/.rvmrc
i=1
in_args=([0]="workspace")
rvm_bin_path=/usr/local/rvm/bin
rvm_ignore_rvmrc=0
rvm_path=/usr/local/rvm
rvm_prefix=/usr/local
rvm_rubygems_path=/usr/local/rvm/rubygems
rvm_saved_env=()
rvm_silence_path_mismatch_check_flag=1
rvm_version='1.29.2 (latest)'
rvmrc=/usr/local/.rvmrc
script=override_gem
tst=-lt
virtualenvwrapper_original_deactivate=$'virtualenv_deactivate () \n{ \n    unset -f pydoc > /dev/null 2>&1;\n    if ! [ -z "${_OLD_VIRTUAL_PATH+_}" ]; then\n        PATH="$_OLD_VIRTUAL_PATH";\n        export PATH;\n        unset _OLD_VIRTUAL_PATH;\n    fi;\n    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ]; then\n        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME";\n        export PYTHONHOME;\n        unset _OLD_VIRTUAL_PYTHONHOME;\n    fi;\n    if [ -n "${BASH-}" ] || [ -n "${ZSH_VERSION-}" ]; then\n        hash -r 2> /dev/null;\n    fi;\n    if ! [ -z "${_OLD_VIRTUAL_PS1+_}" ]; then\n        PS1="$_OLD_VIRTUAL_PS1";\n        export PS1;\n        unset _OLD_VIRTUAL_PS1;\n    fi;\n    unset VIRTUAL_ENV;\n    if [ ! "${1-}" = "nondestructive" ]; then\n        unset -f virtualenv_deactivate;\n    fi\n}'
__expand_tilde_by_ref () 
{ 
    if [[ ${!1} == \~* ]]; then
        if [[ ${!1} == */* ]]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__function_on_stack () 
{ 
    __rvm_string_includes "${FUNCNAME[*]}" "$@" || return $?
}
__function_unset () 
{ 
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        unset -f "$1";
    else
        unset "$1";
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur index=$COMP_POINT lead=${COMP_LINE:0:$COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i ))
        do
            while [[ ${#cur} -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                cur="${cur:1}";
                ((index--));
            done;
            if [[ $i -lt $cword ]]; then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                index=$(( index - old_size + new_size ));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]} ]] && cur=;
        [[ $index -lt 0 ]] && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "${cur:0:$index}"
}
__git_eread () 
{ 
    local f="$1";
    shift;
    test -r "$f" && read "$@" < "$f"
}
__git_ps1 () 
{ 
    local exit=$?;
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}";
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return $exit
        ;;
    esac;
    local ps1_expanded=yes;
    [ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        return $exit;
    fi;
    local short_sha="";
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
        return $exit;
    fi;
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_eread "$g/rebase-merge/end" total;
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            __git_eread "$g/rebase-apply/next" step;
            __git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                __git_eread "$g/rebase-apply/head-name" b;
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! __git_eread "$g/HEAD" head; then
                    return $exit;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(tag)
					git describe --tags HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet || w="*";
                git diff --no-ext-diff --cached --quiet || i="+";
                if [ -z "$short_sha" ] && [ -z "$i" ]; then
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    b=${b##refs/heads/};
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
        __git_ps1_branch_name=$b;
        b="\${__git_ps1_branch_name}";
    fi;
    local f="$w$i$s$u";
    local gitstring="$c$b${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi;
    return $exit
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            __git_ps1_upstream_name=$(git rev-parse 				--abbrev-ref "$upstream" 2>/dev/null);
            if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
                p="$p \${__git_ps1_upstream_name}";
            else
                p="$p ${__git_ps1_upstream_name}";
                unset __git_ps1_upstream_name;
            fi;
        fi;
    fi
}
__list_remote_all () 
{ 
    \typeset _iterator rvm_remote_server_url rvm_remote_server_path;
    _iterator="";
    while __rvm_db "rvm_remote_server_url${_iterator:-}" rvm_remote_server_url; do
        __rvm_include_travis_binaries || continue;
        __rvm_system_path "" "${_iterator}";
        rvm_debug "__list_remote_all${_iterator:-} $rvm_remote_server_url $rvm_remote_server_path";
        __list_remote_for "${rvm_remote_server_url}" "$rvm_remote_server_path";
        : $(( _iterator+=1 ));
    done | \command \sort -u | __rvm_version_sort
}
__list_remote_for () 
{ 
    __list_remote_for_local "$@" || __list_remote_for_index "$@" || __list_remote_for_s3 "$@" || return $?
}
__list_remote_for_index () 
{ 
    if file_exists_at_url "${1}/index.txt"; then
        rvm_debug "__list_remote_for_index ${1}/index.txt";
        __rvm_curl -s "${1}/index.txt" | GREP_OPTIONS="" \command \grep -E "${1}/${2}/.*\.tar\.(gz|bz2)$";
    else
        if file_exists_at_url "${1}/${2}/index.txt"; then
            rvm_debug "__list_remote_for_index ${1}/${2}/index.txt";
            __rvm_curl -s "${1}/${2}/index.txt" | GREP_OPTIONS="" \command \grep -E "${1}/${2}/.*\.tar\.(gz|bz2)$";
        else
            return 1;
        fi;
    fi;
    true
}
__list_remote_for_local () 
{ 
    \typeset __status1 __status2;
    __status1=0;
    __status2=0;
    if [[ -f $rvm_user_path/remote ]]; then
        __rvm_grep "${1}/${2}" < $rvm_user_path/remote || __status1=$?;
    fi;
    __rvm_grep "${1}/${2}" < $rvm_path/config/remote || __status2=$?;
    if (( __status1 || __status2 )); then
        return 1;
    else
        rvm_debug "__list_remote_for_local found";
    fi;
    true
}
__list_remote_for_s3 () 
{ 
    curl -ILfs "${1}" | __rvm_grep "Server: AmazonS3" > /dev/null || return $?;
    \typeset __tmp_name __iterator __next __local_url;
    __iterator=0;
    __next="";
    __tmp_name="$(
    : ${TMPDIR:=${rvm_tmp_path:-/tmp}}
    mktemp "${TMPDIR}/tmp.XXXXXXXXXXXXXXXXXX"
  )";
    while [[ __iterator -eq 0 || -n "${__next}" ]]; do
        __local_url="${1}?prefix=${2}/${__next:+&marker=${__next}}";
        rvm_debug "__list_remote_for_s3-${__iterator} ${__local_url}";
        __rvm_curl -s "${__local_url}" > "${__tmp_name}${__iterator}";
        GREP_OPTIONS="" \command \grep -oE "<Key>[^<]*</Key>" < "${__tmp_name}${__iterator}" | __rvm_awk -F"[<>]" '{print $3}' > "${__tmp_name}";
        if __rvm_grep "<IsTruncated>true</IsTruncated>" < "${__tmp_name}${__iterator}"; then
            __next="$(__rvm_tail -n 1 "${__tmp_name}")";
        else
            __next="";
        fi;
        rm "${__tmp_name}${__iterator}";
        : $(( __iterator+=1 ));
    done;
    GREP_OPTIONS="" \command \grep -E "${2}/.*\.tar\.(gz|bz2)$" < "${__tmp_name}" | GREP_OPTIONS="" \command \grep -v -- "-src-" | __rvm_awk "{ print "'"'$1/'"'"\$1 }";
    rm "${__tmp_name}"*
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && "$COMP_WORDBREAKS" == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while [[ $((--i)) -ge 0 ]]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__mvnarchetype_generate () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        basedir=*)
            COMPREPLY=($( compgen -d -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        *)
            local options="archetypeArtifactId= archetypeCatalog= archetypeGroupId= archetypeRepository= archetypeVersion= basedir=press basedir=tab goals= interactiveMode=";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac;
    __mvncomp "archetypeArtifactId= archetypeCatalog= archetypeGroupId= archetypeRepository= archetypeVersion= basedir= goals= interactiveMode=" "-D" "${cur}"
}
__mvncomp () 
{ 
    local genOpt=;
    if [ "$1" == "-nospace" ]; then
        genOpt="true";
        shift;
    fi;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        -*=)
            COMPREPLY=()
        ;;
        *)
            local IFS='
';
            COMPREPLY=($(compgen -P "$2" 			-W "$(__mvncomp_1 "$1" "$4")" 			-- "$cur"))
        ;;
    esac
}
__mvncomp_1 () 
{ 
    local c IFS=' ''	''
';
    for c in $1;
    do
        case "$c$2" in 
            --*=*)
                printf %s'
' "$c$2"
            ;;
            *.)
                printf %s'
' "$c$2"
            ;;
            *)
                printf %s'
' "$c$2 "
            ;;
        esac;
    done
}
__mvndependency_analyze () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "ignoreNonCompile=true outputXML=true scriptableFlag= scriptableOutput=true verbose=true" "-D" "${cur}"
}
__mvndependency_analyze_dep_mgt () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "ignoreDirect=false" "-D" "${cur}"
}
__mvndependency_purge_local_repository () 
{ 
    local fuzziness="file version artifactId groupId";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        resolutionFuzziness=*)
            __mvncomp "${fuzziness}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "actTransitively=false exclude= reResolve=false verbose=true
			$(__mvnlist_prefix 'resolutionFuzziness=' ${fuzziness})";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_resolve () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        classifier=*)
            __mvncomp "${__mvnclassifiers}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "$(__mvnlist_prefix 'classifier=' ${__mvnclassifiers}) excludeArtifactIds= excludeClassifiers= excludeGroupIds=
			excludeScope= excludeTransitive=true excludeTypes= includeArtifactIds= includeClassifiers= includeGroupIds= includeScope= 
			includeTypes= markersDirectory= outputAbsoluteArtifactFilename= outputFile= outputScope=false overWriteIfNewer=false
			overWriteReleases=true overWriteSnapshots=true silent=true type=";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_tree () 
{ 
    local tokens="whitespace standard extended";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        tokens=*)
            __mvncomp "${tokens}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "excludes= includes= outputFile= scope= verbose=true
			$(__mvnlist_prefix 'tokens=' ${tokens})";
            "-D" "${cur}"
        ;;
    esac
}
__mvndependency_x_dependencies () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        classifier=*)
            __mvncomp "${__mvnclassifiers}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "$(__mvnlist_prefix 'classifier=' ${__mvnclassifiers})" "-D" "${cur}"
        ;;
    esac
}
__mvndeploy_deploy () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "altDeploymentRepository= skip=true updateReleaseInfo=true" "-D" "${cur}"
}
__mvndeploy_deploy_file () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        file=*)
            COMPREPLY=($( compgen -f -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        pomFile=*)
            __mvncomp "$(__mvnlist_poms)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        packaging=*)
            __mvncomp "${__mvnpackaging}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="artifactId= classifier= description= file=press file=tab generatePom=true groupId= pomFile=press pomFile=tab repositoryId= 
		  repositoryLayout=legacy uniqueVersion=false url= version=";
            options="$options $(__mvnlist_prefix 'packaging=' ${__mvnpackaging} )";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac
}
__mvnexec_java () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [[ "${cur}" == "=" ]]; then
        cur="${COMP_WORDS[COMP_CWORD-1]}=";
    fi;
    cur="${cur#-Dexec.}";
    case "${cur}" in 
        classpathScope=*)
            __mvncomp "${__mvnscopes}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="mainClass= args= arguments= includeProjectDependencies=false includePluginDependencies=true
		 classpathScope=press classpathScope=tab
		 cleanupDaemonThreads=false daemonThreadJoinTimeout= stopUnresponsiveDaemonThreads=";
            __mvncomp "$options" "-Dexec." "${cur}"
        ;;
    esac
}
__mvnhelp_describe () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        cmd=*:*)
            local plugin="${cur#*=}";
            plugin="${plugin%%:*}:";
            __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cur)" "${cur#*:}"
        ;;
        cmd=*)
            __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        plugin=*)
            __mvncomp "org.apache.maven.plugins:maven-" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        groupId=*)
            __mvncomp "org.apache.maven.plugins" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        artifactId=*)
            __mvncomp "" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "detail cmd=press cmd=tab plugin= groupId= artifactId=" "-D" "${cur}"
        ;;
    esac
}
__mvninstall_install_file () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        file=*)
            COMPREPLY=($( compgen -f -P "$(__mvnprefix_equals $cur)" -- "${cur#*=}" ))
        ;;
        pomFile=*)
            __mvncomp "$(__mvnlist_poms)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        sources=*)
            __mvncomp "$(__mvnlist_jars)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        javadoc=*)
            __mvncomp "$(__mvnlist_jars)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        packaging=*)
            __mvncomp "${__mvnpackaging}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            local options="artifactId= classifier= file=press file=tab generatePom=true groupId= pomFile=press pomFile=tab
		  createChecksum=true url= version= sources=press sources=tab javadoc=press javadoc=tab";
            options="$options $(__mvnlist_prefix 'packaging=' ${__mvnpackaging} )";
            __mvncomp "$options" "-D" "${cur}"
        ;;
    esac
}
__mvnlist_goals () 
{ 
    local plugin=$1;
    local pfx="";
    if [[ -n "$2" ]]; then
        pfx=$2;
    fi;
    echo ${__mvnall_plugin_and_goals} | tr ' ' '\n' | grep --color=auto "$plugin" | sed "s/.*:/${pfx}/g"
}
__mvnlist_jars () 
{ 
    for x in `find -type f -name *.jar`;
    do
        echo ${x#./};
    done
}
__mvnlist_poms () 
{ 
    for x in `find -type f -name pom.xml -or -name *.pom`;
    do
        echo ${x#./};
    done
}
__mvnlist_prefix () 
{ 
    local pfx=$1 IFS=' ''	''
';
    shift;
    local list=$@;
    for c in $list;
    do
        echo "$pfx$c";
    done
}
__mvnlist_projects () 
{ 
    local poms=$(find . -name pom.xml -print);
    echo $poms | while read -d ' ' POM; do
        local DIR=$(dirname "$POM");
        if [[ "$DIR" != "." ]]; then
            echo "${DIR#./}";
        fi;
    done
}
__mvnplugin_help () 
{ 
    local plugin=$1;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        goal=*)
            __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "detail lineLength= indentSize= $(__mvnlist_goals $plugin 'goal=')" "-D" "${cur}"
        ;;
    esac
}
__mvnprefix_colon () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *:*)
            : great
        ;;
        *)
            pfx="${cur%%:*}:"
        ;;
    esac;
    echo $pfx
}
__mvnprefix_comma () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *,*)
            : great
        ;;
        *)
            pfx="${cur%%,*},"
        ;;
    esac;
    echo $pfx
}
__mvnprefix_equals () 
{ 
    local cur=$1;
    local pfx="";
    case "$COMP_WORDBREAKS" in 
        *=*)
            : great
        ;;
        *)
            pfx="${cur%%=*}="
        ;;
    esac;
    echo $pfx
}
__mvnrelease_prepare () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    __mvncomp "username= dryRun=true" "-D" "${cur}"
}
__mvnscm_checkin () 
{ 
    local versionType="branch tag revision";
    local cur="${COMP_WORDS[COMP_CWORD]}";
    cur="${cur#-D}";
    case "${cur}" in 
        scmVersionType=*)
            __mvncomp "${versionType}" "$(__mvnprefix_equals $cur)" "${cur#*=}"
        ;;
        *)
            __mvncomp "username= message= passphrase= password= scmVersion= $(__mvnlist_prefix 'scmVersionType=' ${versionType})" "-D" "${cur}"
        ;;
    esac
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    for i in $1;
    do
        case $i in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} == +([$exclude]) ]]; do
                [[ $line != [' 	']* ]] && (( j >= 2 )) && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [[ $i == $COMP_CWORD ]] && eval $3=$j;
                line=${line#*"${COMP_WORDS[$i]}"};
                [[ $line == [' 	']* ]] && ((j++));
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            line=${line#*"${COMP_WORDS[i]}"};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
        [[ $i == $COMP_CWORD ]] && eval $3=$j;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__rvm_add_once () 
{ 
    \typeset IFS;
    IFS="|";
    eval "[[ \"${IFS}\${${1}[*]}${IFS}\" == \*\"${IFS}\${2}${IFS}\"\* ]] || ${1}+=( \"\${2}\" )"
}
__rvm_add_to_path () 
{ 
    export PATH;
    if (( $# != 2 )) || [[ -z "$2" ]]; then
        rvm_error "__rvm_add_to_path requires two parameters";
        return 1;
    fi;
    __rvm_remove_from_path "$2";
    case "$1" in 
        prepend)
            PATH="$2:$PATH"
        ;;
        append)
            PATH="$PATH:$2"
        ;;
    esac;
    if [[ -n "${rvm_user_path_prefix:-}" ]]; then
        __rvm_remove_from_path "${rvm_user_path_prefix}";
        PATH="${rvm_user_path_prefix}:$PATH";
    fi;
    builtin hash -r
}
__rvm_after_cd () 
{ 
    \typeset rvm_hook;
    rvm_hook="after_cd";
    if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]; then
        source "${rvm_scripts_path:-$rvm_path/scripts}/hook";
    fi
}
__rvm_ant () 
{ 
    \ant "$@" || return $?
}
__rvm_array_add_or_update () 
{ 
    \typeset _array_name _variable _separator _value _local_value;
    \typeset -a _array_value_old _array_value_new;
    _array_name="$1";
    _variable="$2";
    _separator="$3";
    _value="${4##${_separator}}";
    _array_value_new=();
    eval "_array_value_old=( \"\${${_array_name}[@]}\" )";
    case " ${_array_value_old[*]} " in 
        *[[:space:]]${_variable}*)
            for _local_value in "${_array_value_old[@]}";
            do
                case "${_local_value}" in 
                    ${_variable}*)
                        _array_value_new+=("${_local_value}${_separator}${_value}")
                    ;;
                    *)
                        _array_value_new+=("${_local_value}")
                    ;;
                esac;
            done
        ;;
        *)
            _array_value_new=("${_array_value_old[@]}" "${_variable}${_value}")
        ;;
    esac;
    eval "${_array_name}=( \"\${_array_value_new[@]}\" )"
}
__rvm_array_contains () 
{ 
    \typeset _search _iterator;
    _search="$1";
    shift;
    for _iterator in "$@";
    do
        case "${_iterator}" in 
            ${_search})
                return 0
            ;;
        esac;
    done;
    return 1
}
__rvm_array_prepend_or_ignore () 
{ 
    \typeset _array_name _variable _separator _value _prefix _local_value;
    \typeset -a _array_value_old _array_value_new;
    _array_name="$1";
    _variable="$2";
    _separator="$3";
    _value="$4";
    _prefix="$5";
    _array_value_new=();
    eval "_array_value_old=( \"\${${_array_name}[@]}\" )";
    case " ${_array_value_old[*]} " in 
        *[[:space:]]${_variable}*)
            for _local_value in "${_array_value_old[@]}";
            do
                case "${_local_value}" in 
                    ${_variable}*${_prefix}*)
                        rvm_debug "__rvm_array_prepend_or_ignore ${_array_name} ${_local_value}";
                        _array_value_new+=("${_local_value}")
                    ;;
                    ${_variable}*)
                        rvm_debug "__rvm_array_prepend_or_ignore ${_array_name} ${_variable}\"${_value}${_separator}${_local_value#${_variable}}\"";
                        _array_value_new+=("${_variable}${_value}${_separator}${_local_value#${_variable}}")
                    ;;
                    *)
                        _array_value_new+=("${_local_value}")
                    ;;
                esac;
            done;
            eval "${_array_name}=( \"\${_array_value_new[@]}\" )"
        ;;
    esac
}
__rvm_ask_for () 
{ 
    \typeset response;
    rvm_warn "$1";
    printf "%b" "(anything other than '$2' will cancel) > ";
    if read response && [[ "$2" == "$response" ]]; then
        return 0;
    else
        return 1;
    fi
}
__rvm_ask_to_trust () 
{ 
    \typeset trusted value anykey _rvmrc _rvmrc_base;
    _rvmrc="${1}";
    _rvmrc_base="$(basename "${_rvmrc}")";
    if [[ ! -t 0 || -n "$MC_SID" ]] || (( ${rvm_promptless:=0} == 1 )); then
        return 2;
    fi;
    __rvm_file_notice_initial;
    trusted=0;
    while (( ! trusted )); do
        printf "%b" 'y[es], n[o], v[iew], c[ancel]> ';
        builtin read response;
        value="$(echo -n "${response}" | \command \tr '[[:upper:]]' '[[:lower:]]' | __rvm_strip)";
        case "${value:-n}" in 
            v | view)
                __rvm_display_rvmrc
            ;;
            y | yes)
                trusted=1
            ;;
            n | no)
                break
            ;;
            c | cancel)
                return 1
            ;;
        esac;
    done;
    if (( trusted )); then
        __rvm_trust_rvmrc "$1";
        return 0;
    else
        __rvm_untrust_rvmrc "$1";
        return 1;
    fi
}
__rvm_automake () 
{ 
    \automake "$@" || return $?
}
__rvm_autoreconf () 
{ 
    \autoreconf "$@" || return $?
}
__rvm_awk () 
{ 
    \awk "$@" || return $?
}
__rvm_become () 
{ 
    \typeset string rvm_rvmrc_flag;
    string="$1";
    rvm_rvmrc_flag=0;
    [[ -n "$string" ]] && { 
        rvm_ruby_string="$string";
        rvm_gemset_name=""
    };
    __rvm_use > /dev/null || return $?;
    rvm_ruby_string="${rvm_ruby_string}${rvm_gemset_name:+${rvm_gemset_separator:-'@'}}${rvm_gemset_name:-}";
    return 0
}
__rvm_calculate_remote_file () 
{ 
    rvm_remote_server_url="$( __rvm_db "rvm_remote_server_url${3:-}" )";
    [[ -n "$rvm_remote_server_url" ]] || { 
        rvm_debug "rvm_remote_server_url${3:-} not found";
        return $1
    };
    __rvm_include_travis_binaries || return $1;
    __rvm_system_path "" "${3:-}";
    __rvm_ruby_package_file "${4:-}";
    __remote_file="${rvm_remote_server_url}/${rvm_remote_server_path}${rvm_ruby_package_file}"
}
__rvm_calculate_space_free () 
{ 
    __free_space="$( \command \df -Pk "$1" | __rvm_awk 'BEGIN{x=4} /Free/{x=3} $3=="Avail"{x=3} END{print $x}' )";
    if [[ "${__free_space}" == *M ]]; then
        __free_space="${__free_space%M}";
    else
        __free_space="$(( __free_space / 1024 ))";
    fi
}
__rvm_calculate_space_used () 
{ 
    __used_space="$( \command \du -msc "$@" | __rvm_awk 'END {print $1}' )";
    __used_space="${__used_space%M}"
}
__rvm_call_with_restored_umask () 
{ 
    rvm_umask="$(umask)";
    if [[ -n "${rvm_stored_umask:-}" ]]; then
        umask ${rvm_stored_umask};
    fi;
    "$@";
    umask "${rvm_umask}";
    unset rvm_umask
}
__rvm_cd () 
{ 
    \typeset old_cdpath ret;
    ret=0;
    old_cdpath="${CDPATH}";
    CDPATH=".";
    chpwd_functions="" builtin cd "$@" || ret=$?;
    CDPATH="${old_cdpath}";
    return $ret
}
__rvm_cd_functions_set () 
{ 
    __rvm_do_with_env_before;
    if [[ -n "${rvm_current_rvmrc:-""}" && "$OLDPWD" == "$PWD" ]]; then
        rvm_current_rvmrc="";
    fi;
    __rvm_project_rvmrc 1>&2 || true;
    __rvm_after_cd || true;
    __rvm_do_with_env_after;
    return 0
}
__rvm_check_pipestatus () 
{ 
    for __iterator in "$@";
    do
        case "${__iterator}" in 
            "")
                true
            ;;
            0)
                true
            ;;
            *)
                return ${__iterator}
            ;;
        esac;
    done;
    return 0
}
__rvm_check_rvmrc_trustworthiness () 
{ 
    (( ${rvm_trust_rvmrcs_flag:-0} == 0 )) || return 0;
    [[ -n "$1" ]] || (( $# > 1 )) || return 1;
    \typeset _first _second saveIFS;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _first=1;
    else
        _first=0;
    fi;
    _second=$(( _first + 1 ));
    saveIFS="$IFS";
    IFS=';';
    \typeset -a trust;
    trust=($( __rvm_rvmrc_stored_trust "$1" ));
    IFS="$saveIFS";
    if [[ "${trust[${_second}]:-'#'}" == "$(__rvm_checksum_for_contents "$1")" ]]; then
        [[ "${trust[${_first}]}" == '1' ]] || return $?;
    else
        __rvm_ask_to_trust "$@" || return $?;
    fi;
    true
}
__rvm_checksum_all () 
{ 
    [[ -n "${_checksum_md5:-}" && -n "${_checksum_sha512:-}" ]]
}
__rvm_checksum_any () 
{ 
    [[ -n "${_checksum_md5:-}" || -n "${_checksum_sha512:-}" ]]
}
__rvm_checksum_calculate_file () 
{ 
    _checksum_md5="$(    __rvm_md5_calculate      "${1:-}" )";
    _checksum_sha512="$( __rvm_sha__calculate 512 "${1:-}" )"
}
__rvm_checksum_for_contents () 
{ 
    \typeset __sum;
    __sum=$(  echo "$1" | \command \cat - "$1" | __rvm_md5_for_contents   ) || { 
        rvm_error "Neither md5 nor md5sum were found in the PATH";
        return 1
    };
    __sum+=$( echo "$1" | \command \cat - "$1" | __rvm_sha256_for_contents ) || { 
        rvm_error "Neither sha256sum nor shasum found in the PATH";
        return 1
    };
    echo ${__sum}
}
__rvm_checksum_none () 
{ 
    [[ -z "${_checksum_md5:-}" && -z "${_checksum_sha512:-}" ]]
}
__rvm_checksum_read () 
{ 
    __rvm_checksum_none || return 0;
    \typeset _type _value _name;
    \typeset -a _list;
    list=();
    for _name in "$@";
    do
        list+=("$_name");
        if [[ "$_name" == *"?"* ]]; then
            list+=("${_name%\?*}");
        fi;
    done;
    for _name in "${list[@]}";
    do
        _checksum_md5="$(      __rvm_db_ "$rvm_path/config/md5"    "$_name" | \command \head -n 1 )";
        [[ -n "${_checksum_md5:-}" ]] || _checksum_md5="$(    __rvm_db_ "$rvm_user_path/md5"      "$_name" | \command \head -n 1 )";
        _checksum_sha512="$(   __rvm_db_ "$rvm_path/config/sha512" "$_name" | \command \head -n 1 )";
        [[ -n "${_checksum_sha512:-}" ]] || _checksum_sha512="$( __rvm_db_ "$rvm_user_path/sha512"   "$_name" | \command \head -n 1 )";
        __rvm_checksum_none || return 0;
    done;
    return 1
}
__rvm_checksum_validate_file () 
{ 
    __rvm_checksum_any || return 1;
    if [[ -n "${_checksum_md5:-}" ]]; then
        [[ "$(__rvm_md5_calculate "${1:-}")" == "${_checksum_md5:-}" ]] || return 2;
    fi;
    if [[ -n "${_checksum_sha512:-}" ]]; then
        [[ "$(__rvm_sha__calculate 512 "${1:-}")" == "${_checksum_sha512:-}" ]] || return 3;
    fi;
    return 0
}
__rvm_checksum_write () 
{ 
    [[ -n "${1:-}" ]] || return 1;
    __rvm_checksum_any || return 1;
    [[ -z "${_checksum_md5:-}" ]] || __rvm_db_ "$rvm_user_path/md5" "${1:-}" "${_checksum_md5:-}";
    [[ -z "${_checksum_sha512:-}" ]] || __rvm_db_ "$rvm_user_path/sha512" "${1:-}" "${_checksum_sha512:-}";
    return 0
}
__rvm_cleanse_variables () 
{ 
    __rvm_unset_ruby_variables;
    if [[ ${rvm_sticky_flag:-0} -eq 1 ]]; then
        export rvm_gemset_name;
    else
        unset rvm_gemset_name;
    fi;
    unset rvm_configure_flags rvm_patch_names rvm_make_flags;
    unset rvm_env_string rvm_ruby_string rvm_action rvm_error_message rvm_force_flag rvm_debug_flag rvm_delete_flag rvm_summary_flag rvm_json_flag rvm_yaml_flag rvm_file_name rvm_user_flag rvm_system_flag rvm_install_flag rvm_llvm_flag rvm_sticky_flag rvm_rvmrc_flag rvm_gems_flag rvm_docs_flag rvm_ruby_alias rvm_static_flag rvm_archive_extension rvm_hook rvm_ruby_name rvm_remote_flag;
    __rvm_load_rvmrc
}
__rvm_cleanup_tmp () 
{ 
    if [[ -d "${rvm_tmp_path}/" ]]; then
        case "${rvm_tmp_path%\/}" in 
            *tmp)
                __rvm_rm_rf "${rvm_tmp_path}/${1:-$$}*"
            ;;
        esac;
    fi;
    true
}
__rvm_cli_autoreload () 
{ 
    if [[ ${rvm_reload_flag:-0} -eq 1 ]]; then
        if [[ -s "$rvm_scripts_path/rvm" ]]; then
            __rvm_project_rvmrc_lock=0;
            source "$rvm_scripts_path/rvm";
        else
            echo "rvm not found in $rvm_path, please install and run 'rvm reload'";
            __rvm_teardown;
        fi;
    else
        __rvm_teardown;
    fi
}
__rvm_cli_autoupdate () 
{ 
    [[ " $* " == *" install "* && " $* " != *" help install "* ]] || [[ " $* " == *" list known "* ]] || return 0;
    \typeset online_version version_release;
    case "${rvm_autoupdate_flag:-1}" in 
        0 | disabled)
            true
        ;;
        1 | warn)
            if __rvm_cli_autoupdate_version_old; then
                __rvm_cli_autoupdate_warning;
            fi
        ;;
        2 | enabled)
            if __rvm_cli_autoupdate_version_old; then
                __rvm_cli_autoupdate_execute || return $?;
            fi
        ;;
    esac;
    true
}
__rvm_cli_autoupdate_execute () 
{ 
    printf "%b" "Found old RVM ${rvm_version%% *} - updating.\n";
    __rvm_cli_rvm_get "${version_release}" || return $?;
    __rvm_cli_rvm_reload
}
__rvm_cli_autoupdate_version_old () 
{ 
    online_version="$( __rvm_remote_version )";
    version_release="$(\command \cat "$rvm_path/RELEASE" 2>/dev/null)";
    : version_release:"${version_release:=master}";
    [[ -s "$rvm_path/VERSION" && -n "${online_version:-}" && "${rvm_version%% *}" != "${online_version:-}" ]] || return $?
}
__rvm_cli_autoupdate_warning () 
{ 
    printf "%b" "Warning, new version of rvm available '${online_version}', you are using older version '${rvm_version%% *}'.
You can disable this warning with:    echo rvm_autoupdate_flag=0 >> ~/.rvmrc
You can enable  auto-update  with:    echo rvm_autoupdate_flag=2 >> ~/.rvmrc
"
}
__rvm_cli_get_and_execute_installer () 
{ 
    __rvm_cli_get_installer_cleanup || return $?;
    rvm_log "Downloading https://get.rvm.io";
    __rvm_curl -s https://get.rvm.io -o "${rvm_archives_path}/rvm-installer" || { 
        \typeset _ret=$?;
        rvm_error "Could not download rvm-installer, get some help at #rvm IRC channel at freenode servers.";
        return ${_ret}
    };
    __rvm_cli_get_and_verify_pgp || return $?;
    bash "${rvm_archives_path}/rvm-installer" "$@" || { 
        \typeset _ret=$?;
        rvm_error "Could not update RVM, get some help at #rvm IRC channel at freenode servers.";
        return ${_ret}
    }
}
__rvm_cli_get_and_verify_pgp () 
{ 
    \typeset rvm_gpg_command;
    if rvm_install_gpg_setup; then
        pgp_signature_url="$( __rvm_curl -sSI https://get.rvm.io | \tr "\r" " " | __rvm_awk '/Location:/{print $2".asc"}' )";
        rvm_log "Downloading $pgp_signature_url";
        __rvm_curl -s "${pgp_signature_url}" -o "${rvm_archives_path}/rvm-installer.asc" || return $?;
        rvm_log "Verifying ${rvm_archives_path}/rvm-installer.asc";
        verify_package_pgp "${rvm_archives_path}/rvm-installer" "${rvm_archives_path}/rvm-installer.asc" "$pgp_signature_url" || return $?;
    else
        rvm_warn "No GPG software exists to validate rvm-installer, skipping.";
    fi
}
__rvm_cli_get_installer_cleanup () 
{ 
    [[ -w "${rvm_archives_path}" ]] || { 
        rvm_error "Archives path '${rvm_archives_path}' not writable, aborting.";
        return 1
    };
    [[ ! -e "${rvm_archives_path}/rvm-installer" ]] || rm -f "${rvm_archives_path}/rvm-installer" || { 
        rvm_error "Previous installer '${rvm_archives_path}/rvm-installer' exists and can not be removed, aborting.";
        return 2
    }
}
__rvm_cli_install_ruby () 
{ 
    ( if [[ -n "$1" ]]; then
        \typeset __rubies __installed __missing __search_list;
        \typeset -a __search;
        __rvm_custom_separated_array __search , "$1";
        __rubies="$1";
        __search_list="";
        __rvm_cli_rubies_select || return $?;
        if __rvm_cli_rubies_not_installed; then
            __rvm_run_wrapper manage install "${__rubies}" || return $?;
        fi;
    else
        rvm_error "Can not use or install 'all' rubies.";
        false;
    fi )
}
__rvm_cli_load_rvmrc () 
{ 
    if (( ${rvm_ignore_rvmrc:=0} == 0 )); then
        [[ -n "${rvm_stored_umask:-}" ]] || export rvm_stored_umask=$(umask);
        rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc");
        if [[ -n "${rvm_prefix:-}" ]] && [[ ! "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]; then
            rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc");
        fi;
        for rvmrc in "${rvm_rvmrc_files[@]}";
        do
            if [[ -f "$rvmrc" ]]; then
                if __rvm_grep '^\s*rvm .*$' "$rvmrc" > /dev/null 2>&1; then
                    printf "%b" "
Error:
        $rvmrc is for rvm settings only.
        rvm CLI may NOT be called from within $rvmrc.
        Skipping the loading of $rvmrc";
                    return 1;
                else
                    source "$rvmrc";
                fi;
            fi;
        done;
        unset rvm_rvmrc_files;
    fi
}
__rvm_cli_posix_check () 
{ 
    if __rvm_has_opt "posix"; then
        echo "RVM can not be run with \`set -o posix\`, please turn it off and try again.";
        return 100;
    fi
}
__rvm_cli_rubies_not_installed () 
{ 
    if (( ${rvm_force_flag:-0} == 0 )) && __installed="$(
      __rvm_list_strings | __rvm_grep -E "${__search_list}"
    )" && [[ -n "${__installed}" ]]; then
        rvm_warn "Already installed ${__installed//|/,}.
To reinstall use:

    rvm reinstall ${__installed//|/,}
";
        return 2;
    fi;
    true
}
__rvm_cli_rubies_select () 
{ 
    \typeset __ruby;
    for __ruby in "${__search[@]}";
    do
        rvm_ruby_string="${__ruby}";
        __rvm_select && if [[ -n "$rvm_ruby_string" ]]; then
            __search_list+="^$rvm_ruby_string\$|";
        else
            rvm_error "Could not detect ruby version/name for installation '${__ruby}', please be more specific.";
            return 1;
        fi;
    done;
    __search_list="${__search_list%|}"
}
__rvm_cli_rvm_get () 
{ 
    case "$1" in 
        [0-9]*.[0-9]*.[0-9]*)
            rvm_warn "
Hi there, it looks like you have requested updating rvm to version $1,
if your intention was ruby installation use instead: rvm install $1
"
        ;;
    esac;
    case "$1" in 
        stable | master | head | branch | latest | latest-* | [0-9]*.[0-9]*.[0-9]*)
            __rvm_cli_get_and_execute_installer "$@" || return $?;
            \typeset -x rvm_hook;
            rvm_hook="after_update";
            source "${rvm_scripts_path:-"$rvm_path/scripts"}/hook";
            rvm_reload_flag=1
        ;;
        *)
            rvm_help get
        ;;
    esac
}
__rvm_cli_rvm_reload () 
{ 
    __rvm_project_rvmrc_lock=0;
    rvm_reload_flag=1;
    source "${rvm_scripts_path:-${rvm_path}/scripts}/rvm"
}
__rvm_cli_version_check () 
{ 
    \typeset disk_version;
    disk_version="$(\command \cat "$rvm_path/VERSION") ($(\command \cat "$rvm_path/RELEASE" 2>/dev/null))";
    if [[ -s "$rvm_path/VERSION" && "${rvm_version:-}" != "${disk_version:-}" && " $* " != *" reload "* ]]; then
        if (( ${rvm_auto_reload_flag:-0} )); then
            __rvm_cli_rvm_reload;
        else
            printf "%b" "
RVM version ${disk_version} is installed yet ${rvm_version} is loaded.
Please do one of the following:
  * 'rvm reload'
  * open a new shell
  * 'echo rvm_auto_reload_flag=1 >> ~/.rvmrc' # for auto reload with msg.
  * 'echo rvm_auto_reload_flag=2 >> ~/.rvmrc' # for silent auto reload.

";
            return 1;
        fi;
    fi
}
__rvm_conditionally_add_bin_path () 
{ 
    [[ ":${PATH}:" == *":${rvm_bin_path}:"* ]] || { 
        if [[ "${rvm_ruby_string:-"system"}" == "system" && -z "$GEM_HOME" ]]; then
            PATH="$PATH:${rvm_bin_path}";
        else
            PATH="${rvm_bin_path}:$PATH";
        fi
    }
}
__rvm_conditionally_do_with_env () 
{ 
    if (( __rvm_env_loaded > 0 )); then
        "$@";
    else
        __rvm_do_with_env "$@";
    fi
}
__rvm_cp () 
{ 
    \cp "$@" || return $?
}
__rvm_curl () 
{ 
    ( \typeset curl_path;
    if [[ "${_system_name} ${_system_version}" == "Solaris 10" ]] && ! __rvm_which curl > /dev/null 2>&1; then
        curl_path=/opt/csw/bin/;
    else
        curl_path="";
    fi;
    __rvm_which ${curl_path}curl > /dev/null 2>&1 || { 
        rvm_error "RVM requires 'curl'. Install 'curl' first and try again.";
        return 200
    };
    \typeset -a __flags;
    __flags=(--fail --location);
    if [[ -n "${rvm_curl_flags[*]}" ]]; then
        __flags+=("${rvm_curl_flags[@]}");
    else
        __flags+=(--max-redirs 10 --max-time 1800);
    fi;
    [[ "$*" == *"--max-time"* ]] || [[ "$*" == *"--connect-timeout"* ]] || [[ "${__flags[*]}" == *"--connect-timeout"* ]] || __flags+=(--connect-timeout 30 --retry-delay 2 --retry 3);
    if [[ -n "${rvm_proxy:-}" ]]; then
        __flags+=(--proxy "${rvm_proxy:-}");
    fi;
    __rvm_curl_output_control;
    unset curl;
    __rvm_debug_command ${curl_path}curl "${__flags[@]}" "$@" || return $? )
}
__rvm_curl_output_control () 
{ 
    if (( ${rvm_quiet_curl_flag:-0} == 1 )); then
        __flags+=("--silent" "--show-error");
    else
        if [[ " $*" == *" -s"* || " $*" == *" --silent"* ]]; then
            [[ " $*" == *" -S"* || " $*" == *" -sS"* || " $*" == *" --show-error"* ]] || { 
                __flags+=("--show-error")
            };
        fi;
    fi
}
__rvm_current_gemset () 
{ 
    \typeset current_gemset;
    current_gemset="${GEM_HOME:-}";
    current_gemset="${current_gemset##*${rvm_gemset_separator:-@}}";
    if [[ "${current_gemset}" == "${GEM_HOME:-}" ]]; then
        echo '';
    else
        echo "${current_gemset}";
    fi
}
__rvm_custom_separated_array () 
{ 
    \typeset IFS;
    IFS=$2;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        eval "$1+=( \${=3} )";
    else
        eval "$1+=( \$3 )";
    fi
}
__rvm_date () 
{ 
    \date "$@" || return $?
}
__rvm_db () 
{ 
    \typeset value key variable;
    key="${1:-}";
    variable="${2:-}";
    value="";
    if [[ -f "$rvm_user_path/db" ]]; then
        value="$( __rvm_db_ "$rvm_user_path/db"   "$key" )";
    fi;
    if [[ -z "$value" && -f "$rvm_path/config/db" ]]; then
        value="$( __rvm_db_ "$rvm_path/config/db" "$key" )";
    fi;
    [[ -n "$value" ]] || return 1;
    if [[ -n "$variable" ]]; then
        eval "$variable='$value'";
    else
        echo "$value";
    fi;
    true
}
__rvm_db_ () 
{ 
    \typeset __db __key __value;
    __db="$1";
    __key="${2%%\?*}";
    shift 2;
    __value="$*";
    case "${__value}" in 
        unset | delete)
            __rvm_db_remove "${__db}" "${__key}"
        ;;
        "")
            __rvm_db_get "${__db}" "${__key}"
        ;;
        *)
            __rvm_db_add "${__db}" "${__key}" "${__value}"
        ;;
    esac
}
__rvm_db_add () 
{ 
    \typeset __dir="${1%/*}";
    if [[ -f "${1}" ]]; then
        __rvm_db_remove "${1}" "${2}";
    else
        if [[ ! -d "${__dir}" ]]; then
            mkdir -p "${__dir}";
        fi;
    fi;
    printf "%b=%b\n" "$2" "$3" >> "$1"
}
__rvm_db_get () 
{ 
    if [[ -f "$1" ]]; then
        __rvm_sed -n -e "\#^$2=# { s#^$2=##;; p; }" -e '/^$/d' < "$1";
    else
        echo -n "";
    fi
}
__rvm_db_remove () 
{ 
    if [[ -f "$1" ]]; then
        __rvm_sed -e "\#^$2=# d" -e '/^$/d' "$1" > "$1.new";
        \command \mv -f "$1.new" "$1";
    fi
}
__rvm_db_system () 
{ 
    \typeset __key __message;
    for __key in "${_system_name}_${_system_version}_$1" "${_system_name}_$1" "$1";
    do
        if __rvm_db "${__key}_error" __message; then
            rvm_error "${__message}";
        fi;
        if __rvm_db "${__key}_warn" __message; then
            rvm_warn "${__message}";
        fi;
        if __rvm_db "${__key}" "$2"; then
            return 0;
        fi;
    done;
    true
}
__rvm_debug_command () 
{ 
    rvm_debug "Running($#): $*";
    "$@" || return $?
}
__rvm_detect_debian_major_version_from_codename () 
{ 
    case $_system_version in 
        stretch*)
            _system_version="9"
        ;;
        jessie*)
            _system_version="8"
        ;;
        wheezy*)
            _system_version="7"
        ;;
        squeeze*)
            _system_version="6"
        ;;
        lenny*)
            _system_version="5"
        ;;
        etch*)
            _system_version="4"
        ;;
        sarge*)
            _system_version="3"
        ;;
        woody*)
            _system_version="3"
        ;;
        potato*)
            _system_version="2"
        ;;
        slink*)
            _system_version="2"
        ;;
        hamm*)
            _system_version="2"
        ;;
    esac
}
__rvm_detect_system () 
{ 
    unset _system_type _system_name _system_version _system_arch;
    export _system_type _system_name _system_version _system_arch;
    _system_info="$(command uname -a)";
    _system_type="unknown";
    _system_name="unknown";
    _system_name_lowercase="unknown";
    _system_version="unknown";
    _system_arch="$(command uname -m)";
    case "$(command uname)" in 
        Linux | GNU*)
            _system_type="Linux";
            if [[ -f /etc/lsb-release ]] && GREP_OPTIONS="" \command \grep "DISTRIB_ID=Ubuntu" /etc/lsb-release > /dev/null; then
                _system_name="Ubuntu";
                _system_version="$(awk -F'=' '$1=="DISTRIB_RELEASE"{print $2}' /etc/lsb-release | head -n 1)";
                _system_arch="$( dpkg --print-architecture )";
            else
                if [[ -f /etc/lsb-release ]] && GREP_OPTIONS="" \command \grep "DISTRIB_ID=neon" /etc/lsb-release > /dev/null; then
                    _system_name="Ubuntu";
                    _system_version="$(awk -F'=' '$1=="DISTRIB_RELEASE"{print $2}' /etc/lsb-release | head -n 1)";
                    _system_arch="$( dpkg --print-architecture )";
                else
                    if [[ -f /etc/lsb-release ]] && GREP_OPTIONS="" \command \grep "DISTRIB_ID=LinuxMint" /etc/lsb-release > /dev/null; then
                        _system_name="Mint";
                        _system_version="$(awk -F'=' '$1=="DISTRIB_RELEASE"{print $2}' /etc/lsb-release | head -n 1)";
                        _system_arch="$( dpkg --print-architecture )";
                    else
                        if [[ -f /etc/lsb-release ]] && GREP_OPTIONS="" \command \grep "DISTRIB_ID=ManjaroLinux" /etc/lsb-release > /dev/null; then
                            _system_name="Manjaro";
                            _system_version="$(awk -F'=' '$1=="DISTRIB_RELEASE"{print $2}' /etc/lsb-release | head -n 1)";
                        else
                            if [[ -f /etc/altlinux-release ]]; then
                                _system_name="Arch";
                                _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                            else
                                if [[ -f /etc/os-release ]] && GREP_OPTIONS="" \command \grep "ID=opensuse" /etc/os-release > /dev/null; then
                                    _system_name="OpenSuSE";
                                    _system_version="$(awk -F'=' '$1=="VERSION_ID"{gsub(/"/,"");print $2}' /etc/os-release | head -n 1)";
                                else
                                    if [[ -f /etc/SuSE-release ]]; then
                                        _system_name="SuSE";
                                        _system_version="$(
          \command \awk -F'=' '{gsub(/ /,"")} $1~/VERSION/ {version=$2} $1~/PATCHLEVEL/ {patch=$2} END {print version"."patch}' < /etc/SuSE-release
        )";
                                    else
                                        if [[ -f /etc/debian_version ]]; then
                                            _system_name="Debian";
                                            _system_version="$(\command \cat /etc/debian_version | \command \awk -F. '{print $1}' | head -n 1)";
                                            _system_arch="$( dpkg --print-architecture )";
                                            __rvm_detect_debian_major_version_from_codename;
                                        else
                                            if [[ -f /etc/os-release ]] && GREP_OPTIONS="" \command \grep "ID=pclinuxos" /etc/os-release > /dev/null; then
                                                _system_name="PCLinuxOS";
                                                _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/redhat-release  | \command \awk -F. '{print $1}' | head -n 1)";
                                                _system_arch="$( uname -m )";
                                            else
                                                if [[ -f /etc/devuan_version ]]; then
                                                    _system_name="Devuan";
                                                    _system_version="$(\command \cat /etc/devuan_version | \command \awk -F. '{print $1}' | head -n 1)";
                                                    _system_arch="$( dpkg --print-architecture )";
                                                else
                                                    if [[ -f /etc/os-release ]] && GREP_OPTIONS="" \command \grep "ID=debian" /etc/os-release > /dev/null; then
                                                        _system_name="Debian";
                                                        _system_version="$(awk -F'=' '$1=="VERSION_ID"{gsub(/"/,"");print $2}' /etc/os-release | \command \awk -F. '{print $1}' | head -n 1)";
                                                        _system_arch="$( dpkg --print-architecture )";
                                                        __rvm_detect_debian_major_version_from_codename;
                                                    else
                                                        if [[ -f /etc/system-release ]] && GREP_OPTIONS="" \command \grep "Amazon Linux AMI" /etc/system-release > /dev/null; then
                                                            _system_name="Amazon";
                                                            _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/system-release | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                        else
                                                            if [[ -f /etc/sabayon-release ]]; then
                                                                _system_name="Sabayon";
                                                                _system_version="$(\command \cat /etc/sabayon-release | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                            else
                                                                if [[ -f /etc/gentoo-release ]]; then
                                                                    _system_name="Gentoo";
                                                                    _system_version="base-$(\command \cat /etc/gentoo-release | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                                else
                                                                    if [[ -f /etc/arch-release ]]; then
                                                                        _system_name="Arch";
                                                                        _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                                    else
                                                                        if [[ -f /etc/fedora-release ]]; then
                                                                            _system_name="Fedora";
                                                                            _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9]+' /etc/fedora-release | head -n 1)";
                                                                        else
                                                                            if [[ -f /etc/oracle-release ]]; then
                                                                                _system_name="Oracle";
                                                                                _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/oracle-release  | \command \awk -F. '{print $1}' | head -n 1)";
                                                                            else
                                                                                if [[ -f /etc/redhat-release ]]; then
                                                                                    _system_name="$(
          GREP_OPTIONS="" \command \grep -Eo 'CentOS|PCLinuxOS|ClearOS|Mageia|Scientific|ROSA Desktop|OpenMandriva' /etc/redhat-release 2>/dev/null | \command \head -n 1 | \command \sed "s/ //"
        )";
                                                                                    _system_name="${_system_name:-CentOS}";
                                                                                    _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/redhat-release  | \command \awk -F. 'NR==1{print $1}' | head -n 1)";
                                                                                    _system_arch="$( uname -m )";
                                                                                else
                                                                                    if [[ -f /etc/centos-release ]]; then
                                                                                        _system_name="CentOS";
                                                                                        _system_version="$(GREP_OPTIONS="" \command \grep -Eo '[0-9\.]+' /etc/centos-release  | \command \awk -F. '{print $1}' | head -n 1)";
                                                                                    else
                                                                                        if [[ -f /etc/lsb-release ]] && GREP_OPTIONS="" \command \grep "DISTRIB_ID=Solus" /etc/lsb-release > /dev/null; then
                                                                                            _system_name="Solus";
                                                                                            _system_version="$(awk -F'=' '$1=="DISTRIB_RELEASE"{print $2}' /etc/lsb-release | head -n 1)";
                                                                                        else
                                                                                            if [[ -f /proc/devices ]] && GREP_OPTIONS="" \command \grep -Eo "synobios" /proc/devices > /dev/null; then
                                                                                                _system_type="BSD";
                                                                                                _system_name="Synology";
                                                                                                _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                                                            else
                                                                                                _system_version="libc-$(ldd --version  | \command \awk 'NR==1 {print $NF}' | \command \awk -F. '{print $1"."$2}' | head -n 1)";
                                                                                            fi;
                                                                                        fi;
                                                                                    fi;
                                                                                fi;
                                                                            fi;
                                                                        fi;
                                                                    fi;
                                                                fi;
                                                            fi;
                                                        fi;
                                                    fi;
                                                fi;
                                            fi;
                                        fi;
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi
        ;;
        SunOS)
            _system_type="SunOS";
            _system_name="Solaris";
            _system_version="$(command uname -v)";
            _system_arch="$(command isainfo -k)";
            if [[ "${_system_version}" == joyent* ]]; then
                _system_name="SmartOS";
                _system_version="${_system_version#* }";
            else
                if [[ "${_system_version}" == omnios* ]]; then
                    _system_name="OmniOS";
                    _system_version="${_system_version#* }";
                else
                    if [[ "${_system_version}" == oi* || "${_system_version}" == illumos* ]]; then
                        _system_name="OpenIndiana";
                        _system_version="${_system_version#* }";
                    else
                        if [[ "${_system_version}" == Generic* ]]; then
                            _system_version="10";
                        else
                            if [[ "${_system_version}" == *11* ]]; then
                                _system_version="11";
                            fi;
                        fi;
                    fi;
                fi;
            fi
        ;;
        FreeBSD)
            _system_type="BSD";
            _system_name="FreeBSD";
            _system_version="$(command uname -r)";
            _system_version="${_system_version%%-*}"
        ;;
        OpenBSD)
            _system_type="BSD";
            _system_name="OpenBSD";
            _system_version="$(command uname -r)"
        ;;
        DragonFly)
            _system_type="BSD";
            _system_name="DragonFly";
            _system_version="$(command uname -r)";
            _system_version="${_system_version%%-*}"
        ;;
        NetBSD)
            _system_type="BSD";
            _system_name="NetBSD";
            _system_version_full="$(command uname -r)";
            _system_version="$(echo ${_system_version_full} | \command \awk -F. '{print $1"."$2}')"
        ;;
        Darwin)
            _system_type="Darwin";
            _system_name="OSX";
            _system_version="$(sw_vers -productVersion | \command \awk -F. '{print $1"."$2}')"
        ;;
        CYGWIN*)
            _system_type="Windows";
            _system_name="Cygwin"
        ;;
        MINGW*)
            _system_type="Windows";
            _system_name="Mingw"
        ;;
        *)
            return 1
        ;;
    esac;
    _system_type="${_system_type//[ \/]/_}";
    _system_name="${_system_name//[ \/]/_}";
    _system_name_lowercase="$(echo ${_system_name} | \command \tr '[A-Z]' '[a-z]')";
    _system_version="${_system_version//[ \/]/_}";
    _system_arch="${_system_arch//[ \/]/_}";
    _system_arch="${_system_arch/amd64/x86_64}";
    _system_arch="${_system_arch/i[123456789]86/i386}"
}
__rvm_detect_system_override () 
{ 
    \typeset _var;
    for _var in system_type system_name system_name_lowercase system_version system_arch;
    do
        __rvm_db ${_var} _${_var};
    done
}
__rvm_detect_xcode_version () 
{ 
    \typeset version_file;
    for version_file in /Applications/Xcode.app/Contents/version.plist /Developer/Applications/Xcode.app/Contents/version.plist;
    do
        if [[ -f $version_file ]]; then
            if [[ -x /usr/libexec/PlistBuddy ]]; then
                /usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" $version_file;
            else
                __rvm_sed -n '/<key>CFBundleShortVersionString<\/key>/{n; s/^.*>\(.*\)<.*$/\1/; p;}' < $version_file;
            fi;
            return 0;
        fi;
    done;
    if builtin command -v xcodebuild > /dev/null; then
        xcodebuild -version | __rvm_sed -n '/Xcode/ {s/Xcode //; p;}';
        return 0;
    fi;
    return 1
}
__rvm_detect_xcode_version_at_least () 
{ 
    \typeset __xcode_version="$(__rvm_detect_xcode_version)";
    [[ -n "$__xcode_version" ]] || return 0;
    __rvm_version_compare "$__xcode_version" -ge "$1" || return $?;
    true
}
__rvm_display_rvmrc () 
{ 
    __rvm_file_notice_display_pre;
    __rvm_wait_anykey "(( press a key to review the ${_rvmrc_base} file ))";
    printf "%b" "${rvm_warn_clr}";
    command cat -v "${_rvmrc}";
    printf "%b" "${rvm_reset_clr}";
    __rvm_file_notice_display_post
}
__rvm_do_with_env () 
{ 
    \typeset result;
    __rvm_do_with_env_before;
    "$@";
    result=$?;
    __rvm_do_with_env_after;
    return ${result:-0}
}
__rvm_do_with_env_after () 
{ 
    __rvm_teardown
}
__rvm_do_with_env_before () 
{ 
    if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]; then
        source "${rvm_scripts_path:-"$rvm_path/scripts"}/initialize";
        __rvm_setup;
    fi
}
__rvm_dotted () 
{ 
    set +x;
    \typeset flush;
    if (( $# )); then
        printf "%b" "${rvm_notify_clr:-}$*${rvm_reset_clr:-}";
    fi;
    if __rvm_awk '{fflush;}' <<< EO 2> /dev/null; then
        flush=fflush;
    else
        flush=flush;
    fi;
    awk -v go_back="$( tput cub1 2>/dev/null || true)" '
  BEGIN{
    spin[0]="|"go_back;
    spin[1]="/"go_back;
    spin[2]="-"go_back;
    spin[3]="\\"go_back }
  {
    if ((NR-1)%(10)==9)
      printf ".";
    else
      if (go_back!="") printf spin[(NR-1)%4];
    '${flush}' }
  END{
    print "." }
  '
}
__rvm_ensure_has_environment_files () 
{ 
    \typeset file_name variable value environment_id __path __gem_home;
    __gem_home="${rvm_ruby_gem_home}";
    file_name="${__gem_home}/environment";
    __path="";
    if [[ "${__gem_home##*@}" != "global" ]]; then
        __path+="${__gem_home}/bin:";
    fi;
    __path+="${rvm_ruby_global_gems_path}/bin:${rvm_ruby_home}/bin";
    \command \rm -f "$file_name";
    \command \mkdir -p "${__gem_home}/wrappers" "${rvm_environments_path}" "${rvm_wrappers_path}";
    printf "%b" "export PATH=\"${__path}:\$PATH\"\n" > "$file_name";
    for variable in GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC MAGLEV_HOME RBXOPT RUBY_VERSION;
    do
        eval "value=\${${variable}:-""}";
        if [[ -n "$value" ]]; then
            printf "export %b='%b'\n" "${variable}" "${value}" >> "$file_name";
        else
            printf "unset %b\n" "${variable}" >> "$file_name";
        fi;
    done;
    environment_id="${__gem_home##*/}";
    [[ -L "${rvm_environments_path}/${environment_id}" ]] || { 
        if [[ -f "${rvm_environments_path}/${environment_id}" ]]; then
            rm -rf "${rvm_environments_path}/${environment_id}";
        fi;
        ln -nfs "${__gem_home}/environment" "${rvm_environments_path}/${environment_id}"
    };
    ln -nfs "${__gem_home}/wrappers" "$rvm_wrappers_path/${environment_id}";
    return 0
}
__rvm_ensure_is_a_function () 
{ 
    if [[ ${rvm_reload_flag:=0} == 1 ]] || ! is_a_function rvm; then
        for script in version functions/selector cd functions/cli cli override_gem;
        do
            if [[ -f "$rvm_scripts_path/$script" ]]; then
                source "$rvm_scripts_path/$script";
            else
                printf "%b" "WARNING:
        Could not source '$rvm_scripts_path/$script' as file does not exist.
        RVM will likely not work as expected.\n";
            fi;
        done;
    fi
}
__rvm_env_file_notice_display_post () 
{ 
    __rvm_table "Viewing of ${_rvmrc} complete."  <<-TEXT
Trusting an ${_rvmrc_base} file means that whenever you cd into this directory, RVM will export environment variables from ${_rvmrc_base}.
Note that if the contents of the file change, you will be re-prompted to review the file and adjust its trust settings. You may also change the trust settings manually at any time with the 'rvm rvmrc' command.
TEXT

}
__rvm_env_file_notice_initial () 
{ 
    __rvm_table "NOTICE"  <<-TEXT
RVM has encountered a new or modified ${_rvmrc_base} file in the current directory, environment variables from this file will be exported and therefore may influence your shell.

Examine the contents of this file carefully to be sure the contents are safe before trusting it!
Do you wish to trust '${_rvmrc}'?
Choose v[iew] below to view the contents
TEXT

}
__rvm_env_print () 
{ 
    environment_file_path="$rvm_environments_path/$(__rvm_env_string)";
    if [[ "$rvm_path_flag" == "1" || "$*" == *"--path"* ]]; then
        echo "$environment_file_path";
    else
        if [[ "$rvm_cron_flag" == "1" || "$*" == *"--cron"* ]]; then
            \command \cat "$environment_file_path" | __rvm_grep -Eo "[^ ]+=[^;]+" | __rvm_sed -e 's/\$PATH/'"${PATH//\//\\/}"'/' -e 's/\${PATH}/'"${PATH//\//\\/}"'/';
        else
            \command \cat "$environment_file_path";
        fi;
    fi
}
__rvm_env_string () 
{ 
    \typeset _string;
    _string="${GEM_HOME:-}";
    _string="${_string##*/}";
    printf "%b" "${_string:-system}\n"
}
__rvm_expand_ruby_string () 
{ 
    \typeset string current_ruby;
    string="$1";
    case "${string:-all}" in 
        all)
            __rvm_list_strings | \command \tr ' ' "\n"
        ;;
        all-gemsets)
            __rvm_list_gemset_strings
        ;;
        default-with-rvmrc | rvmrc)
            "$rvm_scripts_path/tools" path-identifier "$PWD"
        ;;
        all-rubies | rubies)
            __rvm_list_strings
        ;;
        current-ruby | gemsets)
            current_ruby="$(__rvm_env_string)";
            current_ruby="${current_ruby%@*}";
            rvm_silence_logging=1 "$rvm_scripts_path/gemsets" list strings | __rvm_sed "s/ (default)//; s/^/$current_ruby${rvm_gemset_separator:-@}/ ; s/@default// ;"
        ;;
        current)
            __rvm_env_string
        ;;
        aliases)
            __rvm_awk -F= '{print $string}' < "$rvm_path/config/alias"
        ;;
        *)
            __rvm_ruby_strings_exist $( echo "$string" | \command \tr "," "\n" | __rvm_strip )
        ;;
    esac
}
__rvm_export () 
{ 
    \typeset name;
    name=${1%%\=*};
    builtin export rvm_old_$name=${!name};
    export "$@";
    return $?
}
__rvm_file_env_check_unload () 
{ 
    if (( ${#rvm_saved_env[@]} > 0 )); then
        __rvm_set_env "" "${rvm_saved_env[@]}";
    fi;
    rvm_saved_env=()
}
__rvm_file_load_env () 
{ 
    \typeset -a __sed_commands;
    __sed_commands=();
    if [[ -n "${2:-}" ]]; then
        __sed_commands+=(-e "/^$2/ !d" -e "s/^$2//");
    else
        __sed_commands+=(-e "/^#/ d" -e "/^$/ d");
    fi;
    __rvm_read_lines __file_env_variables <( { cat "$1"; echo ""; } | __rvm_sed "${__sed_commands[@]}" )
}
__rvm_file_load_env_and_trust () 
{ 
    [[ -f "$1" ]] || return 0;
    __rvm_file_load_env "$1" "${2:-}";
    if (( ${#__file_env_variables[@]} == 0 )) || __rvm_check_rvmrc_trustworthiness "$1"; then
        true;
    else
        rvm_debug "Envirionment variables variables from '$1' wont be loaded because of lack of trust (status=$?).";
        __file_env_variables=();
    fi
}
__rvm_file_notice_display_post () 
{ 
    case "${_rvmrc}" in 
        */.rvmrc)
            __rvm_rvmrc_notice_display_post
        ;;
        *)
            __rvm_env_file_notice_display_post
        ;;
    esac
}
__rvm_file_notice_display_pre () 
{ 
    __rvm_table  <<-TEXT
The contents of the ${_rvmrc_base} file will now be displayed.
After reading the file, you will be prompted again for 'yes or no' to set the trust level for this particular version of the file.

Note: You will be re-prompted each time the ${_rvmrc_base} file's contents change
changes, and may change the trust setting manually at any time.
TEXT

}
__rvm_file_notice_initial () 
{ 
    case "${_rvmrc}" in 
        */.rvmrc)
            __rvm_rvmrc_notice_initial
        ;;
        *)
            __rvm_env_file_notice_initial
        ;;
    esac
}
__rvm_file_set_env () 
{ 
    __rvm_file_env_check_unload;
    __rvm_set_env "rvm_saved_env" "${__file_env_variables[@]}"
}
__rvm_find () 
{ 
    \find "$@" || return $?
}
__rvm_find_first_file () 
{ 
    \typeset _first_file _variable_first_file __file_enum;
    _first_file="";
    _variable_first_file="$1";
    shift;
    for __file_enum in "$@";
    do
        if [[ -f "$__file_enum" ]]; then
            eval "$_variable_first_file=\"\$__file_enum\"";
            return 0;
        fi;
    done;
    eval "$_variable_first_file=\"\"";
    return 1
}
__rvm_fix_group_permissions () 
{ 
    if \umask -S | __rvm_grep 'g=rw' > /dev/null; then
        chmod -R g+rwX "$@";
    fi
}
__rvm_fix_path_from_gem_path () 
{ 
    [[ -n "${GEM_PATH:-}" ]] || return 0;
    export PATH;
    \typeset IFS _iterator_path;
    \typeset -a _gem_path _new_path;
    IFS=:;
    _gem_path=();
    _new_path=();
    __rvm_custom_separated_array _gem_path : "${GEM_PATH}";
    for _iterator_path in "${_gem_path[@]}";
    do
        _new_path+=("${_iterator_path}/bin");
    done;
    _new_path+=("${MY_RUBY_HOME:-${GEM_HOME/gems/rubies}}/bin");
    _new_path+=("${rvm_bin_path}");
    PATH="${_new_path[*]}:$PATH";
    builtin hash -r
}
__rvm_fix_selected_ruby () 
{ 
    \typeset __ret=0;
    if (( $# )); then
        "$@" || __ret=$?;
    fi;
    [[ -d "$GEM_HOME" && -d "$MY_RUBY_HOME" ]] || { 
        if [[ -d ${MY_RUBY_HOME%/*}/defaul ]]; then
            __rvm_use default;
        else
            __rvm_use system;
        fi
    }
}
__rvm_fold () 
{ 
    if fold -s -w 10 <<< bla > /dev/null; then
        fold -s -w $1;
    else
        fold -w $1;
    fi
}
__rvm_gemset_clear () 
{ 
    export rvm_gemset_name;
    rvm_gemset_name="";
    __rvm_use
}
__rvm_gemset_handle_default () 
{ 
    rvm_gemset_name="${rvm_gemset_separator:-@}${rvm_gemset_name:-}${rvm_gemset_separator:-@}";
    rvm_gemset_name="${rvm_gemset_name/${rvm_gemset_separator:-@}default${rvm_gemset_separator:-@}/}";
    rvm_gemset_name="${rvm_gemset_name//${rvm_gemset_separator:-@}/}"
}
__rvm_gemset_pristine () 
{ 
    __rvm_log_command "gemset.pristine-$1" "Making gemset $1 pristine" __rvm_with "$1" gemset_pristine
}
__rvm_gemset_select () 
{ 
    __rvm_gemset_select_only && __rvm_gemset_select_validation || return $?
}
__rvm_gemset_select_cli () 
{ 
    __rvm_gemset_select_cli_validation && __rvm_gemset_select || return $?
}
__rvm_gemset_select_cli_validation () 
{ 
    \typeset orig_gemset;
    if ! builtin command -v gem > /dev/null; then
        rvm_log "'gem' command not found, cannot select a gemset.";
        return 0;
    fi;
    orig_gemset="${rvm_gemset_name:-}";
    __rvm_gemset_handle_default;
    if [[ -z "${rvm_gemset_name:-}" && "$orig_gemset" != "default" && ${rvm_sticky_flag:-0} -eq 1 ]]; then
        if [[ -n "${rvm_ruby_gem_home:-}" ]]; then
            rvm_gemset_name="$rvm_ruby_gem_home";
        else
            if [[ -n "${GEM_HOME:-}" ]]; then
                rvm_gemset_name="$GEM_HOME";
            fi;
        fi;
        rvm_gemset_name="${rvm_gemset_name##*/}";
        rvm_gemset_name="${rvm_gemset_name#*${rvm_gemset_separator:-"@"}}";
    fi;
    if [[ -z "${rvm_ruby_string:-}" && -n "${GEM_HOME:-}" && -n "${GEM_HOME%@*}" ]]; then
        rvm_ruby_string="${GEM_HOME%@*}";
        rvm_ruby_string="${rvm_ruby_string##*/}";
    fi;
    if [[ -z "${rvm_ruby_string:-}" ]]; then
        rvm_error "Gemsets can not be used with non rvm controlled rubies (currently).";
        return 3;
    fi
}
__rvm_gemset_select_only () 
{ 
    rvm_ruby_gem_home="${rvm_gems_path:-"$rvm_path/gems"}/$rvm_ruby_string";
    : rvm_ignore_gemsets_flag:${rvm_ignore_gemsets_flag:=0}:;
    if (( rvm_ignore_gemsets_flag )); then
        rvm_ruby_global_gems_path="${rvm_ruby_gem_home}";
        rvm_ruby_gem_path="${rvm_ruby_gem_home}";
        rvm_gemset_name="";
    else
        rvm_ruby_global_gems_path="${rvm_ruby_gem_home}${rvm_gemset_separator:-"@"}global";
        __rvm_gemset_handle_default;
        [[ -z "$rvm_gemset_name" ]] || rvm_ruby_gem_home="${rvm_ruby_gem_home}${rvm_gemset_separator:-"@"}${rvm_gemset_name}";
        if [[ "$rvm_gemset_name" == "global" ]]; then
            rvm_ruby_gem_path="${rvm_ruby_gem_home}";
        else
            rvm_ruby_gem_path="${rvm_ruby_gem_home}:${rvm_ruby_global_gems_path}";
        fi;
    fi;
    if [[ -n "${rvm_gemset_name}" ]]; then
        rvm_env_string="${rvm_ruby_string}@${rvm_gemset_name}";
    else
        rvm_env_string=${rvm_ruby_string};
    fi;
    true
}
__rvm_gemset_select_validation () 
{ 
    if [[ ! -d "${rvm_ruby_gem_home}" ]]; then
        if (( ${rvm_gemset_create_on_use_flag:=0} == 0 && ${rvm_create_flag:=0} == 0 && ${rvm_delete_flag:=0} == 0 )); then
            rvm_expected_gemset_name="${rvm_gemset_name}";
            rvm_gemset_name="";
            __rvm_gemset_select_only;
            return 2;
        fi;
    else
        if (( ${rvm_delete_flag:=0} == 1 )); then
            return 4;
        fi;
    fi;
    case "${rvm_gemset_name}" in 
        */*)
            rvm_error "Gemsets can not contain path separator '/'.";
            return 5
        ;;
        *:*)
            rvm_error "Gemsets can not contain PATH separator ':'.";
            return 5
        ;;
    esac;
    \typeset rvm_ruby_gem_home_254;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        rvm_ruby_gem_home_254="${rvm_ruby_gem_home[0,254]}";
    else
        rvm_ruby_gem_home_254="${rvm_ruby_gem_home:0:254}";
    fi;
    if [[ "${rvm_ruby_gem_home}" != "${rvm_ruby_gem_home_254}" ]]; then
        rvm_error "Gemset gem home to long ${#rvm_ruby_gem_home}.";
        return 6;
    fi
}
__rvm_gemset_use () 
{ 
    if [[ "$(__rvm_env_string)" == "system" ]]; then
        rvm_error "System ruby is not controlled by RVM, but you can use it with 'rvm automount', read more: 'rvm help mount'.";
        return 2;
    else
        if __rvm_gemset_select_cli; then
            rvm_log "Using $rvm_ruby_string with gemset ${rvm_gemset_name:-default}";
            __rvm_use;
        else
            if [[ -n "${rvm_expected_gemset_name}" ]]; then
                __rvm_gemset_use_ensure;
            else
                rvm_error "Gemset was not given.\n  Usage:\n    rvm gemset use <gemsetname>\n";
                return 1;
            fi;
        fi;
    fi
}
__rvm_gemset_use_ensure () 
{ 
    if [[ ! -d "$rvm_ruby_gem_home" ]] || [[ -n "${rvm_expected_gemset_name}" && ! -d "${rvm_ruby_gem_home%@*}@${rvm_expected_gemset_name}" ]]; then
        if (( ${rvm_gemset_create_on_use_flag:=0} == 1 || ${rvm_create_flag:=0} == 1 )); then
            gemset_create "${rvm_expected_gemset_name:-${rvm_gemset_name:-}}";
        else
            rvm_error "Gemset '${rvm_expected_gemset_name:-${rvm_gemset_name:-}}' does not exist, 'rvm $rvm_ruby_string do rvm gemset create ${rvm_expected_gemset_name:-${rvm_gemset_name:-}}' first, or append '--create'.";
            return 2;
        fi;
    fi
}
__rvm_get_user_shell () 
{ 
    case "${_system_type}:${_system_name}" in 
        Linux:* | SunOS:* | BSD:* | *:Cygwin)
            __shell="$( getent passwd $USER )" || { 
                rvm_error "Error checking user shell via getent ... something went wrong, report a bug.";
                return 2
            };
            echo "${__shell##*:}"
        ;;
        Darwin:*)
            \typeset __version;
            __version="$(dscl localhost -read "/Search/Users/$USER" UserShell)" || { 
                rvm_error "Error checking user shell via dscl ... something went wrong, report a bug.";
                return 3
            };
            echo ${__version#*: }
        ;;
        *)
            rvm_error "Do not know how to check user shell on '$(command uname)'.";
            return 1
        ;;
    esac
}
__rvm_grep () 
{ 
    GREP_OPTIONS="" \command \grep "$@" || return $?
}
__rvm_has_opt () 
{ 
    if [[ -n "${ZSH_VERSION}" ]]; then
        setopt | GREP_OPTIONS="" \command \grep "^${1}$" > /dev/null 2>&1 || return $?;
    else
        if [[ -n "${KSH_VERSION}" ]]; then
            set +o | GREP_OPTIONS="" \command \grep "-o ${1}$" > /dev/null 2>&1 || return $?;
        else
            if [[ -n "${BASH_VERSION}" ]]; then
                [[ ":$SHELLOPTS:" == *":${1}:"* ]] || return $?;
            else
                return 1;
            fi;
        fi;
    fi
}
__rvm_include_travis_binaries () 
{ 
    if [[ $rvm_remote_server_url == *"travis"* && $TRAVIS != true && $_system_name_lowercase == "osx" ]]; then
        rvm_debug "Travis binaries for OSX are not movable and can't be used outside of Travis environment. Skip that source.";
        return 1;
    fi;
    return 0
}
__rvm_initial_gemsets_create () 
{ 
    __rvm_log_command "chmod.bin" "$rvm_ruby_string - #making binaries executable" __rvm_set_executable "$rvm_ruby_home/bin"/* && ( rvm_ruby_binary="${1:-$rvm_ruby_home/bin/ruby}" rubygems_setup ${rvm_rubygems_version:-latest} ) && __rvm_initial_gemsets_create_without_rubygems "$1"
}
__rvm_initial_gemsets_create_without_rubygems () 
{ 
    __rvm_rubygems_create_link "$1" && gemset_create "global" && __rvm_with "${rvm_ruby_string}@global" __rvm_remove_without_gems && gemset_create ""
}
__rvm_initialize () 
{ 
    true ${rvm_scripts_path:="$rvm_path/scripts"};
    export rvm_scripts_path;
    source "$rvm_scripts_path/base";
    __rvm_conditionally_add_bin_path;
    export PATH;
    [[ -d "${rvm_tmp_path:-/tmp}" ]] || command mkdir -p "${rvm_tmp_path}";
    return 0
}
__rvm_join_array () 
{ 
    \typeset IFS;
    IFS="$2";
    eval "$1=\"\${$3[*]}\""
}
__rvm_libtoolize () 
{ 
    \libtoolize "$@" || return $?
}
__rvm_lines_with_gems () 
{ 
    \typeset -a __gems_to_add;
    __gems_to_add=();
    case "${1}" in 
        global)
            __rvm_custom_separated_array __gems_to_add " " "${rvm_with_gems:-}"
        ;;
        default)
            __rvm_custom_separated_array __gems_to_add " " "${rvm_with_default_gems:-}"
        ;;
        *)
            return 0
        ;;
    esac;
    (( ${#__gems_to_add[@]} )) || return 0;
    \typeset __gem __version;
    for __gem in "${__gems_to_add[@]}";
    do
        __version="${__gem#*=}";
        __gem="${__gem%%=*}";
        if [[ "${__gem}" == "${__version}" ]]; then
            lines+=("${__gem}");
        else
            lines+=("${__gem} -v ${__version}");
        fi;
    done
}
__rvm_lines_without_comments () 
{ 
    __rvm_remove_from_array lines "#*|+( )" "${lines[@]}"
}
__rvm_lines_without_gems () 
{ 
    [[ -n "${rvm_without_gems}" ]] || return 0;
    \typeset -a __gems_to_remove;
    __gems_to_remove=();
    __rvm_custom_separated_array __gems_to_remove " " "${rvm_without_gems}";
    (( ${#__gems_to_remove[@]} )) || return 0;
    \typeset __gem;
    for __gem in "${__gems_to_remove[@]}";
    do
        __rvm_remove_from_array lines "${__gem}|${__gem% *} *" "${lines[@]}";
    done
}
__rvm_list_gems () 
{ 
    \typeset __checks __names;
    __checks="${1:-}";
    shift || true;
    __names="$*";
    if [[ -n "${__names}" ]]; then
        __checks="%w{${__names}}.include?(gem.name)${__checks:+" && ( ${__checks} )"}";
    fi;
    if [[ -n "${__checks}" ]]; then
        __checks="if ${__checks}";
    fi;
    rvm_debug "gem list check: ${__checks}";
    ruby -rrubygems -e "
    Gem::Specification.each{|gem|
      puts \"#{gem.name} #{gem.version}\" ${__checks}
    }
  " 2> /dev/null || gem list $@ | __rvm_sed '/\*\*\*/ d ; /^$/ d; s/ (/,/; s/, /,/g; s/)//;' | __rvm_awk -F ',' '{for(i=2;i<=NF;i++) print $1" "$i }'
}
__rvm_list_gemset_strings () 
{ 
    \typeset all_rubies ruby_name gemset;
    all_rubies="$(__rvm_list_strings | tr "\n" ":")";
    for gemset in "${rvm_gems_path:-"$rvm_path/gems"}"/*;
    do
        case "$gemset" in 
            */\* | @* | doc | cache | system)
                continue
            ;;
        esac;
        ruby_name="${gemset%%@*}";
        ruby_name="${ruby_name##*/}";
        case ":$all_rubies" in 
            *:${ruby_name}:*)
                true
            ;;
            *)
                continue
            ;;
        esac;
        echo "${gemset##*/}";
    done | sort;
    return 0
}
__rvm_list_known_strings () 
{ 
    __rvm_sed -e 's/#.*$//g' -e 's#\[##g' -e 's#\]##g' < "$rvm_path/config/known" | sort -r | uniq;
    return $?
}
__rvm_list_strings () 
{ 
    __rvm_find "$rvm_rubies_path" -mindepth 1 -maxdepth 1 -type d | __rvm_awk -F'/' '{print $NF}'
}
__rvm_load_environment () 
{ 
    \typeset __hook;
    if [[ -f "$rvm_environments_path/$1" ]]; then
        unset GEM_HOME GEM_PATH;
        __rvm_remove_rvm_from_path;
        __rvm_conditionally_add_bin_path;
        \. "$rvm_environments_path/$1";
        rvm_hook="after_use";
        if [[ -n "${rvm_scripts_path:-}" || -n "${rvm_path:-}" ]]; then
            source "${rvm_scripts_path:-$rvm_path/scripts}/hook";
        fi;
        builtin hash -r;
    else
        __rvm_use "$1";
    fi
}
__rvm_load_project_config () 
{ 
    rvm_debug "__rvm_load_project_config $1";
    \typeset __gemfile _bundle_install;
    \typeset -a __file_env_variables;
    __file_env_variables=();
    __gemfile="";
    rvm_previous_environment="$(__rvm_env_string)";
    : rvm_autoinstall_bundler_flag:${rvm_autoinstall_bundler_flag:=0};
    case "$1" in 
        */.rvmrc)
            __rvmrc_warning_display_for_rvmrc "$1";
            if __rvm_check_rvmrc_trustworthiness "$1"; then
                __rvm_remove_rvm_from_path;
                __rvm_conditionally_add_bin_path;
                rvm_current_rvmrc="$1";
                __rvm_ensure_is_a_function;
                unset GEM_HOME GEM_PATH;
                rvm_ruby_string="${rvm_previous_environment/system/default}" rvm_action=use source "$1" || return $?;
            else
                return $?;
            fi
        ;;
        */.versions.conf)
            __rvm_ensure_is_a_function;
            rvm_current_rvmrc="$1";
            rvm_ruby_string="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby=/ {s/ruby=//;p;}' | tail -n 1 )";
            [[ -n "${rvm_ruby_string}" ]] || return 2;
            rvm_gemset_name="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby-gemset=/ {s/ruby-gemset=//;p;}' | tail -n 1 )";
            rvm_create_flag=1 __rvm_use || return 3;
            __rvm_file_load_env_and_trust "$1" "env-";
            _bundle_install="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^ruby-bundle-install=/ {s/ruby-bundle-install=//;p;}' )";
            if [[ -n "${_bundle_install}" ]]; then
                if [[ -f "${_bundle_install}" ]]; then
                    __gemfile="${_bundle_install}";
                else
                    __gemfile="${1%/*}/Gemfile";
                fi;
            fi
        ;;
        */Gemfile)
            __rvm_ensure_is_a_function;
            rvm_current_rvmrc="$1";
            rvm_ruby_string="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^#ruby=/ {s/#ruby=//;p;}' | tail -n 1 )";
            [[ -n "${rvm_ruby_string}" ]] || { 
                rvm_ruby_string="$(
          \command \tr -d '\r' <"$1" |
          __rvm_sed -n "s/[[:space:]]+rescue[[:space:]]+nil$//; /^\s*ruby[[:space:](]/ {s/^\s*ruby//; s/[[:space:]()'\"]//g; p;}" |
          \tail -n 1
        )";
                [[ -n "${rvm_ruby_string}" ]] || return 2
            };
            rvm_ruby_string="${rvm_ruby_string/,:patchlevel=>/-p}";
            rvm_ruby_string="${rvm_ruby_string/,patchlevel:/-p}";
            rvm_gemset_name="$( \command \tr -d '\r' <"$1" | __rvm_sed -n '/^#ruby-gemset=/ {s/#ruby-gemset=//;p;}' | tail -n 1 )";
            if [[ -z "${rvm_gemset_name:-}" && -f "${1%/*}/.ruby-gemset" ]]; then
                rvm_gemset_name="$( \command \tr -d '\r' <"${1%/*}/.ruby-gemset" )";
            fi;
            __rvmrc_warning_display_for_Gemfile "$1";
            rvm_create_flag=1 __rvm_use || return 3;
            __rvm_file_load_env_and_trust "$1" "#ruby-env-";
            __gemfile="$1"
        ;;
        */.ruby-version | */.rbfu-version | */.rbenv-version)
            __rvm_ensure_is_a_function;
            rvm_current_rvmrc="$1";
            rvm_ruby_string="$( \command \tr -d '\r' <"$1" )";
            if [[ -z "${rvm_ruby_string}" ]]; then
                return 2;
            fi;
            if [[ -f "${1%/*}/.ruby-gemset" ]]; then
                rvm_gemset_name="$( \command \tr -d '\r' <"${1%/*}/.ruby-gemset" )";
            else
                rvm_gemset_name="";
            fi;
            rvm_create_flag=1 __rvm_use || return 3;
            __rvm_file_load_env_and_trust "${1%/*}/.ruby-env";
            __rvm_file_load_env_and_trust "${1%/*}/.rbenv-vars";
            __gemfile="${1%/*}/Gemfile"
        ;;
        *)
            rvm_error "Unsupported file format for '$1'";
            return 1
        ;;
    esac;
    __rvm_file_set_env;
    if [[ "${rvm_autoinstall_bundler_flag:-0}" == 1 && -n "${__gemfile:-}" && -f "${__gemfile:-}" ]]; then
        __rvm_which bundle > /dev/null 2>&1 || gem install --remote bundler;
        bundle install --gemfile="${__gemfile}" | __rvm_grep -vE '^Using|Your bundle is complete';
    fi
}
__rvm_load_rvmrc () 
{ 
    \typeset _file;
    \typeset -a rvm_rvmrc_files;
    if (( ${rvm_ignore_rvmrc:=0} == 1 )); then
        return 0;
    fi;
    [[ -n "${rvm_stored_umask:-}" ]] || export rvm_stored_umask=$(umask);
    rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc");
    if [[ -n "${rvm_prefix:-}" ]] && ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]; then
        rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc");
    fi;
    for _file in "${rvm_rvmrc_files[@]}";
    do
        if [[ -s "$_file" ]]; then
            if __rvm_grep '^\s*rvm .*$' "$_file" > /dev/null 2>&1; then
                rvm_error "
$_file is for rvm settings only.
rvm CLI may NOT be called from within $_file.
Skipping the loading of $_file
";
                return 1;
            else
                source "$_file";
            fi;
        fi;
    done;
    return 0
}
__rvm_log_command () 
{ 
    \typeset name message _command_start _command_name;
    \typeset -a _command;
    name="${1:-}";
    message="${2:-}";
    shift 2;
    _command=("$@");
    _command_start="$1";
    while (( $# )) && [[ "$1" == *"="* ]]; do
        shift;
    done;
    _command_name="$1";
    [[ "${_command_start}" != *"="* ]] || _command=("env" "${_command[@]}");
    if __function_on_stack __rvm_log_command_internal; then
        __rvm_log_command_simple "$@" || return $?;
    else
        __rvm_log_command_internal "$@" || return $?;
    fi
}
__rvm_log_command_caclulate_log_file_name () 
{ 
    [[ -n "${rvm_log_timestamp:-}" ]] || __rvm_log_command_caclulate_log_timestamp;
    [[ -n "${rvm_log_filesystem:-}" ]] || __rvm_log_command_caclulate_log_filesystem;
    [[ -n "${rvm_log_namelen:-}" ]] || __rvm_log_command_caclulate_log_namelen;
    name="${name//[ \/]/_}";
    _log="${rvm_log_path}/${rvm_log_timestamp}${rvm_ruby_string:+_}${rvm_ruby_string:-}/${name}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _log="${_log[0,${rvm_log_namelen}]}.log";
    else
        _log="${_log:0:${rvm_log_namelen}}.log";
    fi
}
__rvm_log_command_caclulate_log_filesystem () 
{ 
    export rvm_log_filesystem="$(
    __rvm_mount 2>/dev/null | __rvm_awk -v rvm_path=$rvm_path '
      BEGIN{longest=""; fstype=""}
      {if (index(rvm_path,$3)==1 && length($3)>length(longest)){longest=$3; fstype=$5}}
      END{print fstype}
    '
  )";
    rvm_debug "Log filesystem: ${rvm_log_filesystem}"
}
__rvm_log_command_caclulate_log_namelen () 
{ 
    case "${rvm_log_filesystem}" in 
        ecryptfs)
            export rvm_log_namelen=138
        ;;
        *)
            export rvm_log_namelen=250
        ;;
    esac;
    rvm_debug "Log max name length: ${rvm_log_namelen}"
}
__rvm_log_command_caclulate_log_timestamp () 
{ 
    export rvm_log_timestamp="$(__rvm_date "+%s")";
    rvm_debug "Log prefix: ${rvm_log_path}/${rvm_log_timestamp}${rvm_ruby_string:+_}${rvm_ruby_string:-}/"
}
__rvm_log_command_debug () 
{ 
    printf "%b" "[$(__rvm_date +'%Y-%m-%d %H:%M:%S')] ${_command_name}\n";
    if is_a_function "${_command_name}"; then
        \typeset -f "${_command_name}";
    fi;
    printf "%b" "current path: $PWD\n";
    env | __rvm_grep -E '^GEM_HOME=|^GEM_PATH=|^PATH=';
    printf "%b" "command(${#_command[@]}): ${_command[*]}\n"
}
__rvm_log_command_internal () 
{ 
    \typeset _log;
    (( ${rvm_niceness:-0} == 0 )) || _command=(nice -n $rvm_niceness "${_command[@]}");
    __rvm_log_command_caclulate_log_file_name;
    rvm_debug "Log file: ${_log}";
    [[ -d "${_log%\/*}" ]] || \command \mkdir -p "${_log%\/*}";
    [[ -f "${_log}" ]] || \command \rm -f "${_log}";
    __rvm_log_command_debug | tee "${_log}" | rvm_debug_stream;
    __rvm_log_dotted "${_log}" "$message" "${_command[@]}" || { 
        \typeset result=$?;
        \typeset __show_lines="${rvm_show_log_lines_on_error:-15}";
        rvm_error "Error running '${_command[*]}',";
        case "${__show_lines}" in 
            0)
                rvm_error "please read ${_log}"
            ;;
            all)
                rvm_error "content of log ${_log}";
                cat "${_log}" 1>&2
            ;;
            *)
                rvm_error "showing last ${__show_lines} lines of ${_log}";
                tail -n "${__show_lines}" "${_log}" 1>&2
            ;;
        esac;
        return ${result}
    }
}
__rvm_log_command_simple () 
{ 
    __rvm_log_command_debug;
    rvm_log "$message";
    "$@" || return $?
}
__rvm_log_dotted () 
{ 
    \typeset __log_file __message __iterator __result __local_rvm_trace_flag;
    __log_file="$1";
    __message="$2";
    shift 2;
    __result=0;
    __local_rvm_trace_flag=${rvm_trace_flag:-0};
    if (( ${rvm_trace_flag:-0} )); then
        { 
            set -x;
            "$@" 2>&1 | tee -a "${__log_file}";
            __rvm_check_pipestatus ${PIPESTATUS[@]} ${pipestatus[@]} || __result=$?;
            (( __local_rvm_trace_flag > 0 )) || set +x
        } 1>&2;
    else
        if [[ -n "${ZSH_VERSION:-}" ]]; then
            rvm_log "${__message} - please wait";
            { 
                set -x;
                "$@" > "${__log_file}" 2>&1 || __result=$?;
                (( __local_rvm_trace_flag > 0 )) || set +x
            } 2> /dev/null;
        else
            { 
                set -x;
                "$@" 2>&1 | tee -a "${__log_file}" | __rvm_dotted "${__message}";
                __rvm_check_pipestatus ${PIPESTATUS[@]} ${pipestatus[@]} || __result=$?;
                (( __local_rvm_trace_flag > 0 )) || set +x
            } 2> /dev/null;
        fi;
    fi;
    return $__result
}
__rvm_make () 
{ 
    \make "$@" || return $?
}
__rvm_md5_calculate () 
{ 
    \typeset _sum;
    if builtin command -v md5 > /dev/null 2>&1; then
        _sum=$(md5 "$@");
        echo ${_sum##* };
        return 0;
    else
        if builtin command -v md5sum > /dev/null 2>&1; then
            _sum=$(md5sum "$@");
            echo ${_sum%% *};
            return 0;
        else
            if builtin command -v gmd5sum > /dev/null 2>&1; then
                _sum=$(gmd5sum "$@");
                echo ${_sum%% *};
                return 0;
            else
                for _path in /usr/gnu/bin /opt/csw/bin /sbin /bin /usr/bin /usr/sbin;
                do
                    if [[ -x "${_path}/md5" ]]; then
                        _sum=$(${_path}/md5 "$@");
                        echo ${_sum##* };
                        return 0;
                    else
                        if [[ -x "${_path}/md5sum" ]]; then
                            _sum=$(${_path}/md5sum "$@");
                            echo ${_sum%% *};
                            return 0;
                        else
                            if [[ -x "${_path}/gmd5sum" ]]; then
                                _sum=$(${_path}/gmd5sum "$@");
                                echo ${_sum%% *};
                                return 0;
                            fi;
                        fi;
                    fi;
                done;
            fi;
        fi;
    fi;
    rvm_error "Neither of md5sum, md5, gmd5sum found in the PATH";
    return 1
}
__rvm_md5_for_contents () 
{ 
    if builtin command -v md5 > /dev/null; then
        md5 | __rvm_awk '{print $1}';
    else
        if builtin command -v md5sum > /dev/null; then
            md5sum | __rvm_awk '{print $1}';
        else
            if builtin command -v openssl > /dev/null; then
                openssl md5 | __rvm_awk '{print $1}';
            else
                return 1;
            fi;
        fi;
    fi;
    true
}
__rvm_meta () 
{ 
    rvm_meta_authors=("Michal Papis" "Piotr Kuczynski" "Wayne E. Seguin");
    rvm_meta_website="https://rvm.io/";
    rvm_meta_version="${rvm_version}"
}
__rvm_mount () 
{ 
    \mount "$@" || return $?
}
__rvm_nuke_rvm_variables () 
{ 
    unset rvm_head_flag $(env | __rvm_awk -F= '/^rvm_/{print $1" "}')
}
__rvm_package_create () 
{ 
    rvm_debug __rvm_package_create:$#: "$@";
    case "$1" in 
        *.tar.bz2)
            if [[ -z "${3:-}" ]]; then
                __rvm_tar cjf "$1" "$2";
            else
                __rvm_tar cjf "$1" -C "$2" "$3";
            fi
        ;;
        *.tar.gz | *.tgz)
            if [[ -z "${3:-}" ]]; then
                __rvm_tar czf "$1" "$2";
            else
                __rvm_tar czf "$1" -C "$2" "$3";
            fi
        ;;
        *)
            return 199
        ;;
    esac
}
__rvm_package_extract () 
{ 
    rvm_debug __rvm_package_extract:$#: "$@";
    \typeset __tempdir __path __file __return;
    __return=0;
    __tempdir="$( TMPDIR="${rvm_tmp_path}" mktemp -d -t rvm-tmp.XXXXXXXXX )";
    __rvm_package_extract_run "$1" "$__tempdir" || __return=$?;
    if (( __return == 0 )); then
        for __path in "$__tempdir"/*;
        do
            __file="${__path##*/}";
            if [[ -n "${__file}" && -e "$2/${__file}" ]]; then
                \command \rm -rf "$2/${__file}" || __return=$?;
            fi;
            \command \mv -f "${__path}" "$2/" || __return=$?;
        done;
    fi;
    if [[ -n "$__tempdir" ]]; then
        \command \rm -rf "$__tempdir";
    fi;
    return $__return
}
__rvm_package_extract_run () 
{ 
    if [[ " ${rvm_tar_options:-} " != *" --no-same-owner "* ]] && __rvm_tar --help 2>&1 | __rvm_grep -- --no-same-owner > /dev/null; then
        rvm_tar_options="${rvm_tar_options:-}${rvm_tar_options:+ }--no-same-owner";
    fi;
    [[ -d "$2" ]] || mkdir -p "$2";
    case "$1" in 
        *.zip)
            unzip -q -o "$1" -d "$2"
        ;;
        *.tar.bz2)
            if [[ -n "$ZSH_VERSION" ]]; then
                __rvm_tar xjf "$1" -C "$2" ${=rvm_tar_options:-};
            else
                __rvm_tar xjf "$1" -C "$2" ${rvm_tar_options:-};
            fi
        ;;
        *.tar.gz | *.tgz)
            if [[ -n "$ZSH_VERSION" ]]; then
                __rvm_tar xzf "$1" -C "$2" ${=rvm_tar_options:-};
            else
                __rvm_tar xzf "$1" -C "$2" ${rvm_tar_options:-};
            fi
        ;;
        *)
            return 199
        ;;
    esac && __rvm_fix_group_permissions "$2"/* || return $?
}
__rvm_package_list () 
{ 
    rvm_debug __rvm_package_list:$#: "$@";
    case "$1" in 
        *.zip)
            unzip -Z -1 "$1"
        ;;
        *.tar.bz2)
            __rvm_tar tjf "$1"
        ;;
        *.tar.gz | *.tgz)
            __rvm_tar tzf "$1"
        ;;
        *)
            return 199
        ;;
    esac
}
__rvm_pager_or_cat_v () 
{ 
    eval "${PAGER:-\command \cat} '$1'"
}
__rvm_parse_args () 
{ 
    \typeset _string;
    export rvm_ruby_string;
    rvm_action="${rvm_action:-""}";
    rvm_parse_break=0;
    if [[ " $* " == *" --trace "* ]]; then
        echo "$@";
        __rvm_version;
    fi;
    while [[ -n "$next_token" ]]; do
        rvm_token="$next_token";
        if (( $# > 0 )); then
            next_token="$1";
            shift;
        else
            next_token="";
        fi;
        case "$rvm_token" in 
            [0-9a-zA-ZuU]* | @*)
                case "$rvm_token" in 
                    use)
                        rvm_action="$rvm_token";
                        rvm_verbose_flag=1;
                        __rvm_file_env_check_unload;
                        if [[ -n "${next_token:-}" && ! -d "${next_token:-}" && "${next_token:-}" != "-"* && "${next_token:-}" != "@"* ]]; then
                            rvm_ruby_interpreter="$next_token";
                            rvm_ruby_string="$next_token";
                            rvm_ruby_strings="$next_token";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        else
                            if [[ -z "${next_token:-}" ]] && __rvm_project_dir_check .; then
                                __rvm_rvmrc_tools try_to_read_ruby . || __rvm_parse_args_error_finding_project_file;
                            fi;
                        fi
                    ;;
                    install | uninstall | reinstall | try_install)
                        export ${rvm_token}_flag=1;
                        rvm_action=$rvm_token
                    ;;
                    gemset)
                        rvm_action=$rvm_token;
                        rvm_ruby_args=();
                        __rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@";
                        : rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:;
                        next_token="${rvm_ruby_args[__array_start]}";
                        rvm_gemset_name="${rvm_ruby_args[__array_start+1]}";
                        case "${next_token:-help}" in 
                            help)
                                true
                            ;;
                            clear)
                                __rvm_gemset_clear
                            ;;
                            use | delete)
                                [[ "delete" != "$next_token" ]] || rvm_delete_flag=1;
                                [[ "use" != "$next_token" ]] || rvm_action+="_$next_token";
                                case "$rvm_gemset_name" in 
                                    *${rvm_gemset_separator:-"@"}*)
                                        rvm_ruby_string="${rvm_gemset_name%%${rvm_gemset_separator:-"@"}*}";
                                        rvm_gemset_name="${rvm_gemset_name##*${rvm_gemset_separator:-"@"}}";
                                        if [[ "${rvm_ruby_string:-""}" != "${rvm_gemset_name:-""}" ]]; then
                                            rvm_ruby_string="$rvm_ruby_string${rvm_gemset_separator:-"@"}$rvm_gemset_name";
                                        fi;
                                        rvm_ruby_gem_home="$rvm_ruby_gem_home${rvm_gemset_separator:-"@"}$rvm_gemset_name"
                                    ;;
                                    "")
                                        rvm_error "Gemset was not given.\n  Usage:\n    rvm gemset $rvm_gemset_name <gemsetname>\n";
                                        return 1
                                    ;;
                                esac
                            ;;
                        esac;
                        rvm_parse_break=1
                    ;;
                    gemdir | gempath | gemhome)
                        rvm_ruby_args=("$rvm_token");
                        rvm_action="gemset";
                        rvm_gemdir_flag=1;
                        if [[ "system" == "$next_token" ]]; then
                            rvm_system_flag=1;
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        fi;
                        if [[ "user" == "$next_token" ]]; then
                            rvm_user_flag=1;
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        fi
                    ;;
                    pkg)
                        rvm_action="$rvm_token";
                        __rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@";
                        rvm_parse_break=1
                    ;;
                    do | exec)
                        if [[ -z "$next_token" ]]; then
                            rvm_action="error";
                            rvm_error_message="'rvm $rvm_token' must be followed by arguments.";
                            break;
                        fi;
                        rvm_action="do";
                        rvm_ruby_args=("$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    gem | rake | ruby)
                        [[ "$rvm_token" == "ruby" ]] && case $rvm_action in 
                            install | reinstall | use | remove)
                                rvm_ruby_string=ruby;
                                rvm_ruby_strings=ruby;
                                continue
                            ;;
                        esac;
                        rvm_action=error;
                        rvm_error_message="Please note that \`rvm $rvm_token ...\` was removed, try \`$rvm_token $next_token $*\` or \`rvm all do $rvm_token $next_token $*\` instead."
                    ;;
                    fetch | version | remote_version | reset | debug | reload | update | monitor | notes | implode | seppuku | env | unexport | automount | prepare)
                        rvm_action=$rvm_token
                    ;;
                    doctor)
                        rvm_action=notes
                    ;;
                    mount)
                        rvm_action=$rvm_token;
                        while [[ -n "${next_token:-}" ]] && [[ -x "${next_token:-}" || -d "${next_token:-}" || "${next_token:-}" == http* || "${next_token:-}" == *tar.bz2 || "${next_token:-}" == *tar.gz ]]; do
                            rvm_ruby_args=("$next_token" "${rvm_ruby_args[@]}");
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        done
                    ;;
                    rm | remove)
                        rvm_action="remove";
                        rvm_remove_flag=1
                    ;;
                    rtfm | RTFM | rvmrc | usage | help | inspect | list | ls | info | strings | get | current | docs | alias | rubygems | cleanup | tools | disk-usage | snapshot | repair | migrate | downgrade | upgrade | cron | group | switch | which | config-get | requirements | autolibs | osx-ssl-certs | fix-permissions)
                        case "$rvm_token" in 
                            downgrade)
                                rvm_action="upgrade"
                            ;;
                            ls)
                                rvm_action="list"
                            ;;
                            usage)
                                rvm_action="help"
                            ;;
                            RTFM)
                                rvm_action="rtfm"
                            ;;
                            *)
                                rvm_action="$rvm_token"
                            ;;
                        esac;
                        rvm_ruby_args=();
                        __rvm_parse_args_find_known_flags rvm_ruby_args "$next_token" "$@";
                        rvm_parse_break=1
                    ;;
                    user)
                        rvm_action="tools";
                        rvm_ruby_args=("$rvm_token" "$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    load-rvmrc)
                        rvm_action="rvmrc";
                        rvm_ruby_args=("load" "$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    specs | tests)
                        rvm_action="rake";
                        rvm_ruby_args=("${rvm_token/%ss/s}")
                    ;;
                    export)
                        if [[ -n "$next_token" ]]; then
                            \typeset -a ___args;
                            ___args=("$next_token" "$@");
                            rvm_export_args="${___args[*]}";
                            rvm_action="export";
                            rvm_parse_break=1;
                        else
                            rvm_action="error";
                            rvm_error_message="rvm export must be followed by a NAME=VALUE argument";
                        fi
                    ;;
                    alt*)
                        rvm_action="help";
                        rvm_ruby_args=("alt.md");
                        rvm_parse_break=1
                    ;;
                    wrapper)
                        rvm_action="wrapper";
                        rvm_ruby_string="$next_token";
                        rvm_wrapper_name="$1";
                        (( $# == 0 )) || shift;
                        rvm_ruby_args=("$@");
                        rvm_parse_break=1
                    ;;
                    in)
                        rvm_token="${next_token}";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        export rvm_in_flag="$rvm_token";
                        __rvm_project_dir_check "$rvm_token" && __rvm_rvmrc_tools try_to_read_ruby $rvm_token || __rvm_parse_args_error_finding_project_file
                    ;;
                    *,*)
                        rvm_ruby_strings="$rvm_token";
                        [[ -n "${rvm_action:-""}" ]] || rvm_action="ruby"
                    ;;
                    ${rvm_gemset_separator:-"@"}*)
                        rvm_action="${rvm_action:-use}";
                        rvm_gemset_name="${rvm_token#${rvm_gemset_separator:-"@"}}";
                        rvm_ruby_string="${rvm_ruby_string:-${GEM_HOME##*/}}";
                        rvm_ruby_string="${rvm_ruby_string%%${rvm_gemset_separator:-"@"}*}";
                        rvm_ruby_strings="${rvm_ruby_string}${rvm_gemset_separator:-"@"}${rvm_gemset_name}"
                    ;;
                    *${rvm_gemset_separator:-"@"}*)
                        rvm_verbose_flag=1;
                        rvm_action="${rvm_action:-use}";
                        rvm_gemset_name="${rvm_token/*${rvm_gemset_separator:-"@"}/}";
                        rvm_ruby_string="$rvm_token";
                        rvm_ruby_strings="$rvm_token"
                    ;;
                    *+*)
                        rvm_action="${rvm_action:-use}";
                        rvm_ruby_alias="${rvm_token/*+/}";
                        rvm_ruby_string="${rvm_token/+*/}";
                        rvm_ruby_strings="$rvm_ruby_string"
                    ;;
                    *-* | +([0-9]).+([0-9])*)
                        rvm_verbose_flag=1;
                        rvm_action="${rvm_action:-use}";
                        rvm_ruby_string="$rvm_token";
                        rvm_ruby_strings="$rvm_token"
                    ;;
                    opal* | jruby* | ree* | macruby* | rbx* | rubinius* | mruby | ironruby* | default* | maglev* | topaz* | ruby* | system | default | all)
                        rvm_action="${rvm_action:-use}";
                        rvm_ruby_interpreter="$rvm_token";
                        rvm_ruby_string="$rvm_token";
                        rvm_ruby_strings="$rvm_token"
                    ;;
                    kiji* | tcs* | jamesgolick*)
                        rvm_error_message="The $rvm_token was removed from RVM, use: rvm install ruby-head-<name> --url https://github.com/github/ruby.git --branch 2.1";
                        rvm_action="error"
                    ;;
                    old)
                        case "${rvm_action:-action-missing}" in 
                            remove)
                                rvm_ruby_strings="old:${next_token:-}";
                                next_token="${1:-}";
                                (( $# == 0 )) || shift
                            ;;
                            action-missing)
                                rvm_error_message="what do you want to do with old rubies? rvm can only remove old rubies.";
                                rvm_action="error"
                            ;;
                            *)
                                rvm_error_message="rvm can not $rvm_action old rubies, rvm can only remove old rubies.";
                                rvm_action="error"
                            ;;
                        esac
                    ;;
                    *.rb)
                        rvm_ruby_args=("$rvm_token");
                        rvm_ruby_file="$rvm_token";
                        if [[ -z "${rvm_action:-""}" || "$rvm_action" == "use" ]]; then
                            rvm_action="ruby";
                        fi
                    ;;
                    *.gems)
                        rvm_file_name="${rvm_token}"
                    ;;
                    "")
                        rvm_action="error";
                        rvm_error_message="Unrecognized command line argument(s): '$@'"
                    ;;
                    *)
                        if [[ "gemset" == "$rvm_action" ]]; then
                            rvm_gemset_name="${rvm_token/.gems/}";
                            rvm_file_name="$rvm_gemset_name.gems";
                        else
                            if [[ -f "$rvm_rubies_path/$rvm_token" || -L "$rvm_rubies_path/$rvm_token" ]]; then
                                rvm_ruby_string=$rvm_token;
                                rvm_ruby_strings="$rvm_token";
                                rvm_action="${rvm_action:-use}";
                            else
                                if [[ -d "$rvm_token" ]] || __rvm_project_dir_check "$rvm_token"; then
                                    __rvm_rvmrc_tools try_to_read_ruby $rvm_token || __rvm_parse_args_error_finding_project_file;
                                else
                                    rvm_action="error";
                                    rvm_error_message="Unrecognized command line argument: '$rvm_token'";
                                fi;
                            fi;
                        fi
                    ;;
                esac
            ;;
            -*)
                case "$rvm_token" in 
                    -S)
                        rvm_action="ruby";
                        rvm_ruby_args=("$rvm_token" "$next_token" "$@");
                        rvm_parse_break=1
                    ;;
                    -e)
                        rvm_action="ruby";
                        IFS="\n";
                        rvm_ruby_args=("$rvm_token" "'$next_token $@'");
                        IFS=" ";
                        rvm_parse_break=1
                    ;;
                    -v | --version)
                        if [[ -z "$next_token" ]]; then
                            rvm_action="version";
                        else
                            rvm_ruby_version="$next_token";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        fi
                    ;;
                    -n | --name)
                        rvm_ruby_name="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --branch)
                        rvm_ruby_repo_branch="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_disable_binary_flag=1
                    ;;
                    --repository | --repo | --url)
                        rvm_ruby_repo_url="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_disable_binary_flag=1
                    ;;
                    -r | --remote | --binary | --latest-binary)
                        rvm_remote_flag=1;
                        if [[ "$rvm_token" == "--latest-binary" ]]; then
                            rvm_fuzzy_flag=1;
                        fi;
                        while [[ -n "${next_token:-}" ]] && [[ "${next_token:-}" == http* || "${next_token:-}" == *tar.bz2 || "${next_token:-}" == *tar.gz || "${next_token:-}" == *":"* ]]; do
                            rvm_ruby_args=("${rvm_ruby_args[@]}" "$next_token");
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        done
                    ;;
                    --ree-options)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_ree_options , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        else
                            rvm_action="error";
                            rvm_error_message="--ree-options *must* be followed by... well... comma,separated,list,of,options.";
                        fi
                    ;;
                    --patches | --patch)
                        __rvm_custom_separated_array rvm_patch_names , "$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_patch_original_pwd="$PWD";
                        rvm_disable_binary_flag=1
                    ;;
                    --arch | --archflags)
                        rvm_architectures+=("${next_token#-arch }");
                        next_token="${1:-}";
                        (( $# == 0 )) || shift;
                        rvm_disable_binary_flag=1
                    ;;
                    --with-arch=*)
                        rvm_architectures+=("${rvm_token#--with-arch=}");
                        rvm_disable_binary_flag=1
                    ;;
                    --32 | --64)
                        rvm_architectures+=("${rvm_token#--}");
                        rvm_disable_binary_flag=1
                    ;;
                    --universal)
                        rvm_architectures+=("32" "64");
                        rvm_disable_binary_flag=1
                    ;;
                    --bin)
                        rvm_bin_path="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --rdoc | --yard)
                        rvm_docs_type="$rvm_token";
                        rvm_docs_type
                    ;;
                    -f | --file)
                        rvm_action="ruby";
                        rvm_ruby_file="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --passenger)
                        rvm_log "NOTE: If you are using Passenger 3 you no longer need the passenger_ruby,\nuse the wrapper script for your ruby instead (see 'rvm wrapper')";
                        rvm_wrapper_name="${rvm_token/--/}"
                    ;;
                    --editor)
                        rvm_wrapper_name="${rvm_token/--/}"
                    ;;
                    --symlink)
                        rvm_warn "--symlink has been removed, please see 'rvm wrapper'.";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    -h | --help)
                        rvm_action=help
                    ;;
                    -l | --level)
                        rvm_ruby_patch_level="p$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --sha | --make | --make-install)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_ruby_${rvm_token}"="$next_token";
                        next_token="${1:-}";
                        rvm_disable_binary_flag=1;
                        (( $# == 0 )) || shift
                    ;;
                    --nice | --sdk | --autoconf-flags | --proxy)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --disable-llvm | --disable-jit)
                        rvm_llvm_flag=0
                    ;;
                    --enable-llvm | --enable-jit)
                        rvm_llvm_flag=1
                    ;;
                    --install)
                        rvm_install_on_use_flag=1
                    ;;
                    --autolibs=*)
                        export rvm_autolibs_flag="${rvm_token#*=}"
                    ;;
                    --color=*)
                        rvm_pretty_print_flag=${rvm_token#--color=}
                    ;;
                    --pretty)
                        rvm_pretty_print_flag=auto
                    ;;
                    --1.8 | --1.9 | --2.0 | --2.1 | --18 | --19 | --20 | --21)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//\./};
                        export "rvm_${rvm_token}_flag"=1;
                        rvm_disable_binary_flag=1
                    ;;
                    --rvmrc | --versions-conf | --ruby-version)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export rvm_rvmrc_flag="${rvm_token}"
                    ;;
                    --list-missing-packages)
                        export rvm_list_missing_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --list-undesired-packages)
                        export rvm_list_undesired_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --list-installed-packages)
                        export rvm_list_installed_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --list-all-packages)
                        export rvm_list_missing_packages_flag=1;
                        export rvm_list_undesired_packages_flag=1;
                        export rvm_list_installed_packages_flag=1;
                        export rvm_quiet_flag=1
                    ;;
                    --head | --static | --self | --gem | --reconfigure | --default | --force | --export | --summary | --latest | --yaml | --json | --archive | --shebang | --path | --cron | --tail | --delete | --verbose | --import | --sticky | --create | --gems | --docs | --skip-autoreconf | --force-autoconf | --auto-dotfiles | --autoinstall-bundler | --disable-binary | --ignore-gemsets | --skip-gemsets | --debug | --quiet | --silent | --skip-openssl | --fuzzy | --quiet-curl | --skip-pristine | --dynamic-extensions)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag"=1
                    ;;
                    --no-docs)
                        rvm_token=${rvm_token#--no-};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag"=0
                    ;;
                    --auto)
                        export "rvm_auto_dotfiles_flag"=1;
                        rvm_warn "Warning, --auto is deprecated in favor of --auto-dotfiles."
                    ;;
                    --rubygems)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_version"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --dump-environment | --max-time)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --verify-downloads)
                        rvm_token=${rvm_token#--};
                        rvm_token=${rvm_token//-/_};
                        export "rvm_${rvm_token}_flag_cli"="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    --clang)
                        export CC=clang;
                        export CXX=clang++;
                        rvm_disable_binary_flag=1
                    ;;
                    -M)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_make_flags , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                            rvm_disable_binary_flag=1;
                        else
                            rvm_action="error";
                            rvm_error_message="--make *must* be followed by make flags.";
                        fi
                    ;;
                    -j)
                        if [[ -n "$next_token" ]]; then
                            rvm_make_flags+=(-j$next_token);
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                        else
                            rvm_action="error";
                            rvm_error_message="-j *must* be followed by an integer (normally the # of CPU's in your machine).";
                        fi
                    ;;
                    --with-rubies)
                        rvm_ruby_strings="$next_token";
                        next_token="${1:-}";
                        (( $# == 0 )) || shift
                    ;;
                    -C | --configure)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_configure_flags , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                            rvm_disable_binary_flag=1;
                        else
                            rvm_action="error";
                            rvm_error_message="--configure *must* be followed by configure flags.";
                        fi
                    ;;
                    -E | --env)
                        if [[ -n "$next_token" ]]; then
                            __rvm_custom_separated_array rvm_configure_env , "${next_token}";
                            next_token="${1:-}";
                            (( $# == 0 )) || shift;
                            rvm_disable_binary_flag=1;
                        else
                            rvm_action="error";
                            rvm_error_message="--configure *must* be followed by configure flags.";
                        fi
                    ;;
                    --movable)
                        rvm_movable_flag=1;
                        rvm_disable_binary_flag=1
                    ;;
                    --with-* | --without-* | --enable-* | --disable-*)
                        rvm_configure_flags+=("$rvm_token");
                        rvm_disable_binary_flag=1
                    ;;
                    --trace)
                        export rvm_trace_flag=1;
                        if [[ -n "${BASH_VERSION:-}" ]]; then
                            export PS4="+ \$(__rvm_date \"+%s.%N\" 2>/dev/null) \${BASH_SOURCE##\${rvm_path:-}} : \${FUNCNAME[0]:+\${FUNCNAME[0]}()}  \${LINENO} > ";
                        else
                            if [[ -n "${ZSH_VERSION:-}" ]]; then
                                export PS4="+ %* %F{red}%x:%I %F{green}%N:%i%F{white} %_";
                            fi;
                        fi;
                        set -o xtrace
                    ;;
                    --)
                        if [[ "${rvm_action}" == *install ]]; then
                            rvm_configure_flags+=("$next_token" "$@");
                        else
                            rvm_ruby_args=("$next_token" "$@");
                        fi;
                        rvm_disable_binary_flag=1;
                        rvm_parse_break=1
                    ;;
                    *)
                        rvm_action="error";
                        rvm_error_message="Unrecognized command line flag: '$rvm_token'"
                    ;;
                esac
            ;;
            *)
                if [[ -d "$rvm_token" ]] || __rvm_project_dir_check "$rvm_token"; then
                    __rvm_rvmrc_tools try_to_read_ruby "$rvm_token" || __rvm_parse_args_error_finding_project_file;
                else
                    rvm_action="error";
                    rvm_error_message="Unrecognized command line argument(s): '$rvm_token $@'";
                fi
            ;;
        esac;
        if [[ -z "${rvm_action:-""}" && -n "${rvm_ruby_string:-""}" ]]; then
            rvm_action="use";
        fi;
        if [[ "error" == "${rvm_action:-""}" || ${rvm_parse_break:-0} -eq 1 || -n "${rvm_error_message:-""}" ]]; then
            break;
        fi;
    done;
    : rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:;
    if [[ -n "${rvm_error_message:-""}" ]]; then
        rvm_error "$rvm_error_message ( see: 'rvm usage' )";
        unset rvm_error_message;
        return 1;
    fi
}
__rvm_parse_args_error_finding_project_file () 
{ 
    unset RVM_PROJECT_PATH;
    case $? in 
        101)
            true
        ;;
        *)
            rvm_error_message="Could not determine which Ruby to use; $rvm_token should contain .rvmrc or .versions.conf or .ruby-version or .rbfu-version or .rbenv-version, or an appropriate line in Gemfile."
        ;;
    esac;
    rvm_action="error"
}
__rvm_parse_args_find_known_flags () 
{ 
    \typeset _args_array_name _temp_var;
    \typeset -a _new_args;
    _args_array_name="$1";
    (( $# == 0 )) || shift;
    _new_args=();
    while (( $# )); do
        case "$1" in 
            --verify-downloads)
                export "rvm_verify_downloads_flag_cli"="${2:-}";
                shift
            ;;
            --force | --verbose | --debug | --quiet | --silent | --create)
                export "rvm_${1#--}_flag=1"
            ;;
            --only-path)
                _temp_var="${1#--}";
                export "rvm_${_temp_var//-/_}_flag=1"
            ;;
            --32 | --64)
                rvm_architectures+=("${1#--}");
                rvm_disable_binary_flag=1
            ;;
            --universal)
                rvm_architectures+=("32" "64");
                rvm_disable_binary_flag=1
            ;;
            --patches | --patch)
                __rvm_custom_separated_array rvm_patch_names , "${2:-}";
                rvm_patch_original_pwd="$PWD";
                rvm_disable_binary_flag=1;
                shift
            ;;
            --autolibs=*)
                export rvm_autolibs_flag="${1#*=}"
            ;;
            --)
                shift;
                _new_args+=("$@");
                shift $#
            ;;
            *)
                _new_args+=("$1")
            ;;
        esac;
        (( $# == 0 )) || shift;
    done;
    eval "${_args_array_name}+=( \"\${_new_args[@]}\" )"
}
__rvm_parse_gems_args () 
{ 
    \typeset gem="${*%%;*}";
    if __rvm_string_match "$gem" "*.gem$"; then
        gem_name="$(basename "${gem/.gem/}" |  __rvm_awk -F'-' '{$NF=NULL;print}')";
        gem_version="$(basename "${gem/.gem/}" |  __rvm_awk -F'-' '{print $NF}' )";
    else
        gem_name="${gem/ */}";
        case "$gem" in 
            *--version*)
                gem_version=$(
          echo "$gem" | __rvm_sed -e 's#.*--version[=]*[ ]*##' | __rvm_awk '{print $1}'
        )
            ;;
            *-v*)
                gem_version=$(
          echo "$gem" | __rvm_sed -e 's#.*-v[=]*[ ]*##' | __rvm_awk '{print $1}'
        )
            ;;
        esac;
    fi
}
__rvm_patch () 
{ 
    \patch "$@" || return $?
}
__rvm_path_match_gem_home_check () 
{ 
    (( ${rvm_silence_path_mismatch_check_flag:-0} == 0 )) || return 0;
    if [[ -n "${GEM_HOME:-}" ]]; then
        case "$PATH:" in 
            $GEM_HOME/bin:*)
                true
            ;;
            *:$GEM_HOME/bin:*)
                __rvm_path_match_gem_home_check_warning "is not at first place"
            ;;
            *)
                __rvm_path_match_gem_home_check_warning "is not available"
            ;;
        esac;
    else
        \typeset __path_to_ruby;
        if __path_to_ruby="$( builtin command -v ruby 2>/dev/null )" && [[ "${__path_to_ruby}" == "${rvm_path}"* ]]; then
            __path_to_ruby="${__path_to_ruby%/bin/ruby}";
            __path_to_ruby="${__path_to_ruby##*/}";
            __rvm_path_match_gem_home_check_warning_missing "${__path_to_ruby}";
        fi;
    fi
}
__rvm_path_match_gem_home_check_warn () 
{ 
    rvm_warn "Warning! PATH is not properly set up, $1.
         Usually this is caused by shell initialization files. Search for 'PATH=...' entries.
         You can also re-add RVM to your profile by running: 'rvm get stable --auto-dotfiles'.
         To fix it temporarily in this shell session run: 'rvm use $2'.
         To ignore this error add rvm_silence_path_mismatch_check_flag=1 to your ~/.rvmrc file."
}
__rvm_path_match_gem_home_check_warning () 
{ 
    __rvm_path_match_gem_home_check_warn "'$GEM_HOME/bin' $1" "${GEM_HOME##*/}"
}
__rvm_path_match_gem_home_check_warning_missing () 
{ 
    __rvm_path_match_gem_home_check_warn "\$GEM_HOME is not set" "$1"
}
__rvm_project_dir_check () 
{ 
    \typeset _found_file path_to_check variable variable_default;
    \typeset -a _valid_files;
    path_to_check="$1";
    variable="${2:-}";
    variable_default="${3:-}";
    _valid_files=("$path_to_check" "$path_to_check/.rvmrc" "$path_to_check/.versions.conf" "$path_to_check/.ruby-version" "$path_to_check/.rbfu-version" "$path_to_check/.rbenv-version" "$path_to_check/Gemfile");
    __rvm_find_first_file _found_file "${_valid_files[@]}" || true;
    if [[ "${_found_file##*/}" == "Gemfile" ]]; then
        if [[ -s "$_found_file" ]] && { 
            __rvm_grep "^#ruby=" "$_found_file" > /dev/null || __rvm_grep -E "^\s*ruby" "$_found_file" > /dev/null
        }; then
            true;
        else
            _found_file="";
        fi;
    else
        if [[ "${_found_file}" == "$HOME/.rvmrc" ]]; then
            _found_file="";
        fi;
    fi;
    if [[ -n "$variable" ]]; then
        eval "$variable=\"\${_found_file:-$variable_default}\"";
    fi;
    if [[ -n "${_found_file:-$variable_default}" ]]; then
        RVM_PROJECT_PATH="${_found_file:-$variable_default}";
        RVM_PROJECT_PATH="${RVM_PROJECT_PATH%/*}";
    else
        \typeset __result=$?;
        unset RVM_PROJECT_PATH;
        return $__result;
    fi
}
__rvm_project_rvmrc () 
{ 
    export __rvm_project_rvmrc_lock;
    : __rvm_project_rvmrc_lock:${__rvm_project_rvmrc_lock:=0};
    : __rvm_project_rvmrc_lock:$((__rvm_project_rvmrc_lock+=1));
    if (( __rvm_project_rvmrc_lock > 1 )); then
        return 0;
    fi;
    \typeset working_dir found_file rvm_trustworthiness_result save_PATH;
    working_dir="${1:-"$PWD"}";
    save_PATH="${PATH}";
    while :; do
        if [[ -z "$working_dir" || "$HOME" == "$working_dir" || "${rvm_prefix:-}" == "$working_dir" || "$working_dir" == "." ]]; then
            if (( ${rvm_project_rvmrc_default:-0} >= 1 )); then
                rvm_previous_environment=default;
            fi;
            if [[ -n "${rvm_previous_environment:-""}" ]] && (( ${rvm_project_rvmrc_default:-0} < 2 )); then
                __rvm_load_environment "$rvm_previous_environment";
            fi;
            __rvm_file_env_check_unload;
            unset rvm_current_rvmrc rvm_previous_environment;
            break;
        else
            if __rvm_project_dir_check "$working_dir" found_file; then
                rvm_trustworthiness_result=0;
                if [[ "${found_file}" != "${rvm_current_rvmrc:-""}" ]]; then
                    __rvm_conditionally_do_with_env __rvm_load_project_config "${found_file}" || { 
                        rvm_trustworthiness_result=$?;
                        PATH="${save_PATH}";
                        unset RVM_PROJECT_PATH
                    };
                fi;
                unset __rvm_project_rvmrc_lock;
                return "$rvm_trustworthiness_result";
            else
                working_dir="${working_dir%/*}";
            fi;
        fi;
    done;
    unset __rvm_project_rvmrc_lock;
    return 1
}
__rvm_read_lines () 
{ 
    \typeset IFS;
    IFS="
";
    if [[ "${2:--}" == "-" ]]; then
        eval "$1=( \$( \command \cat - ) )";
    else
        eval "$1=( \$( \command \cat \"\${2:--}\" ) )";
    fi
}
__rvm_readlink () 
{ 
    \readlink "$@" || return $?
}
__rvm_readlink_deep () 
{ 
    eval "
    while [[ -n \"\${$1}\" && -L \"\${$1}\" ]]
    do $1=\"\$(__rvm_readlink \"\${$1}\")\"
    done
  "
}
__rvm_record_install () 
{ 
    [[ -n "$1" ]] || return;
    \typeset recorded_ruby_name rvm_install_record_file;
    recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )";
    rvm_install_record_file="$rvm_user_path/installs";
    [[ -f "$rvm_install_record_file" ]] || \command \touch "$rvm_install_record_file";
    __rvm_sed_i "$rvm_install_record_file" -e "/^$recorded_ruby_name/d";
    printf "%b" "$recorded_ruby_name -- ${rvm_configure_flags[*]}\n" >> "$rvm_install_record_file"
}
__rvm_record_ruby_configs () 
{ 
    \typeset __dir;
    for __dir in "$rvm_path/rubies/"*;
    do
        if [[ ! -L "${__dir}" && ! -s "${__dir}/config" && -x "${__dir}/bin/ruby" ]]; then
            __rvm_ruby_config_save "${__dir}/bin/ruby" "${__dir}/config" || { 
                \typeset string="${__dir##*/}";
                rvm_error "    Can not save config data for ruby: '${string}', most likely it is broken installation and you can:
    - try fix it: 'rvm reinstall ${string}', OR:
    - remove  it: 'rvm uninstall ${string} --gems'"
            };
        fi;
    done
}
__rvm_recorded_install_command () 
{ 
    \typeset recorded_ruby_name;
    recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )";
    recorded_ruby_name=${recorded_ruby_name%%${rvm_gemset_seperator:-"@"}*};
    [[ -n "$recorded_ruby_name" ]] || return 1;
    if [[ -s "$rvm_user_path/installs" ]] && __rvm_grep "^$recorded_ruby_name " "$rvm_user_path/installs" > /dev/null 2>&1; then
        __rvm_grep "^$recorded_ruby_name " "$rvm_user_path/installs" | \command \head -n 1;
    else
        return 1;
    fi
}
__rvm_remote_extension () 
{ 
    case "$1" in 
        *.tar.*)
            rvm_remote_extension="tar${1##*tar}"
        ;;
        jruby-*)
            rvm_remote_extension="tar.gz"
        ;;
        *)
            rvm_remote_extension="tar.bz2"
        ;;
    esac;
    [[ "$2" != "-" ]] || printf "%b" "${rvm_remote_extension}"
}
__rvm_remote_server_path () 
{ 
    \typeset _iterator;
    _iterator="";
    while ! __rvm_remote_server_path_single 0 1 "${_iterator}" "${1:-}"; do
        : $(( _iterator+=1 ));
    done
}
__rvm_remote_server_path_single () 
{ 
    \typeset __remote_file;
    __rvm_calculate_remote_file "$@" || return $?;
    if [[ -z "${__remote_file:-}" ]]; then
        rvm_debug "No remote file name found";
        return $1;
    else
        if file_exists_at_url "${__remote_file}"; then
            rvm_debug "Remote file exists ${__remote_file}";
            printf "%b" "$( __rvm_db "rvm_remote_server_verify_downloads${3:-}" ):${__remote_file}";
        else
            if [[ -f "${rvm_archives_path}/${rvm_ruby_package_file##*/}" && "${rvm_ruby_package_file##*/}" == *bin-* ]]; then
                rvm_debug "Cached file exists ${__remote_file}";
                printf "%b" "$( __rvm_db "rvm_remote_server_verify_downloads${3:-}" ):${rvm_archives_path}/${rvm_ruby_package_file##*/}";
            else
                rvm_debug "Remote file does not exist ${__remote_file}";
                return $2;
            fi;
        fi;
    fi
}
__rvm_remote_version () 
{ 
    __rvm_curl -s --max-time 10 https://github.com/rvm/rvm/raw/master/VERSION || true
}
__rvm_remove_broken_symlinks () 
{ 
    if [[ ! -e "$1" && -L "$1" ]]; then
        __rvm_rm_rf "$1";
    fi
}
__rvm_remove_from_array () 
{ 
    \typeset _array_name _iterator _search;
    \typeset -a _temp_array;
    _array_name="$1";
    _search="$2";
    shift 2;
    _temp_array=();
    for _iterator in "$@";
    do
        __rvm_string_match "$_iterator" "$_search" || _temp_array+=("$_iterator");
    done;
    eval "$_array_name=( \"\${_temp_array[@]}\" )"
}
__rvm_remove_from_path () 
{ 
    export PATH;
    \typeset _value;
    _value="${1//+(\/)//}";
    if [[ "$PATH" == *"//"* || "$PATH" == *"/:"* ]]; then
        if [[ "${_system_type}" = "Darwin" ]]; then
            PATH="$(\sed -E -e 's#/+#/#g' -e 's#/:#:#' <<<$PATH)";
        else
            PATH="$(\sed -r -e 's#/+#/#g' -e 's#/:#:#' <<<$PATH)";
        fi;
    fi;
    if __rvm_string_match ":$PATH:" "*:${_value}:*"; then
        \typeset -a _path;
        _path=();
        __rvm_custom_separated_array _path : "${PATH}";
        __rvm_remove_from_array _path "${_value}" "${_path[@]}";
        __rvm_join_array PATH : _path;
    fi
}
__rvm_remove_install_record () 
{ 
    \typeset recorded_ruby_name rvm_install_record_file;
    recorded_ruby_name="$( "$rvm_scripts_path/tools" strings "$1" )";
    rvm_install_record_file="$rvm_user_path/installs";
    if [[ -s "$rvm_install_record_file" ]]; then
        __rvm_sed_i "$rvm_install_record_file" -e "/^$recorded_ruby_name/d";
    fi
}
__rvm_remove_rvm_from_path () 
{ 
    \typeset local_rvm_path;
    __rvm_remove_from_path "${rvm_path%/}/*";
    __rvm_remove_from_path "${rvm_bin_path}";
    while local_rvm_path="$( __rvm_which rvm 2>/dev/null )"; do
        __rvm_remove_from_path "${local_rvm_path%/*}";
    done;
    builtin hash -r
}
__rvm_remove_without_gems () 
{ 
    [[ -n "${rvm_without_gems}" ]] || return 0;
    \typeset -a __gems_to_remove __extra_flags;
    __rvm_read_lines __gems_to_remove <(
    GEM_PATH="$GEM_HOME" __rvm_list_gems "" "${rvm_without_gems}"
  );
    (( ${#__gems_to_remove[@]} )) || return 0;
    __extra_flags=();
    if __rvm_version_compare "$(\command \gem --version)" -ge 2.1.0; then
        __extra_flags+=(--abort-on-dependent);
    fi;
    \typeset __gem __name __version;
    for __gem in "${__gems_to_remove[@]}";
    do
        __name="${__gem% *}";
        __version="${__gem##* }";
        __rvm_log_command "gem.uninstall.${__name}-${__version}" "$rvm_ruby_string - #uninstalling gem ${__name}-${__version}" \command \gem uninstall "${__name}" -v "${__version}" -x "${__extra_flags[@]}" || true;
    done
}
__rvm_reset_rvmrc_trust () 
{ 
    if [[ "$1" == all ]]; then
        echo "" > "${rvm_user_path:-${rvm_path}/user}/rvmrcs";
    else
        __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "delete" > /dev/null 2>&1;
    fi
}
__rvm_rm_rf () 
{ 
    __rvm_rm_rf_verbose "$@"
}
__rvm_rm_rf_verbose () 
{ 
    \typeset target;
    target="${1%%+(/|.)}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        \builtin setopt extendedglob;
    else
        if [[ -n "${BASH_VERSION:-}" ]]; then
            \builtin shopt -s extglob;
        else
            rvm_error "What the heck kind of shell are you running here???";
        fi;
    fi;
    case "${target}" in 
        *(/|.)@(|/Applications|/Developer|/Guides|/Information|/Library|/Network|/System|/User|/Users|/Volumes|/backups|/bdsm|/bin|/boot|/cores|/data|/dev|/etc|/home|/lib|/lib64|/mach_kernel|/media|/misc|/mnt|/net|/opt|/private|/proc|/root|/sbin|/selinux|/srv|/sys|/tmp|/usr|/var))
            rvm_debug "__rvm_rm_rf target is not valid - can not remove";
            return 1
        ;;
        *)
            if [[ -z "${target}" ]]; then
                rvm_debug "__rvm_rm_rf target not given";
                return 1;
            else
                if [[ -d "${target}" ]]; then
                    \command \rm -rf "${target}" || { 
                        \typeset ret=$?;
                        rvm_debug "__rvm_rm_rf error removing target dir '${target}'.";
                        return $ret
                    };
                else
                    if [[ -f "${target}" || -L "${target}" ]]; then
                        \command \rm -f "${target}" || { 
                            \typeset ret=$?;
                            rvm_debug "__rvm_rm_rf error removing target file/link '${target}'.";
                            return $ret
                        };
                    else
                        rvm_debug "__rvm_rm_rf already gone: $*";
                    fi;
                fi;
            fi
        ;;
    esac;
    true
}
__rvm_ruby_config_get () 
{ 
    \typeset variable_name ruby_path;
    variable_name="$1";
    ruby_path="${2:-$rvm_ruby_home/bin/ruby}";
    __rvm_string_match "$ruby_path" "*mruby*" && return;
    case "${variable_name:---all}" in 
        --all)
            "$ruby_path" -rrbconfig -e 'puts RbConfig::CONFIG.sort.map{|k,v| "#{k}: #{v}" }' 2> /dev/null || return $?
        ;;
        *)
            "$ruby_path" -rrbconfig -e 'puts RbConfig::CONFIG["'"$variable_name"'"]' 2> /dev/null || return $?
        ;;
    esac
}
__rvm_ruby_config_save () 
{ 
    \typeset ruby_path;
    ruby_path="${1:-$rvm_ruby_home/bin/ruby}";
    case "$ruby_path" in 
        */mruby*)
            __rvm_ruby_config_save_mruby "${2:-${ruby_path%%/bin/ruby}/config}"
        ;;
        *)
            __rvm_ruby_config_save_generic "$2"
        ;;
    esac
}
__rvm_ruby_config_save_generic () 
{ 
    \typeset config_path default_config_path;
    default_config_path="#{RbConfig::CONFIG[\"prefix\"]}/config";
    config_path="${1:-$default_config_path}";
    "$ruby_path" -rrbconfig -e '\
    File.open("'"$config_path"'","w") { |file|
      RbConfig::CONFIG.sort.each{|key,value|
        file.write("#{key.gsub(/\.|-/,"_")}=\"#{value.gsub("$","\\$")}\"\n")
      }
    }
  ' > /dev/null 2>&1
}
__rvm_ruby_config_save_mruby () 
{ 
    echo "target_cpu=\"$_system_arch\"" > "$1"
}
__rvm_ruby_package_file () 
{ 
    case "$1" in 
        *.tar.*)
            rvm_ruby_package_file="/$1"
        ;;
        rbx* | rubinius*)
            rvm_ruby_package_file="/${1//rbx/rubinius}.$(__rvm_remote_extension "$1" -)"
        ;;
        jruby-head)
            rvm_ruby_package_file="/jruby-head.$(__rvm_remote_extension "$1" -)"
        ;;
        jruby*)
            \typeset __version;
            __version="$(
        rvm_ruby_string="$1"
        rvm_remote_flag=0 __rvm_ruby_string
        echo "$rvm_ruby_version"
      )";
            rvm_ruby_package_file="/${__version}/jruby-bin-${__version}.$(__rvm_remote_extension "$1" -)"
        ;;
        "")
            rvm_ruby_package_file=""
        ;;
        ruby* | mruby*)
            rvm_ruby_package_file="/$1.$(__rvm_remote_extension "$1" -)"
        ;;
        *)
            rvm_ruby_package_file="/ruby-$1.$(__rvm_remote_extension "$1" -)"
        ;;
    esac
}
__rvm_ruby_string () 
{ 
    true ${rvm_head_flag:=0} ${rvm_delete_flag:=0};
    rvm_expanding_aliases='';
    true "${rvm_ruby_version:=}" "${rvm_gemset_name:=}" "${rvm_ruby_interpreter:=}" "${rvm_ruby_version:=}" "${rvm_ruby_tag:=}" "${rvm_ruby_patch_level:=}" "${rvm_ruby_revision:=}" ${rvm_gemset_separator:="@"} "${rvm_ruby_string:=}" ${rvm_expanding_aliases:=0} ${rvm_head_flag:=0};
    if [[ "$rvm_ruby_string" == *"${rvm_gemset_separator}"* ]]; then
        rvm_gemset_name="${rvm_ruby_string/*${rvm_gemset_separator}/}";
        rvm_ruby_string="${rvm_ruby_string/${rvm_gemset_separator}*/}";
    fi;
    if (( rvm_expanding_aliases == 0 )) && [[ -n "${rvm_ruby_string}" && "$rvm_ruby_string" != "system" ]]; then
        if [[ -f "$rvm_path/config/known_aliases" && -s "$rvm_path/config/known_aliases" ]] && expanded_alias_name="$(__rvm_db_ "$rvm_path/config/known_aliases" "$rvm_ruby_string")" && [[ -n "$expanded_alias_name" ]]; then
            rvm_ruby_string="$expanded_alias_name";
        fi;
    fi;
    if (( rvm_expanding_aliases == 0 )) && [[ -n "${rvm_ruby_string}" && "$rvm_ruby_string" != "system" ]]; then
        if [[ -f "$rvm_path/config/alias" && -s "$rvm_path/config/alias" ]] && expanded_alias_name="$(__rvm_db_ "$rvm_path/config/alias" "$rvm_ruby_string")" && [[ -n "$expanded_alias_name" ]]; then
            rvm_ruby_string="$expanded_alias_name";
        else
            if [[ "$rvm_ruby_string" == default ]]; then
                rvm_ruby_string="system";
            fi;
        fi;
        if [[ "$rvm_ruby_string" == *"${rvm_gemset_separator}"* ]]; then
            rvm_gemset_name="${rvm_ruby_string/*${rvm_gemset_separator}/}";
            rvm_ruby_string="${rvm_ruby_string/${rvm_gemset_separator}*/}";
        fi;
    fi;
    if [[ -n "$gemset_name" ]]; then
        rvm_gemset_name="$gemset_name";
        rvm_sticky_flag=1;
    fi;
    __rvm_ruby_string_parse || return $?;
    __rvm_ruby_string_find;
    detected_rvm_ruby_name="${rvm_ruby_name:-}";
    rvm_ruby_name="";
    true
}
__rvm_ruby_string_autodetect () 
{ 
    if [[ -z "${rvm_ruby_version:-}" && "${rvm_ruby_interpreter}" != "ext" && "${rvm_ruby_interpreter}" != "system" ]] && (( ${rvm_head_flag:=0} == 0 )); then
        if (( ${rvm_fuzzy_flag:-0} == 1 )); then
            rvm_ruby_version="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_interpreter}-.*${rvm_ruby_name:-}" |
        __rvm_awk -F- '{print $2}' |
        __rvm_version_sort |
        __rvm_tail -n 1
      )";
        fi;
        rvm_ruby_version="${rvm_ruby_version:-"$(
      __rvm_db "${rvm_ruby_interpreter}_version"
    )"}";
    fi;
    if (( ${rvm_head_flag:=0} )) && [[ "${rvm_ruby_interpreter}" == "ruby" ]] && __rvm_version_compare "${rvm_ruby_version}" -ge 2.1; then
        __rvm_take_n rvm_ruby_version 2 .;
    fi;
    rvm_ruby_string="${rvm_ruby_interpreter}${rvm_ruby_version:+-}${rvm_ruby_version:-}";
    if [[ "${rvm_ruby_interpreter}" == "ext" ]]; then
        true;
    else
        if [[ "${rvm_head_flag:=0}" == "1" || -n "${rvm_ruby_sha:-}" || -n "${rvm_ruby_tag:-}" ]]; then
            if [[ "${rvm_head_flag:=0}" == "1" ]]; then
                rvm_ruby_string="${rvm_ruby_string}-head";
            fi;
            if [[ -n "${rvm_ruby_sha:-}" ]]; then
                rvm_ruby_string="${rvm_ruby_string}-s${rvm_ruby_sha}";
            else
                if [[ -n "${rvm_ruby_tag:-}" ]]; then
                    rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_tag}";
                fi;
            fi;
            if [[ ! -d "${rvm_rubies_path}/${rvm_ruby_string}" ]] && (( ${rvm_fuzzy_flag:-0} == 1 )); then
                \typeset new_ruby_string;
                new_ruby_string="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_string}.*${rvm_ruby_name:-}" |
        __rvm_version_sort |
        __rvm_tail -n 1
      )";
                rvm_ruby_string="${new_ruby_string:-$rvm_ruby_string}";
            fi;
        else
            if [[ -n "${rvm_ruby_revision:-}" ]]; then
                rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_revision}";
            else
                if [[ -n "${rvm_ruby_patch_level:-}" ]]; then
                    rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_patch_level}";
                else
                    if [[ -n "${rvm_ruby_user_tag:-}" ]]; then
                        rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_user_tag}";
                    else
                        if (( ${rvm_fuzzy_flag:-0} == 1 )) && [[ "${rvm_ruby_interpreter}" == "ruby" || "${rvm_ruby_interpreter}" == "ree" ]]; then
                            rvm_ruby_patch_level="$(
        __rvm_list_strings |
        __rvm_grep "^${rvm_ruby_interpreter}-${rvm_ruby_version}-.*${rvm_ruby_name:-}" |
        __rvm_awk -F- '{print $3}' |
        __rvm_version_sort |
        __rvm_tail -n 1
      )";
                        fi;
                        [[ -n "${rvm_ruby_patch_level:-""}" ]] || __rvm_db_system "${rvm_ruby_interpreter}_${rvm_ruby_version}_patch_level" rvm_ruby_patch_level;
                        if [[ -n "${rvm_ruby_patch_level:-""}" ]]; then
                            rvm_ruby_string="${rvm_ruby_string}-${rvm_ruby_patch_level}";
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    true
}
__rvm_ruby_string_find () 
{ 
    if __rvm_ruby_string_installed; then
        true;
    else
        if __rvm_ruby_string_remotely_available; then
            true;
        else
            __rvm_ruby_string_autodetect;
            case "${rvm_ruby_string}" in 
                ruby-+([1-9]) | ruby-+([1-9]).+([0-9]) | ruby-1.+([1-9]).+([0-9]) | jruby-[19]*)
                    __rvm_ruby_string_latest && __rvm_ruby_string_parse_ || return $?
                ;;
            esac;
        fi;
    fi;
    if [[ -n "${rvm_ruby_name:-}" && ! "${rvm_ruby_string}" == *"-${rvm_ruby_name}" ]]; then
        rvm_ruby_string="${rvm_ruby_string}${rvm_ruby_name:+-}${rvm_ruby_name:-}";
    fi
}
__rvm_ruby_string_fuzzy () 
{ 
    \typeset new_ruby_string __search;
    __search="${rvm_ruby_string}";
    if [[ -n "${rvm_ruby_name:-}" ]]; then
        __search="${__search%${rvm_ruby_name:-}}.*${rvm_ruby_name:-}";
    fi;
    new_ruby_string="$(
    __rvm_list_strings |
    __rvm_grep "${__search//\./\\.}" |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    if [[ -n "${new_ruby_string}" ]]; then
        rvm_ruby_string="${new_ruby_string}";
    else
        return $?;
    fi
}
__rvm_ruby_string_fuzzy_remote () 
{ 
    \typeset new_ruby_string __search;
    __search="${rvm_ruby_string}";
    if [[ -n "${rvm_ruby_name:-}" ]]; then
        __search="${__search%${rvm_ruby_name:-}}.*${rvm_ruby_name:-}";
    fi;
    new_ruby_string="$(
    __list_remote_all |
    __rvm_awk -F/ '{ x=$NF;
      gsub(".tar.*","",x);
      gsub("jruby-bin","jruby",x);
      gsub("rubinius","rbx",x);
      print x}' |
    __rvm_version_sort |
    __rvm_awk '
BEGIN{found=""; any=""}
/^'"${__search}"'$/ {found=$1}
/^'"${__search}"'/ {any=$1}
END{if (found) print found; else if (any) print any;}
'
  )";
    rvm_ruby_string="${new_ruby_string:-$rvm_ruby_string}"
}
__rvm_ruby_string_installed () 
{ 
    \typeset __ruby_inst_dir="$rvm_rubies_path/${rvm_ruby_string}";
    if [[ -n "${rvm_ruby_name:-}" && ! "${rvm_ruby_string}" == *"-${rvm_ruby_name}" ]]; then
        __ruby_inst_dir="${__ruby_inst_dir}-${rvm_ruby_name}";
    fi;
    [[ -n "$rvm_ruby_interpreter" && -n "${rvm_ruby_string}" && -d "${__ruby_inst_dir}" ]] && [[ -z "${rvm_gemset_name}" || ${rvm_create_flag:-0} -eq 1 || -d "${__ruby_inst_dir}${rvm_gemset_separator}${rvm_gemset_name}" ]]
}
__rvm_ruby_string_latest () 
{ 
    \typeset check_ruby_string new_ruby_string;
    check_ruby_string="";
    if [[ -n "${rvm_ruby_interpreter}" ]]; then
        check_ruby_string+="${rvm_ruby_interpreter}-";
    fi;
    if [[ -n "${rvm_ruby_version}" ]]; then
        check_ruby_string+="${rvm_ruby_version//\./\.}.*";
    fi;
    if [[ -n "${rvm_ruby_patch_level}" ]]; then
        check_ruby_string+="${rvm_ruby_patch_level//\./\.}.*";
    fi;
    if [[ -z "${check_ruby_string}" ]]; then
        check_ruby_string="$rvm_ruby_string";
    fi;
    new_ruby_string="$(
    \command \cat "$rvm_path/config/known_strings" |
    __rvm_grep "${check_ruby_string}" |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    if [[ -n "${new_ruby_string}" ]]; then
        rvm_ruby_string="${new_ruby_string}";
    else
        rvm_error "Unknown ruby string (do not know how to handle): $rvm_ruby_string.";
        return 1;
    fi
}
__rvm_ruby_string_parse () 
{ 
    __rvm_ruby_string_parse_ || true;
    if (( ${rvm_fuzzy_flag:-0} == 1 )) && [[ ! -d "${rvm_rubies_path}/${rvm_ruby_string}" ]]; then
        if (( ${rvm_remote_flag:-0} == 1 )); then
            __rvm_ruby_string_fuzzy || __rvm_ruby_string_fuzzy_remote || return $?;
        else
            __rvm_ruby_string_fuzzy || true;
        fi;
    fi;
    __rvm_ruby_string_parse_ || return $?;
    if [[ -z "${rvm_ruby_interpreter}" ]]; then
        rvm_error "Unknown ruby interpreter version (do not know how to handle): $rvm_ruby_string.";
        return 1;
    fi
}
__rvm_ruby_string_parse_ () 
{ 
    \typeset ruby_string gemset_name expanded_alias_name repo_url branch_name ruby_name;
    ruby_string="${rvm_ruby_string:-}";
    gemset_name="${rvm_gemset_name:-}";
    repo_url="${rvm_ruby_repo_url:-}";
    branch_name="${rvm_ruby_repo_branch:-}";
    ruby_name="${rvm_ruby_name:-}";
    __rvm_unset_ruby_variables;
    rvm_ruby_repo_url="${repo_url:-}";
    rvm_ruby_repo_branch="${branch_name:-}";
    rvm_ruby_name="$ruby_name";
    export rvm_head_flag=0;
    if [[ -z "${ruby_string}" || "${ruby_string}" == "current" ]]; then
        if [[ "${GEM_HOME:-}" == *"${rvm_gems_path}"* ]]; then
            ruby_string="${GEM_HOME##*\/}";
            ruby_string="${ruby_string/%${rvm_gemset_separator:-"@"}*}";
        else
            ruby_string="system";
        fi;
    fi;
    strings=();
    __rvm_custom_separated_array strings - "${ruby_string}";
    rvm_ruby_string="${ruby_string}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        setopt LOCAL_OPTIONS KSH_GLOB;
    fi;
    for string in ${strings[@]};
    do
        case "$string" in 
            head)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="";
                rvm_ruby_tag="";
                rvm_head_flag=1
            ;;
            system)
                rvm_ruby_interpreter="system";
                rvm_ruby_patch_level="";
                rvm_ruby_tag="";
                rvm_ruby_revision="";
                rvm_ruby_version="";
                rvm_gemset_name="";
                rvm_head_flag=0;
                return 0
            ;;
            ext | external)
                rvm_ruby_interpreter="ext";
                rvm_ruby_patch_level="";
                rvm_ruby_tag="";
                rvm_ruby_revision="";
                rvm_ruby_version="";
                rvm_head_flag=0;
                rvm_ruby_name="${ruby_string:-${rvm_ruby_string}}";
                rvm_ruby_name="${rvm_ruby_name#*-}";
                break
            ;;
            nightly | weekly | monthly)
                case "${rvm_ruby_interpreter}" in 
                    rbx | rubinius)
                        rvm_ruby_patch_level="$string"
                    ;;
                    *)
                        rvm_ruby_version="$string"
                    ;;
                esac;
                rvm_nightly_flag=1
            ;;
            nightly* | weekly* | monthly*)
                case "${rvm_ruby_interpreter}" in 
                    rbx | rubinius)
                        rvm_ruby_patch_level="$string"
                    ;;
                    *)
                        rvm_ruby_version="$string"
                    ;;
                esac
            ;;
            preview*)
                rvm_ruby_patch_level="$string"
            ;;
            rc[0-9]*)
                rvm_ruby_patch_level="$string"
            ;;
            +([0-9]).+([0-9]).[0-9]*)
                rvm_ruby_version="${string}";
                rvm_ruby_revision="";
                rvm_ruby_tag=""
            ;;
            [0-9][0-9]*)
                case "${rvm_ruby_interpreter:-""}" in 
                    ree)
                        rvm_ruby_patch_level="$string";
                        rvm_ruby_revision=""
                    ;;
                    maglev)
                        rvm_ruby_version="$string";
                        rvm_ruby_revision="";
                        rvm_ruby_patch_level=""
                    ;;
                    *)
                        rvm_ruby_version="${string}";
                        rvm_ruby_revision="";
                        rvm_ruby_tag=""
                    ;;
                esac
            ;;
            [0-9]*)
                rvm_ruby_version="${string}";
                rvm_ruby_revision="";
                rvm_ruby_tag=""
            ;;
            p[0-9]*)
                rvm_ruby_patch_level="$string"
            ;;
            r[0-9]*)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="$string"
            ;;
            s[0-9a-zA-ZuU]*)
                rvm_ruby_revision="";
                rvm_ruby_sha="${string#s}"
            ;;
            tv[0-9]* | t[0-9]*)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="";
                rvm_ruby_tag="$string"
            ;;
            m[0-9]*)
                rvm_ruby_mode="$string"
            ;;
            u[0-9a-zA-ZuU]*)
                rvm_ruby_patch_level="";
                rvm_ruby_revision="";
                rvm_ruby_tag="";
                rvm_ruby_patch="";
                rvm_ruby_user_tag="$string"
            ;;
            b[0-9]*)
                rvm_ruby_repo_branch="${string}";
                rvm_head_flag=1
            ;;
            rubinius)
                rvm_ruby_interpreter="rbx"
            ;;
            opal | ruby | rbx | jruby | macruby | ree | maglev | ironruby | mruby | topaz)
                rvm_ruby_interpreter="$string"
            ;;
            [a-zA-ZuU]*([0-9a-zA-ZuU]|_))
                rvm_ruby_name="$string"
            ;;
            *)
                rvm_ruby_string="${ruby_string:-}";
                return 0
            ;;
        esac;
    done;
    if [[ -z "${rvm_ruby_interpreter}" && -n "${rvm_ruby_version}" ]]; then
        case "${rvm_ruby_version}" in 
            1.[5-7]* | 9*)
                rvm_ruby_interpreter=jruby
            ;;
            1.[8-9]* | 2*)
                rvm_ruby_interpreter=ruby
            ;;
        esac;
        if [[ -n "${rvm_ruby_interpreter}" ]]; then
            rvm_ruby_string="${rvm_ruby_interpreter}-${rvm_ruby_string}";
        fi;
    fi;
    true
}
__rvm_ruby_string_paths_under () 
{ 
    \typeset __search_path part parts IFS;
    IFS=" ";
    __search_path="${1%/}";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        parts=(${=rvm_ruby_string//-/ });
    else
        parts=(${rvm_ruby_string//-/ });
    fi;
    echo "$__search_path";
    for part in "${parts[@]}";
    do
        __search_path="$__search_path/$part";
        echo "$__search_path";
    done
}
__rvm_ruby_string_remotely_available () 
{ 
    (( ${rvm_remote_flag:-0} == 1 )) && [[ -n "$rvm_ruby_interpreter" && -n "${rvm_ruby_string}" ]] && __rvm_remote_server_path "${rvm_ruby_string}" > /dev/null
}
__rvm_ruby_strings_exist () 
{ 
    for rvm_ruby_string in ${@//,/ };
    do
        rvm_gemset_name="";
        rvm_verbose_flag=0 __rvm_use "${rvm_ruby_string}" > /dev/null 2>&1 || return $?;
        true rvm_gemset_name:${rvm_gemset_name:=${rvm_expected_gemset_name}};
        printf "%b" "${rvm_ruby_string}${rvm_gemset_name:+@}${rvm_gemset_name:-}\n";
    done;
    unset rvm_ruby_string
}
__rvm_rubygems_create_link () 
{ 
    \typeset ruby_lib_gem_path;
    \command \mkdir -p "$rvm_ruby_gem_home/bin";
    rubygems_detect_ruby_lib_gem_path "${1:-ruby}" || return 0;
    if [[ -L "$ruby_lib_gem_path" && -w "$ruby_lib_gem_path" ]]; then
        rm -rf "$ruby_lib_gem_path";
    fi;
    if [[ -e "$rvm_ruby_global_gems_path" && ! -L "$rvm_ruby_global_gems_path" ]]; then
        rm -rf "$rvm_ruby_global_gems_path";
    fi;
    [[ -d "$ruby_lib_gem_path" ]] || \command \mkdir -p "$ruby_lib_gem_path";
    if [[ -w "$ruby_lib_gem_path" ]]; then
        [[ -L "$rvm_ruby_global_gems_path" ]] || ln -fs "$ruby_lib_gem_path" "$rvm_ruby_global_gems_path";
    else
        [[ -d "$rvm_ruby_global_gems_path" ]] || \command \mkdir -p "$rvm_ruby_global_gems_path";
    fi;
    \command \mkdir -p "$rvm_ruby_global_gems_path/bin"
}
__rvm_run_wrapper () 
{ 
    ( file="$1";
    action="${2:-}";
    shift 2;
    rubies_string="${1:-}";
    args=($@);
    source "$rvm_scripts_path"/base;
    source "$rvm_scripts_path"/$file )
}
__rvm_rvmrc_key () 
{ 
    printf "%b" "$1" | \command \tr '[#/.=()]' _;
    return $?
}
__rvm_rvmrc_match_all () 
{ 
    [[ "${1:-}" == "all" || "${1:-}" == "all.rvmrcs" || "${1:-}" == "allGemfiles" ]]
}
__rvm_rvmrc_notice_display_post () 
{ 
    __rvm_table "Viewing of ${_rvmrc} complete."  <<-TEXT
Trusting an ${_rvmrc_base} file means that whenever you cd into this directory, RVM will run this ${_rvmrc_base} shell script.
Note that if the contents of the file change, you will be re-prompted to review the file and adjust its trust settings. You may also change the trust settings manually at any time with the 'rvm rvmrc' command.
TEXT

}
__rvm_rvmrc_notice_initial () 
{ 
    __rvm_table "NOTICE"  <<-TEXT
RVM has encountered a new or modified ${_rvmrc_base} file in the current directory, this is a shell script and therefore may contain any shell commands.

Examine the contents of this file carefully to be sure the contents are safe before trusting it!
Do you wish to trust '${_rvmrc}'?
Choose v[iew] below to view the contents
TEXT

}
__rvm_rvmrc_stored_trust () 
{ 
    [[ -f "$1" ]] || return 1;
    __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" || return $?
}
__rvm_rvmrc_stored_trust_check () 
{ 
    \typeset _first _second _rvmrc _rvmrc_base;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _first=1;
    else
        _first=0;
    fi;
    _second=$(( _first + 1 ));
    _rvmrc="${1}";
    _rvmrc_base="$(basename "${_rvmrc}")";
    if [[ -f "$_rvmrc" ]]; then
        saveIFS=$IFS;
        IFS=';';
        trust=($(__rvm_rvmrc_stored_trust "$_rvmrc"));
        IFS=$saveIFS;
        if [[ "${trust[${_second}]:-'#'}" != "$(__rvm_checksum_for_contents "$_rvmrc")" ]]; then
            echo "The '$_rvmrc' contains unreviewed changes.";
            return 1;
        else
            if [[ "${trust[${_first}]}" == '1' ]]; then
                echo "The '$_rvmrc' is currently trusted.";
                return 0;
            else
                if [[ "${trust[${_first}]}" == '0' ]]; then
                    echo "The '$_rvmrc' is currently untrusted.";
                    return 1;
                else
                    echo "The trustiworthiness of '$_rvmrc' is currently unknown.";
                    return 1;
                fi;
            fi;
        fi;
    else
        echo "There is no '$_rvmrc'";
        return 1;
    fi
}
__rvm_rvmrc_to () 
{ 
    case "${1:-help}" in 
        .ruby-version | ruby-version)
            __rvm_rvmrc_to_ruby_version || return $?
        ;;
        help)
            rvm_help rvmrc to;
            return 0
        ;;
        *)
            rvm_error_help "Unknown subcommand '$1'" rvmrc to;
            return 1
        ;;
    esac
}
__rvm_rvmrc_to_ruby_version () 
{ 
    ( [[ -s "$PWD/.rvmrc" ]] || { 
        rvm_error "No .rvmrc to convert";
        return 2
    };
    __rvm_load_project_config "$PWD/.rvmrc" || { 
        rvm_error "Could not load .rvmrc";
        return 3
    };
    __rvm_set_ruby_version;
    \command \rm .rvmrc || { 
        rvm_error "Could not remove .rvmrc";
        return 4
    } )
}
__rvm_rvmrc_tools () 
{ 
    \typeset rvmrc_action rvmrc_warning_action rvmrc_path saveIFS trust rvmrc_ruby;
    rvmrc_action="$1";
    (( $# )) && shift || true;
    if [[ "${rvmrc_action}" == "warning" ]]; then
        rvmrc_warning_action="${1:-}";
        (( $# )) && shift || true;
    fi;
    if [[ "${rvmrc_action}" == "create" ]]; then
        rvmrc_ruby="${1:-${GEM_HOME##*/}}";
        rvmrc_path="$(__rvm_cd "$PWD" >/dev/null 2>&1; pwd)/${2:-.rvmrc}";
    else
        if [[ "$1" == ".rvmrc" ]]; then
            rvmrc_path="$PWD/.rvmrc";
        else
            if [[ "${rvmrc_action}" == "to" || "${rvmrc_action}" == "warning" ]] || [[ -n "${1:-}" ]]; then
                rvmrc_path="$1";
            else
                rvmrc_path="$PWD/.rvmrc";
            fi;
        fi;
    fi;
    if [[ "${rvmrc_action}" == "to" || "${rvmrc_action}" == "warning" || "${rvmrc_action}" == "create" ]] || __rvm_rvmrc_match_all "${rvmrc_path:-}"; then
        true;
    else
        __rvm_project_dir_check "${rvmrc_path}" rvmrc_path "${rvmrc_path}/.rvmrc";
    fi;
    rvmrc_path="${rvmrc_path//\/\///}";
    rvmrc_path="${rvmrc_path%/}";
    case "$rvmrc_action" in 
        warning)
            __rvmrc_warning "${rvmrc_warning_action:-}" "$rvmrc_path" || return $?
        ;;
        to)
            __rvm_rvmrc_to "$rvmrc_path" || return $?
        ;;
        create)
            ( rvm_create_flag=1 __rvm_use "${rvmrc_ruby}";
            case "${rvmrc_path}" in 
                */.rvmrc | */--rvmrc)
                    __rvm_set_rvmrc
                ;;
                */.ruby-version | */--ruby-version)
                    __rvm_set_ruby_version
                ;;
                */.versions.conf | */--versions-conf)
                    __rvm_set_versions_conf
                ;;
                *)
                    rvm_error "Unrecognized project file format.";
                    return 1
                ;;
            esac )
        ;;
        reset)
            __rvm_reset_rvmrc_trust "$rvmrc_path" && rvm_log "Reset trust for $rvmrc_path" || rvm_error "Reset trust for $rvmrc_path - failed"
        ;;
        trust)
            __rvm_trust_rvmrc "$rvmrc_path" && rvm_log "Marked $rvmrc_path as trusted" || rvm_error "Marked $rvmrc_path as trusted - failed"
        ;;
        untrust)
            __rvm_untrust_rvmrc "$rvmrc_path" && rvm_log "Marked $rvmrc_path as untrusted" || rvm_error "Marked $rvmrc_path as untrusted - failed"
        ;;
        trusted)
            __rvm_rvmrc_stored_trust_check "$rvmrc_path" || return $?
        ;;
        is_trusted)
            __rvm_rvmrc_stored_trust_check "$rvmrc_path" > /dev/null
        ;;
        load)
            rvm_current_rvmrc="" rvm_trust_rvmrcs_flag=1 __rvm_project_rvmrc "${rvmrc_path%/.rvmrc}"
        ;;
        try_to_read_ruby)
            __rvm_rvmrc_tools_try_to_read_ruby "$@" || return $?
        ;;
        *)
            rvm_error "Usage: rvm rvmrc {trust,untrust,trusted,load,reset,is_trusted,try_to_read_ruby,create}";
            return 1
        ;;
    esac;
    return $?
}
__rvm_rvmrc_tools_read_ruby () 
{ 
    \typeset __result;
    \typeset -a rvmrc_tools_read_ruby;
    rvmrc_tools_read_ruby=();
    __rvm_save_variables rvmrc_tools_read_ruby rvm_current_rvmrc result current_result rvm_token next_token rvm_action _string;
    rvm_current_rvmrc="";
    rvm_action="${rvm_action:-use}" rvm_trust_rvmrcs_flag=1 __rvm_project_rvmrc "$rvmrc_path" > /dev/null && rvm_ruby_string="${GEM_HOME##*/}" && rvm_ruby_strings="$rvm_ruby_string" || __result=101;
    __rvm_set_env "" "${rvmrc_tools_read_ruby[@]}";
    return ${__result:-0}
}
__rvm_rvmrc_tools_try_to_read_ruby () 
{ 
    case "$rvmrc_path" in 
        */.rvmrc)
            if [[ -n "${rvm_trust_rvmrcs_flag:-}" ]]; then
                export rvm_trust_rvmrcs_flag;
            fi;
            rvmrc_path="$(cd "$(dirname "$rvmrc_path")"; pwd)/.rvmrc";
            __rvm_rvmrc_tools is_trusted "$(dirname "$rvmrc_path")" .rvmrc || ( rvm_promptless=1 __rvm_project_rvmrc "$rvmrc_path" > /dev/null 2>&1 );
            if __rvm_rvmrc_tools is_trusted "$(dirname "$rvmrc_path")" .rvmrc; then
                __rvm_rvmrc_tools_read_ruby "$@" || return $?;
            else
                return 1;
            fi
        ;;
        *)
            __rvm_rvmrc_tools_read_ruby "$@" || return $?
        ;;
    esac
}
__rvm_save_variables () 
{ 
    \typeset __save_to __key;
    __save_to="$1";
    shift;
    for __key in "$@";
    do
        eval "${__save_to}+=( \"\${__key}=\${${__key}}\" )";
    done
}
__rvm_sed () 
{ 
    \sed "$@" || return $?
}
__rvm_sed_i () 
{ 
    \typeset _filename _executable _user;
    [[ -n "${1:-}" ]] || { 
        rvm_debug "no file given for __rvm_sed_i";
        return 0
    };
    _filename="$1";
    shift;
    if [[ -x "${_filename}" ]]; then
        _executable=true;
    fi;
    _user="$( __rvm_statf "%u:%g" "%u:%g" "${_filename}" )";
    { 
        __rvm_sed "$@" < "${_filename}" > "${_filename}.new" && \command \mv -f "${_filename}.new" "${_filename}"
    } 2>&1 | rvm_debug_stream;
    if [[ -n "${_executable:-}" && ! -x "${_filename}" ]]; then
        chmod +x "${_filename}";
    fi;
    if [[ "$_user" != "$( __rvm_statf "%u:%g" "%u:%g" "${_filename}" )" ]]; then
        chown "$_user" "${_filename}";
    fi
}
__rvm_select () 
{ 
    true ${rvm_gemset_name:=};
    __rvm_select_set_variable_defaults && __rvm_select_detect_ruby_string "${1:-}" && __rvm_ruby_string && __rvm_select_after_parse || return $?
}
__rvm_select_after_parse () 
{ 
    __rvm_select_interpreter_variables && __rvm_select_version_variables && __rvm_select_default_variables || return $?;
    [[ "system" == "$rvm_ruby_interpreter" ]] || __rvm_gemset_select || return $result;
    rvm_ruby_selected_flag=1
}
__rvm_select_default_variables () 
{ 
    if [[ "${rvm_ruby_interpreter}" != ext ]]; then
        rvm_ruby_package_name="${rvm_ruby_package_name:-${rvm_ruby_string//-n*}}";
    fi;
    rvm_ruby_home="$rvm_rubies_path/$rvm_ruby_string";
    rvm_ruby_binary="$rvm_ruby_home/bin/ruby";
    rvm_ruby_irbrc="$rvm_ruby_home/.irbrc"
}
__rvm_select_detect_ruby_string () 
{ 
    rvm_ruby_string="${1:-${rvm_ruby_string:-${rvm_env_string:-}}}";
    if [[ -z "${rvm_ruby_string:-}" ]]; then
        rvm_ruby_string="${rvm_ruby_interpreter:-}";
        rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_version:+-}${rvm_ruby_version:-}";
        rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}";
        rvm_ruby_string="${rvm_ruby_string:-}${rvm_ruby_revision:+-}${rvm_ruby_revision:-}";
        if [[ -n "${rvm_ruby_name:-}" ]]; then
            rvm_ruby_name="$rvm_ruby_string-$rvm_ruby_name";
        fi;
    fi
}
__rvm_select_interpreter_common () 
{ 
    rvm_ruby_interpreter="${1}";
    rvm_ruby_version="head";
    rvm_ruby_patch_level="";
    export rvm_head_flag=1;
    rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "${1}_repo_url")}";
    rvm_ruby_url=$rvm_ruby_repo_url;
    rvm_ruby_configure="";
    rvm_ruby_make="";
    rvm_ruby_make_install=""
}
__rvm_select_interpreter_current () 
{ 
    ruby_binary="$(builtin command -v ruby)";
    if (( $? == 0)) && __rvm_string_match "$ruby_binary" "*rvm*"; then
        rvm_ruby_string="$(dirname "$ruby_binary" | __rvm_xargs dirname | __rvm_xargs basename)";
    else
        rvm_ruby_interpreter="system";
    fi
}
__rvm_select_interpreter_default () 
{ 
    true
}
__rvm_select_interpreter_ext () 
{ 
    if [[ -z "${rvm_ruby_name:-${detected_rvm_ruby_name:-}}" ]]; then
        rvm_error "External ruby name was not specified!";
        return 1;
    fi
}
__rvm_select_interpreter_ironruby () 
{ 
    rvm_ruby_patch_level="";
    if (( ${rvm_head_flag:=0} == 1 )); then
        rvm_ruby_version="head";
        rvm_ruby_package_name="${rvm_ruby_string}";
        rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "ironruby_repo_url")}";
        rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "ironruby_repo_url")}";
        rvm_disable_binary_flag=1;
    else
        rvm_archive_extension="zip";
        rvm_ruby_version=${rvm_ruby_version:-"$(__rvm_db "ironruby_version")"};
        rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}";
        rvm_ruby_package_file="${rvm_ruby_interpreter}-${rvm_ruby_version}.${rvm_archive_extension}";
        rvm_ruby_url="$(__rvm_db "ironruby_${rvm_ruby_version}_url")";
    fi;
    export rvm_ruby_version rvm_ruby_string rvm_ruby_package_name rvm_ruby_repo_url rvm_ruby_url rvm_archive_extension;
    true
}
__rvm_select_interpreter_jruby () 
{ 
    rvm_ruby_patch_level="";
    rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "jruby_repo_url")}";
    rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "jruby_repo_url")}";
    if (( ${rvm_head_flag:=0} == 1 )); then
        (( ${rvm_remote_flag:-0} == 1 )) || rvm_disable_binary_flag=1;
        rvm_ruby_version="head";
    else
        if (( ${rvm_18_flag:-0} || ${rvm_19_flag:-0} || ${rvm_20_flag:-0} || ${#rvm_patch_names[@]} )); then
            rvm_disable_binary_flag=1;
        fi;
        rvm_ruby_version="${rvm_ruby_version:-"$(__rvm_db "jruby_version")"}";
        rvm_ruby_tag="${rvm_ruby_tag:-${rvm_ruby_version}}";
    fi;
    alias jruby_ng="jruby --ng";
    alias jruby_ng_server="jruby --ng-server";
    true
}
__rvm_select_interpreter_macruby () 
{ 
    if [[ "Darwin" == "${_system_type}" ]]; then
        rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}";
        if (( ${rvm_head_flag:=0} == 1 )); then
            rvm_ruby_version="";
            rvm_ruby_tag="";
            rvm_ruby_revision="head";
            __rvm_db "macruby_repo_url" "rvm_ruby_repo_url";
            rvm_ruby_url="$rvm_ruby_repo_url";
            rvm_disable_binary_flag=1;
        else
            if [[ "${rvm_ruby_version:-}" == *"nightly"* ]]; then
                __rvm_select_macruby_nightly;
            else
                if [[ -n "${rvm_ruby_version:-}" ]]; then
                    __rvm_db "macruby_${rvm_ruby_version}_url" "rvm_ruby_url";
                    [[ -n "${rvm_ruby_url:-}" ]] || __rvm_db "macruby_url" "rvm_ruby_url";
                    rvm_ruby_package_name="MacRuby%20${rvm_ruby_version}.zip";
                    rvm_ruby_package_file="$rvm_ruby_package_name";
                    rvm_ruby_url="$rvm_ruby_url/$rvm_ruby_package_name";
                else
                    __rvm_db "macruby_version" "rvm_ruby_version";
                    __rvm_db "macruby_url" "rvm_ruby_url";
                    rvm_ruby_package_name="MacRuby%20${rvm_ruby_version}.zip";
                    rvm_ruby_package_file="$rvm_ruby_package_name";
                    rvm_ruby_url="$rvm_ruby_url/$rvm_ruby_package_name";
                fi;
            fi;
        fi;
        rvm_ruby_patch_level="";
    else
        rvm_error "MacRuby can only be installed on a Darwin OS.";
    fi;
    true
}
__rvm_select_interpreter_maglev () 
{ 
    rvm_ruby_patch_level="";
    maglev_url="$(__rvm_db "maglev_url")";
    system="${_system_type}";
    if [[ "$MACHTYPE" == x86_64-apple-darwin* ]]; then
        arch="i386";
    else
        arch="${_system_arch}";
    fi;
    if (( ${rvm_head_flag:=0} == 1 )) || [[ "$rvm_ruby_version" == "head" ]]; then
        rvm_head_flag=1;
        rvm_ruby_version="head";
        rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "maglev_repo_url")}";
        rvm_ruby_url="${rvm_ruby_repo_url:-$(__rvm_db "maglev_repo_url")}";
        rvm_gemstone_version=$(
      __rvm_curl -s https://raw.githubusercontent.com/MagLev/maglev/master/version.txt |
        __rvm_grep "^GEMSTONE" | cut -f2 -d-
    );
        rvm_gemstone_package_file="GemStone-${rvm_gemstone_version}.${system}-${arch}";
        rvm_disable_binary_flag=1;
    else
        rvm_ruby_package_file="MagLev-${rvm_ruby_version}";
        rvm_ruby_version="${rvm_ruby_version:-"$(__rvm_db "maglev_version")"}";
        rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}";
        rvm_ruby_url="${rvm_ruby_url:-"$maglev_url/${rvm_ruby_package_file}.${rvm_archive_extension}"}";
        rvm_gemstone_version=$(
      __rvm_curl -s https://raw.githubusercontent.com/MagLev/maglev/MagLev-${rvm_ruby_version}/version.txt |
        __rvm_grep "^GEMSTONE" | cut -f2 -d-
    );
        rvm_gemstone_package_file="GemStone-${rvm_gemstone_version}.${system}-${arch}";
    fi;
    export MAGLEV_HOME="$rvm_ruby_home";
    export GEMSTONE_GLOBAL_DIR=$MAGLEV_HOME;
    rvm_gemstone_url="$maglev_url/${rvm_gemstone_package_file}.${rvm_archive_extension}";
    true
}
__rvm_select_interpreter_missing () 
{ 
    return 2
}
__rvm_select_interpreter_mruby () 
{ 
    rvm_ruby_interpreter="mruby";
    rvm_ruby_patch_level="";
    rvm_ruby_repo_url="${rvm_ruby_repo_url:-$(__rvm_db "mruby_repo_url")}";
    rvm_ruby_url=$rvm_ruby_repo_url;
    rvm_ruby_configure="";
    rvm_ruby_make="";
    rvm_ruby_make_install="";
    export rvm_skip_autoreconf_flag=1;
    if [[ -z "${rvm_ruby_version:-}" ]]; then
        rvm_head_flag=1;
    else
        rvm_head_flag=0;
        rvm_archive_extension="tar.gz";
        rvm_ruby_package_file="${rvm_ruby_version}";
    fi
}
__rvm_select_interpreter_opal () 
{ 
    __rvm_select_interpreter_common "opal"
}
__rvm_select_interpreter_rbx () 
{ 
    __rvm_select_rbx_nightly || return $?;
    rvm_ruby_interpreter="rbx";
    __rvm_select_rbx_compatibility_branch;
    if (( ${rvm_head_flag:=1} == 0 )) && [[ -z "${rvm_ruby_repo_branch:-}" ]] && [[ "${rvm_ruby_version}" != "head" ]]; then
        if __rvm_version_compare "${rvm_ruby_version}" -ge "2.0.0"; then
            rbx_url="$( __rvm_db "rbx_2.0.0_url" )";
            rvm_archive_extension="tar.bz2";
            rvm_ruby_package_file="rubinius-${rvm_ruby_version}";
            rvm_ruby_url="${rbx_url}/${rvm_ruby_package_file}.${rvm_archive_extension}";
        else
            rbx_url=${rbx_url:-$(__rvm_db "rbx_url")};
            rvm_archive_extension="tar.gz";
            rvm_ruby_package_file="rubinius-${rvm_ruby_version}";
            rvm_ruby_url="${rbx_url}/$rvm_ruby_package_file.${rvm_archive_extension}";
        fi;
    else
        rvm_ruby_repo_url=${rvm_rbx_repo_url:-$(__rvm_db "rbx_repo_url")};
        rvm_head_flag=1;
        rvm_ruby_patch_level="";
        rvm_ruby_tag="${rvm_ruby_version:+v}${rvm_ruby_version:-}";
        rvm_ruby_version="head";
        rvm_disable_binary_flag=1;
    fi;
    if [[ -n "${rvm_rbx_opt:-}" ]]; then
        export RBXOPT="${RBXOPT:=${rvm_rbx_opt}}";
    fi;
    true
}
__rvm_select_interpreter_ree () 
{ 
    rvm_ruby_interpreter=ree;
    rvm_ruby_version=${rvm_ruby_version:-"$(__rvm_db "ree_version")"};
    case "$rvm_ruby_version" in 
        1.8.*)
            true
        ;;
        *)
            rvm_error "Unknown Ruby Enterprise Edition version: $rvm_ruby_version"
        ;;
    esac;
    if [[ -n "${rvm_ruby_patch_level:-0}" ]]; then
        rvm_ruby_patch_level="${rvm_ruby_patch_level#p}";
    fi;
    rvm_ruby_package_file="ruby-enterprise-$rvm_ruby_version-$rvm_ruby_patch_level";
    rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_${rvm_ruby_patch_level}_url")";
    rvm_ruby_url="${rvm_ruby_url:-$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_url")}";
    rvm_ruby_url="${rvm_ruby_url}/$rvm_ruby_package_file.tar.gz";
    true
}
__rvm_select_interpreter_rubinius () 
{ 
    __rvm_select_interpreter_rbx || return $?
}
__rvm_select_interpreter_ruby () 
{ 
    if [[ "${rvm_ruby_patch_level:-}" == "p0" ]] && __rvm_version_compare "${rvm_ruby_version}" -ge 2.1.0 && [[ ! -d "$rvm_rubies_path/$rvm_ruby_string" ]]; then
        rvm_ruby_patch_level="";
        rvm_ruby_string="${rvm_ruby_string%-p0}";
    fi;
    rvm_ruby_package_name="${rvm_ruby_interpreter}-${rvm_ruby_version}${rvm_ruby_patch_level:+-}${rvm_ruby_patch_level:-}";
    rvm_ruby_package_file="${rvm_ruby_package_name}";
    if [[ -z "${rvm_ruby_version:-""}" ]] && (( ${rvm_head_flag:=0} == 0 )); then
        rvm_error "Ruby version was not specified!";
    else
        rvm_ruby_repo_url="${rvm_ruby_repo_url:-"$(__rvm_db "ruby_repo_url")"}";
        if (( ${rvm_head_flag:=0} == 0 )); then
            if __rvm_version_compare "${rvm_ruby_version}" -lt "1.8.5"; then
                rvm_archive_extension="tar.gz";
            else
                rvm_archive_extension="tar.bz2";
            fi;
        else
            rvm_disable_binary_flag=1;
        fi;
    fi;
    true
}
__rvm_select_interpreter_system () 
{ 
    true
}
__rvm_select_interpreter_topaz () 
{ 
    __rvm_select_interpreter_common "topaz"
}
__rvm_select_interpreter_user () 
{ 
    true
}
__rvm_select_interpreter_variables () 
{ 
    rvm_archive_extension="tar.gz";
    if [[ -z "${rvm_ruby_interpreter:-}" ]]; then
        rvm_ruby_interpreter="${rvm_ruby_string//-*/}";
    fi;
    rvm_ruby_interpreter="${rvm_ruby_interpreter:-missing}";
    if is_a_function __rvm_select_interpreter_${rvm_ruby_interpreter}; then
        __rvm_select_interpreter_${rvm_ruby_interpreter} || return $?;
    else
        if [[ -n "${MY_RUBY_HOME:-""}" ]]; then
            __rvm_select "${MY_RUBY_HOME##*/}" || return $?;
        else
            if [[ -z "${rvm_ruby_string:-""}" ]]; then
                rvm_error "Ruby implementation '$rvm_ruby_interpreter' is not known.";
                return 1;
            fi;
        fi;
    fi
}
__rvm_select_late () 
{ 
    if is_a_function __rvm_select_late_${rvm_ruby_interpreter}; then
        __rvm_select_late_${rvm_ruby_interpreter};
    fi
}
__rvm_select_late_rbx () 
{ 
    if { 
        [[ -n "${rvm_ruby_package_file:-}" && -f "${rvm_archives_path}/${rvm_ruby_package_file}" && -s "${rvm_archives_path}/${rvm_ruby_package_file}" ]]
    } || { 
        [[ -n "${rvm_ruby_url:-}" ]] && file_exists_at_url "${rvm_ruby_url}"
    } || { 
        [[ -n "${rbx_url:-}" && -n "${rvm_ruby_version:-}" ]] && __rvm_select_late_rbx_partial "${rbx_url}" "${rvm_ruby_version}"
    }; then
        rvm_head_flag=0;
    else
        rvm_head_flag=1;
        if [[ "${rvm_ruby_version}" == 'head' ]]; then
            true ${rvm_ruby_repo_branch:="master"};
        else
            true ${rvm_ruby_repo_branch:="master"} ${rvm_ruby_tag:="${rvm_ruby_version}"};
        fi;
    fi
}
__rvm_select_late_rbx_partial () 
{ 
    \typeset __found __ext __patern;
    __ext=".${rvm_archive_extension}";
    __patern="${2//\./\.}.*\.${rvm_archive_extension//\./\.}\$";
    __found="$(
    __rvm_curl -s $1/index.txt "rubinius-" |
    __rvm_awk -F"${__ext}" "/${__patern}/"'{print $1}' |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    if [[ -n "${__found}" ]]; then
        rvm_ruby_version="${__found#rubinius-}";
        rvm_ruby_string="rbx-${rvm_ruby_version}";
        rvm_ruby_package_file="${__found}";
        rvm_ruby_url="$1/${__found}.${rvm_archive_extension}";
        return 0;
    else
        return 1;
    fi
}
__rvm_select_macruby_nightly () 
{ 
    __rvm_db "macruby_nightly_url" "rvm_ruby_url";
    case "${rvm_ruby_version:-}" in 
        nightly_*)
            __rvm_select_macruby_nightly_selected
        ;;
        *)
            __rvm_select_macruby_nightly_detect
        ;;
    esac;
    rvm_ruby_url+="/${rvm_ruby_package_file}";
    rvm_verify_downloads_flag=1;
    rvm_debug "selected macruby $rvm_ruby_string => $rvm_ruby_url";
    true
}
__rvm_select_macruby_nightly_detect () 
{ 
    \typeset __string_version;
    rvm_ruby_version="$(
    __rvm_curl -s "$rvm_ruby_url" |
    __rvm_grep -oE "<a href=\"macruby_nightly-[^<]+\.pkg</a>" |
    __rvm_awk -F"[<>]" '{print $3}' |
    __rvm_version_sort |
    __rvm_tail -n 1
  )";
    [[ -n "${rvm_ruby_version}" ]] || { 
        rvm_error "Could not find MacRuby nightly binary.";
        return 1
    };
    rvm_ruby_package_file="${rvm_ruby_version}";
    rvm_ruby_package_name="${rvm_ruby_package_file%.pkg}";
    __string_version="${rvm_ruby_package_name#macruby_nightly-}";
    __string_version="${__string_version//-/.}";
    rvm_ruby_version="nightly_${__string_version}";
    rvm_ruby_string="macruby-${rvm_ruby_version}${rvm_ruby_name:+-}${rvm_ruby_name:-}";
    true
}
__rvm_select_macruby_nightly_selected () 
{ 
    \typeset __string_version;
    __string_version="${rvm_ruby_version//./-}";
    __string_version="${__string_version#nightly_}";
    rvm_ruby_package_name="${rvm_ruby_interpreter}_nightly-${__string_version}";
    rvm_ruby_package_file="$rvm_ruby_package_name.pkg"
}
__rvm_select_rbx_compatibility_branch () 
{ 
    case "${rvm_ruby_version}" in 
        2.0pre)
            rvm_ruby_repo_branch="master"
        ;;
        2.0.testing)
            rvm_ruby_repo_branch="${rvm_ruby_version}"
        ;;
    esac;
    if [[ ${rvm_19_flag:-0} == 1 ]]; then
        rvm_ruby_repo_branch="1.9.3";
        rvm_head_flag=1;
    else
        if [[ ${rvm_18_flag:-0} == 1 ]]; then
            rvm_ruby_repo_branch="1.8.7";
            rvm_head_flag=1;
        fi;
    fi;
    true
}
__rvm_select_rbx_nightly () 
{ 
    (( ${rvm_nightly_flag:=0} == 1 )) || return 0;
    \typeset org_rvm_ruby_patch_level _rvm_ruby_name;
    if [[ "$rvm_ruby_version" == head ]]; then
        rvm_ruby_version="";
    fi;
    rvm_debug "searching for binary rbx ${rvm_ruby_version:-}${rvm_ruby_version:+-}${rvm_ruby_patch_level}*${rvm_ruby_name:+-}${rvm_ruby_name:-}";
    org_rvm_ruby_patch_level="$rvm_ruby_patch_level";
    _rvm_ruby_name="${rvm_ruby_name:-${detected_rvm_ruby_name:-}}";
    rvm_ruby_patch_level="$(
    __list_remote_all |
      __rvm_grep ${rvm_ruby_version:-}${rvm_ruby_version:+-}${org_rvm_ruby_patch_level}.*${_rvm_ruby_name:+-}${_rvm_ruby_name:-} |
      __rvm_tail -n 1
  )";
    [[ -n "${rvm_ruby_patch_level:-}" ]] || { 
        rvm_error "Could not find rbx binary '${rvm_ruby_version:-}${rvm_ruby_version:+-}${org_rvm_ruby_patch_level}*${rvm_ruby_name:+-}${rvm_ruby_name:-}' binary release.";
        return 1
    };
    rvm_ruby_patch_level="${rvm_ruby_patch_level##*/}";
    rvm_ruby_patch_level="${rvm_ruby_patch_level%.tar.*}";
    if [[ -z "${rvm_ruby_version:-}" ]]; then
        rvm_ruby_patch_level="${rvm_ruby_patch_level#rubinius-}";
        rvm_ruby_version="${rvm_ruby_patch_level%%-*}";
    fi;
    if [[ -z "${rvm_ruby_name:-}" ]]; then
        rvm_ruby_name="${rvm_ruby_patch_level##*-}";
    fi;
    rvm_ruby_patch_level="${rvm_ruby_patch_level##*${org_rvm_ruby_patch_level}}";
    rvm_ruby_patch_level="${rvm_ruby_patch_level%%-*}";
    rvm_ruby_patch_level="${org_rvm_ruby_patch_level}${rvm_ruby_patch_level}";
    rvm_ruby_string="rubinius-${rvm_ruby_version}-${rvm_ruby_patch_level}-${rvm_ruby_name}";
    rvm_debug "detected rbx ${rvm_ruby_string}";
    rvm_verify_downloads_flag=1;
    true
}
__rvm_select_set_variable_defaults () 
{ 
    export GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC;
    export rvm_env_string rvm_action rvm_alias_expanded rvm_archive_extension rvm_bin_flag rvm_bin_path rvm_debug_flag rvm_default_flag rvm_delete_flag rvm_docs_type rvm_dump_environment_flag rvm_error_message rvm_expanding_aliases rvm_file_name rvm_gemdir_flag rvm_gemset_name rvm_gemstone_package_file rvm_gemstone_url rvm_head_flag rvm_hook rvm_install_on_use_flag rvm_llvm_flag rvm_loaded_flag rvm_niceness rvm_nightly_flag rvm_only_path_flag rvm_parse_break rvm_patch_original_pwd rvm_pretty_print_flag rvm_proxy rvm_quiet_flag rvm_reload_flag rvm_remove_flag rvm_ruby_alias rvm_ruby_args rvm_ruby_binary rvm_ruby_bits rvm_ruby_configure rvm_ruby_file rvm_ruby_gem_home rvm_ruby_gem_path rvm_ruby_global_gems_path rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_major_version rvm_ruby_make rvm_ruby_make_install rvm_ruby_minor_version rvm_ruby_mode rvm_ruby_name rvm_ruby_package_file rvm_ruby_package_name rvm_ruby_patch rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_revision rvm_ruby_selected_flag rvm_ruby_sha rvm_ruby_string rvm_ruby_strings rvm_ruby_tag rvm_ruby_url rvm_ruby_user_tag rvm_ruby_version rvm_script_name rvm_sdk rvm_silent_flag rvm_sticky_flag rvm_system_flag rvm_token rvm_trace_flag rvm_use_flag rvm_user_flag rvm_verbose_flag rvm_wrapper_name
}
__rvm_select_version_variables () 
{ 
    case "$rvm_ruby_version" in 
        +([0-9]).+([0-9]).+([0-9]))
            rvm_ruby_release_version="${rvm_ruby_version/.*/}";
            rvm_ruby_major_version=${rvm_ruby_version%.*};
            rvm_ruby_major_version=${rvm_ruby_major_version#*.};
            rvm_ruby_minor_version="${rvm_ruby_version//*.}"
        ;;
        +([0-9]).+([0-9]))
            rvm_ruby_release_version="${rvm_ruby_version/.*/}";
            rvm_ruby_major_version="${rvm_ruby_version#*.}";
            rvm_ruby_minor_version=""
        ;;
    esac
}
__rvm_set_color () 
{ 
    \typeset __buffer __variable;
    __buffer='[';
    __variable="$1";
    shift;
    while (( $# )); do
        __rvm_set_color_single "$1";
        shift;
        if (( $# )); then
            __buffer+=';';
        fi;
    done;
    __buffer+='m';
    if [[ "${__variable}" == "" || "${__variable}" == "print" ]]; then
        printf "${__buffer}";
    else
        eval "${__variable}='${__buffer}'";
    fi
}
__rvm_set_color_single () 
{ 
    case "$1" in 
        bold)
            __buffer+='7'
        ;;
        offbold)
            __buffer+='27'
        ;;
        black)
            __buffer+='30'
        ;;
        red)
            __buffer+='31'
        ;;
        green)
            __buffer+='32'
        ;;
        yellow)
            __buffer+='33'
        ;;
        blue)
            __buffer+='34'
        ;;
        magenta)
            __buffer+='35'
        ;;
        cyan)
            __buffer+='36'
        ;;
        white)
            __buffer+='37'
        ;;
        default)
            __buffer+='39'
        ;;
        bblack)
            __buffer+='40'
        ;;
        bred)
            __buffer+='41'
        ;;
        bgreen)
            __buffer+='42'
        ;;
        byellow)
            __buffer+='43'
        ;;
        bblue)
            __buffer+='44'
        ;;
        bmagenta)
            __buffer+='45'
        ;;
        bcyan)
            __buffer+='46'
        ;;
        bwhite)
            __buffer+='47'
        ;;
        bdefault)
            __buffer+='49'
        ;;
        *)
            __buffer+='0'
        ;;
    esac
}
__rvm_set_env () 
{ 
    \typeset __save_to __set __key __value;
    __save_to="$1";
    shift;
    for __set in "$@";
    do
        __key="${__set%%=*}";
        __value="${__set#*=}";
        case "$__value" in 
            \"*\")
                __value="${__value#\"}";
                __value="${__value%\"}"
            ;;
            \'*\')
                __value="${__value#\'}";
                __value="${__value%\'}"
            ;;
        esac;
        rvm_debug "key=$__key; value=$__value;";
        if [[ -n "${__save_to}" ]]; then
            eval "${__save_to}+=( \"\${__key}=\${${__key}}\" )";
        fi;
        if [[ -n "${__value}" ]]; then
            eval "export \${__key}=\"\${__value}\"";
        else
            eval "unset \${__key}";
        fi;
    done
}
__rvm_set_executable () 
{ 
    for __file in "$@";
    do
        [[ -x "${__file}" ]] || chmod +x "${__file}";
    done
}
__rvm_set_ruby_version () 
{ 
    if [[ -s .ruby-version ]]; then
        \command \mv .ruby-version .ruby-version.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
        rvm_warn ".ruby-version is not empty, moving aside to preserve.";
    fi;
    \typeset __version="$(__rvm_env_string)";
    case "${__version}" in 
        *@*)
            if [[ -s .ruby-gemset ]]; then
                \command \mv .ruby-gemset .ruby-gemset.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
                rvm_warn ".ruby-gemset is not empty, moving aside to preserve.";
            fi;
            echo "${__version##*@}" > .ruby-gemset
        ;;
        *)
            if [[ -s .ruby-gemset ]]; then
                \command \mv .ruby-gemset .ruby-gemset.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
                rvm_warn ".ruby-gemset not needed, moving aside to preserve.";
            fi
        ;;
    esac;
    echo "${__version%@*}" > .ruby-version
}
__rvm_set_rvmrc () 
{ 
    \typeset flags identifier short_identifier gem_file;
    true ${rvm_verbose_flag:=0};
    if [[ "$HOME" != "$PWD" && "${rvm_prefix:-}" != "$PWD" ]]; then
        if (( rvm_verbose_flag )); then
            flags="use ";
        fi;
        if [[ -s .rvmrc ]]; then
            \command \mv .rvmrc .rvmrc.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
            rvm_warn ".rvmrc is not empty, moving aside to preserve.";
        fi;
        identifier=$(__rvm_env_string);
        short_identifier="${identifier#ruby-}";
        short_identifier="${short_identifier%%-*}";
        printf "%b" "#!/usr/bin/env bash

# This is an RVM Project .rvmrc file, used to automatically load the ruby
# development environment upon cd'ing into the directory

# First we specify our desired <ruby>[@<gemset>], the @gemset name is optional,
# Only full ruby name is supported here, for short names use:
#     echo \"rvm use ${short_identifier}\" > .rvmrc
environment_id=\"$identifier\"

# Uncomment the following lines if you want to verify rvm version per project
# rvmrc_rvm_version=\"${rvm_version}\" # 1.10.1 seems like a safe start
# eval \"\$(echo \${rvm_version}.\${rvmrc_rvm_version} | __rvm_awk -F. '{print \"[[ \"\$1*65536+\$2*256+\$3\" -ge \"\$4*65536+\$5*256+\$6\" ]]\"}' )\" || {
#   echo \"This .rvmrc file requires at least RVM \${rvmrc_rvm_version}, aborting loading.\"
#   return 1
# }
" >> .rvmrc;
        if __rvm_string_match "$identifier" "jruby*"; then
            printf "%b" "
# Uncomment following line if you want options to be set only for given project.
# PROJECT_JRUBY_OPTS=( --1.9 )
# The variable PROJECT_JRUBY_OPTS requires the following to be run in shell:
#    chmod +x \${rvm_path}/hooks/after_use_jruby_opts
" >> .rvmrc;
        fi;
        printf "%b" "
# First we attempt to load the desired environment directly from the environment
# file. This is very fast and efficient compared to running through the entire
# CLI and selector. If you want feedback on which environment was used then
# insert the word 'use' after --create as this triggers verbose mode.
if [[ -d \"\${rvm_path:-\$HOME/.rvm}/environments\"
  && -s \"\${rvm_path:-\$HOME/.rvm}/environments/\$environment_id\" ]]
then
  \\. \"\${rvm_path:-\$HOME/.rvm}/environments/\$environment_id\"
  for __hook in \"\${rvm_path:-\$HOME/.rvm}/hooks/after_use\"*
  do
    if [[ -f \"\${__hook}\" && -x \"\${__hook}\" && -s \"\${__hook}\" ]]
    then \\. \"\${__hook}\" || true
    fi
  done
  unset __hook
" >> .rvmrc;
        if [[ " $flags " == *" use "* ]]; then
            printf "%b" "  if (( \${rvm_use_flag:=1} >= 1 )) # display automatically" >> .rvmrc;
        else
            printf "%b" "  if (( \${rvm_use_flag:=1} >= 2 )) # display only when forced" >> .rvmrc;
        fi;
        printf "%b" "
  then
    if [[ \$- == *i* ]] # check for interactive shells
    then printf \"%b\" \"Using: \$(tput setaf 2 2>/dev/null)\$GEM_HOME\$(tput sgr0 2>/dev/null)\\\\n\" # show the user the ruby and gemset they are using in green
    else printf \"%b\" \"Using: \$GEM_HOME\\\\n\" # don't use colors in non-interactive shells
    fi
  fi
" >> .rvmrc;
        printf "%b" "else
  # If the environment file has not yet been created, use the RVM CLI to select.
  rvm --create $flags \"\$environment_id\" || {
    echo \"Failed to create RVM environment '\${environment_id}'.\"
    return 1
  }
fi
" >> .rvmrc;
        for gem_file in *.gems;
        do
            case "$gem_file" in 
                \*.gems)
                    continue
                ;;
            esac;
            printf "%b" "
# If you use an RVM gemset file to install a list of gems (*.gems), you can have
# it be automatically loaded. Uncomment the following and adjust the filename if
# necessary.
#
# filename=\".gems\"
# if [[ -s \"\$filename\" ]]
# then
#   rvm gemset import \"\$filename\" | GREP_OPTIONS=\"\" \\\\command \\grep -v already | GREP_OPTIONS=\"\" \command \grep -v listed | GREP_OPTIONS=\"\" \command \grep -v complete | \command \sed '/^$/d'
# fi
" >> .rvmrc;
        done;
        if [[ -s Gemfile ]]; then
            printf "%b" "
# If you use bundler, this might be useful to you:
# if [[ -s Gemfile ]] && {
#   ! builtin command -v bundle >/dev/null ||
#   builtin command -v bundle | GREP_OPTIONS=\"\" \\\\command \\grep \$rvm_path/bin/bundle >/dev/null
# }
# then
#   printf \"%b\" \"The rubygem 'bundler' is not installed. Installing it now.\\\\n\"
#   gem install bundler
# fi
# if [[ -s Gemfile ]] && builtin command -v bundle >/dev/null
# then
#   bundle install | GREP_OPTIONS=\"\" \\\\command \\grep -vE '^Using|Your bundle is complete'
# fi
" >> .rvmrc;
        fi;
    else
        rvm_error ".rvmrc cannot be set in your home directory.      \nThe home .rvmrc is for global rvm settings only.";
    fi
}
__rvm_set_versions_conf () 
{ 
    \typeset gemset identifier;
    if [[ -s .versions.conf ]]; then
        \command \mv .versions.conf .versions.conf.$(__rvm_date +%m.%d.%Y-%H:%M:%S);
        rvm_warn ".version.conf is not empty, moving aside to preserve.";
    fi;
    identifier=$(__rvm_env_string);
    gemset=${identifier#*@};
    identifier=${identifier%@*};
    printf "%b" "ruby=$identifier
" >> .versions.conf;
    if [[ -n "$gemset" && "$gemset" != "$identifier" ]]; then
        printf "%b" "ruby-gemset=$gemset
" >> .versions.conf;
    else
        printf "%b" "#ruby-gemset=my-projectit
" >> .versions.conf;
    fi;
    printf "%b" "#ruby-gem-install=bundler rake
#ruby-bundle-install=true
" >> .versions.conf
}
__rvm_setup () 
{ 
    __variables_definition export;
    if (( __rvm_env_loaded != 1 )); then
        return 0;
    fi;
    if [[ -n "${BASH_VERSION:-}" ]] && ! __function_on_stack cd pushd popd; then
        trap '__rvm_teardown_final ; set +x' EXIT HUP INT QUIT TERM;
    fi;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        export rvm_zsh_clobber rvm_zsh_nomatch;
        if setopt | __rvm_grep -s '^noclobber$' > /dev/null 2>&1; then
            rvm_zsh_clobber=0;
        else
            rvm_zsh_clobber=1;
        fi;
        setopt clobber;
        if setopt | __rvm_grep -s '^nonomatch$' > /dev/null 2>&1; then
            rvm_zsh_nomatch=0;
        else
            rvm_zsh_nomatch=1;
        fi;
        setopt no_nomatch;
    fi
}
__rvm_setup_statf_function () 
{ 
    if [[ "${_system_type}" == Darwin || "${_system_type}" == BSD ]]; then
        function __rvm_statf () 
        { 
            __rvm_stat -f "$2" "$3"
        };
    else
        function __rvm_statf () 
        { 
            __rvm_stat -c "$1" "$3"
        };
    fi
}
__rvm_setup_sudo_function () 
{ 
    if is_a_function __rvm_setup_sudo_function_${_system_name}; then
        __rvm_setup_sudo_function_${_system_name} "$@" || return $?;
    else
        __rvm_setup_sudo_function_Other "$@" || return $?;
    fi
}
__rvm_setup_sudo_function_Other () 
{ 
    if __rvm_which sudo > /dev/null 2>&1; then
        function __rvm_sudo () 
        { 
            \command \sudo "$@"
        };
    else
        rvm_debug "Warning: No 'sudo' found.";
    fi
}
__rvm_setup_sudo_function_PCLinuxOS () 
{ 
    exec 6>&2;
    function __rvm_sudo () 
    { 
        if [[ "$1" == "-p" ]]; then
            printf "${2//%p/[root]/}" 1>&6;
            shift 2;
        fi;
        su -c "$*"
    }
}
__rvm_setup_sudo_function_Solaris () 
{ 
    if [[ -x /opt/csw/bin/sudo ]]; then
        function __rvm_sudo () 
        { 
            /opt/csw/bin/sudo "$@"
        };
    else
        if [[ -x /usr/bin/sudo ]]; then
            function __rvm_sudo () 
            { 
                /usr/bin/sudo "$@"
            };
        else
            rvm_debug "Warning: No '/opt/csw/bin/sudo' found.";
        fi;
    fi
}
__rvm_setup_utils_functions () 
{ 
    \typeset gnu_tools_path gnu_prefix gnu_util;
    \typeset -a gnu_utils gnu_missing;
    gnu_utils=(awk cp date find sed tail tar xargs);
    gnu_missing=();
    if is_a_function __rvm_setup_utils_functions_${_system_name}; then
        __rvm_setup_utils_functions_${_system_name} "$@" || return $?;
    else
        __rvm_setup_utils_functions_Other "$@" || return $?;
    fi
}
__rvm_setup_utils_functions_OSX () 
{ 
    if [[ -x /usr/bin/stat ]]; then
        function __rvm_stat () 
        { 
            /usr/bin/stat "$@" || return $?
        };
    else
        rvm_error "ERROR: Missing (executable) /usr/bin/stat. Falling back to '\\\\command \\\\stat' which might be something else.";
        function __rvm_stat () 
        { 
            \command \stat "$@" || return $?
        };
    fi;
    __rvm_setup_utils_functions_common
}
__rvm_setup_utils_functions_Other () 
{ 
    function __rvm_stat () 
    { 
        \command \stat "$@" || return $?
    };
    __rvm_setup_utils_functions_common
}
__rvm_setup_utils_functions_Solaris () 
{ 
    case "${_system_version}" in 
        10)
            gnu_tools_path=/opt/csw/bin;
            gnu_prefix="g"
        ;;
        11)
            gnu_tools_path=/usr/gnu/bin;
            gnu_prefix=""
        ;;
    esac;
    if [[ -x $gnu_tools_path/${gnu_prefix}grep ]]; then
        eval "__rvm_grep() { GREP_OPTIONS=\"\" $gnu_tools_path/${gnu_prefix}grep \"\$@\" || return \$?; }";
    else
        gnu_missing+=(${gnu_prefix}grep);
    fi;
    if [[ "${_system_name}" == "OpenIndiana" || "${_system_version}" == "11" ]]; then
        function __rvm_stat () 
        { 
            \command \stat "$@" || return $?
        };
    else
        if [[ -x $gnu_tools_path/${gnu_prefix}stat ]]; then
            eval "__rvm_stat() { $gnu_tools_path/${gnu_prefix}stat \"\$@\" || return \$?; }";
        else
            gnu_missing+=(${gnu_prefix}stat);
        fi;
    fi;
    if [[ "${_system_name}" == "SmartOS" ]]; then
        function __rvm_which () 
        { 
            \command \which "$@" || return $?
        };
    else
        if [[ -x $gnu_tools_path/${gnu_prefix}which ]]; then
            eval "__rvm_which() { $gnu_tools_path/${gnu_prefix}which \"\$@\" || return \$?; }";
        else
            gnu_missing+=(${gnu_prefix}which);
        fi;
    fi;
    for gnu_util in "${gnu_utils[@]}";
    do
        if [[ -x $gnu_tools_path/$gnu_prefix$gnu_util ]]; then
            eval "__rvm_$gnu_util() { $gnu_tools_path/$gnu_prefix$gnu_util \"\$@\" || return \$?; }";
        else
            gnu_missing+=($gnu_prefix$gnu_util);
        fi;
    done;
    if (( ${#gnu_missing[@]} )); then
        rvm_error "ERROR: Missing GNU tools: ${gnu_missing[@]}. Make sure they are installed in '$gnu_tools_path/' before using RVM!";
        if [[ "${_system_name} ${_system_version}" == "Solaris 10" ]]; then
            rvm_error "You might want to look at OpenCSW project to install the above mentioned tools (https://www.opencsw.org/about)";
        fi;
        exit 200;
    fi
}
__rvm_setup_utils_functions_common () 
{ 
    function __rvm_grep () 
    { 
        GREP_OPTIONS="" \command \grep "$@" || return $?
    };
    if \command \which --skip-alias --skip-functions which > /dev/null 2>&1; then
        function __rvm_which () 
        { 
            \command \which --skip-alias --skip-functions "$@" || return $?
        };
    else
        if \command \which whence > /dev/null 2>&1 && \command \whence whence > /dev/null 2>&1; then
            function __rvm_which () 
            { 
                \command \whence -p "$@" || return $?
            };
        else
            if \command \which which > /dev/null 2>&1; then
                function __rvm_which () 
                { 
                    \command \which "$@" || return $?
                };
            else
                if \which which > /dev/null 2>&1; then
                    function __rvm_which () 
                    { 
                        \which "$@" || return $?
                    };
                else
                    \typeset __result=$?;
                    rvm_error "ERROR: Missing proper 'which' command. Make sure it is installed before using RVM!";
                    return ${__result};
                fi;
            fi;
        fi;
    fi;
    for gnu_util in "${gnu_utils[@]}";
    do
        eval "__rvm_$gnu_util() { \\$gnu_util \"\$@\" || return \$?; }";
    done
}
__rvm_sha256_for_contents () 
{ 
    if builtin command -v sha256sum > /dev/null; then
        sha256sum | __rvm_awk '{print $1}';
    else
        if builtin command -v sha256 > /dev/null; then
            sha256 | __rvm_awk '{print $1}';
        else
            if builtin command -v shasum > /dev/null; then
                shasum -a256 | __rvm_awk '{print $1}';
            else
                if builtin command -v openssl > /dev/null; then
                    openssl sha -sha256 | __rvm_awk '{print $1}';
                else
                    return 1;
                fi;
            fi;
        fi;
    fi;
    true
}
__rvm_sha__calculate () 
{ 
    \typeset bits _sum;
    bits=${1:-512};
    shift;
    if builtin command -v sha${bits}sum > /dev/null; then
        _sum=$(sha${bits}sum    "$@");
        echo ${_sum% *};
        return 0;
    else
        if builtin command -v sha${bits} > /dev/null; then
            _sum=$(sha${bits}       "$@");
            if [[ "${_sum%% *}" == "SHA${bits}" ]]; then
                echo ${_sum##* };
            else
                echo ${_sum% *};
            fi;
            return 0;
        else
            if builtin command -v shasum > /dev/null; then
                _sum=$(shasum -a${bits} "$@");
                echo ${_sum% *};
                return 0;
            else
                if builtin command -v /opt/csw/bin/shasum > /dev/null; then
                    _sum=$(/opt/csw/bin/shasum -a${bits} "$@");
                    echo ${_sum% *};
                    return 0;
                fi;
            fi;
        fi;
    fi;
    rvm_error "Neither sha512sum nor shasum found in the PATH";
    return 1
}
__rvm_stat () 
{ 
    \command \stat "$@" || return $?
}
__rvm_statf () 
{ 
    __rvm_stat -c "$1" "$3"
}
__rvm_string_includes () 
{ 
    \typeset __search __text="$1";
    shift;
    for __search in "$@";
    do
        if [[ " ${__text} " == *" ${__search} "* ]]; then
            return 0;
        fi;
    done;
    return 1
}
__rvm_string_match () 
{ 
    \typeset _string;
    _string="$1";
    shift;
    while (( $# )); do
        case "${_string}" in 
            ${1// /[[:space:]]})
                return 0
            ;;
        esac;
        shift;
    done;
    return 1
}
__rvm_strings () 
{ 
    \typeset strings ruby_strings;
    ruby_strings=($(echo ${rvm_ruby_args:-$rvm_ruby_string}));
    for rvm_ruby_string in "${ruby_strings[@]}";
    do
        strings="$strings $(__rvm_select ; echo $rvm_ruby_string)";
    done;
    echo $strings;
    return 0
}
__rvm_strip () 
{ 
    __rvm_sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/[[:space:]]\{1,\}/ /g';
    return $?
}
__rvm_sudo () 
{ 
    \command \sudo "$@"
}
__rvm_switch () 
{ 
    \typeset new_rvm_path new_rvm_bin_path;
    (( $# )) && [[ -z "$1" ]] && shift || true;
    (( $# )) && [[ -n "$1" ]] && [[ -d "$1" || -d "${1%/*}" ]] && [[ ! -f "$1" ]] || { 
        rvm_error "No valid path given.";
        return 1
    };
    [[ "${rvm_path}" != "${new_rvm_path}" ]] || { 
        rvm_warn "Already there!";
        return 2
    };
    rvm_log "Switching ${rvm_path} => ${1}";
    new_rvm_path="${1%/}";
    new_rvm_bin_path="${2:-$new_rvm_path/bin}";
    new_rvm_bin_path="${new_rvm_bin_path%/}";
    __rvm_use_system;
    __rvm_remove_from_path "${rvm_path%/}/*";
    rvm_reload_flag=1;
    rvm_path="${new_rvm_path}";
    rvm_bin_path="${new_rvm_bin_path}";
    rvm_scripts_path="${rvm_path}/scripts";
    rvm_environments_path="${rvm_path}/environments";
    __rvm_remove_from_path "${rvm_path%/}/*";
    __rvm_add_to_path prepend "${rvm_bin_path}"
}
__rvm_system_path () 
{ 
    rvm_remote_server_path="$(__rvm_db "rvm_remote_server_path${2:-}")";
    [[ -n "${rvm_remote_server_path}" ]] || rvm_remote_server_path="${_system_name_lowercase}/${_system_version}/${_system_arch}";
    if [[ "${1:-}" == "-" ]]; then
        printf "%b" "${rvm_remote_server_path}\n";
    fi
}
__rvm_table () 
{ 
    if [[ -n "${1:-}" ]]; then
        __rvm_table_br;
        echo "$1" | __rvm_table_wrap_text;
    fi;
    __rvm_table_br;
    \command \cat "${2:--}" | __rvm_table_wrap_text;
    __rvm_table_br
}
__rvm_table_br () 
{ 
    \typeset width=${COLUMNS:-78};
    width=$(( width > 116 ? 116 : width ));
    printf "%-${width}s\n" " " | __rvm_sed 's/ /*/g'
}
__rvm_table_wrap_text () 
{ 
    \typeset width=${COLUMNS:-78};
    width=$(( width > 116 ? 116 : width ));
    width=$(( width - 4 ));
    __rvm_fold $width | __rvm_awk -v width=$width '{printf "* %-"width"s *\n", $0}'
}
__rvm_tail () 
{ 
    \tail "$@" || return $?
}
__rvm_take_n () 
{ 
    \typeset IFS __temp_counter;
    \typeset -a __temp_arr1 __temp_arr2;
    IFS=$3;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        eval "__temp_arr1=( \${=$1} )";
    else
        eval "__temp_arr1=( \$$1 )";
    fi;
    __temp_counter=0;
    __temp_arr2=();
    while (( __temp_counter < $2 )); do
        __temp_arr2+=("${__temp_arr1[__array_start+__temp_counter++]}");
    done;
    eval "$1=\"\${__temp_arr2[*]}\""
}
__rvm_tar () 
{ 
    \tar "$@" || return $?
}
__rvm_teardown () 
{ 
    if builtin command -v __rvm_cleanup_tmp > /dev/null 2>&1; then
        __rvm_cleanup_tmp;
    fi;
    export __rvm_env_loaded;
    : __rvm_env_loaded:${__rvm_env_loaded:=${rvm_tmp_path:+1}}:;
    : __rvm_env_loaded:${__rvm_env_loaded:=0}:;
    : __rvm_env_loaded:$(( __rvm_env_loaded-=1 )):;
    if [[ -z "${rvm_tmp_path:-}" ]] || (( __rvm_env_loaded > 0 )); then
        return 0;
    fi;
    if [[ -n "${BASH_VERSION:-}" ]]; then
        trap - EXIT HUP INT QUIT TERM;
        if is_a_function shell_session_update; then
            trap 'shell_session_update' EXIT;
        fi;
    fi;
    if [[ -n "${ZSH_VERSION:-""}" ]]; then
        (( rvm_zsh_clobber == 0 )) && setopt noclobber;
        (( rvm_zsh_nomatch == 0 )) || setopt nomatch;
        unset rvm_zsh_clobber rvm_zsh_nomatch;
    fi;
    if [[ -n "${rvm_stored_umask:-}" ]]; then
        umask ${rvm_stored_umask};
        unset rvm_stored_umask;
    fi;
    if builtin command -v __rvm_cleanup_download > /dev/null 2>&1; then
        __rvm_cleanup_download;
    fi;
    if [[ "${rvm_stored_errexit:-""}" == "1" ]]; then
        set -e;
    fi;
    __variables_definition unset;
    return 0
}
__rvm_teardown_final () 
{ 
    __rvm_env_loaded=1;
    unset __rvm_project_rvmrc_lock;
    __rvm_teardown
}
__rvm_teardown_if_broken () 
{ 
    if __function_on_stack __rvm_load_project_config || __function_on_stack __rvm_with; then
        true;
    else
        if (( ${__rvm_env_loaded:-0} > 0 )); then
            __rvm_teardown_final;
        fi;
    fi
}
__rvm_trust_rvmrc () 
{ 
    [[ -f "$1" ]] || return 1;
    __rvm_reset_rvmrc_trust "$1";
    __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "1;$(__rvm_checksum_for_contents "$1")" > /dev/null 2>&1 || return $?
}
__rvm_try_sudo () 
{ 
    ( \typeset -a command_to_run;
    \typeset sudo_path sbin_path missing_paths;
    command_to_run=("$@");
    (( UID == 0 )) || case "$rvm_autolibs_flag_number" in 
        0)
            rvm_debug "Running '$*' would require sudo.";
            return 0
        ;;
        1)
            rvm_warn "Running '$*' would require sudo.";
            return 0
        ;;
        2)
            rvm_requiremnts_fail error "Running '$*' would require sudo.";
            return 1
        ;;
        *)
            if is_a_function __rvm_sudo; then
                missing_paths="";
                for sbin_path in /sbin /usr/sbin /usr/local/sbin;
                do
                    if [[ -d "${sbin_path}" ]] && [[ ":$PATH:" != *":${sbin_path}:"* ]]; then
                        missing_paths+=":${sbin_path}";
                    fi;
                done;
                if [[ -n "${missing_paths}" ]]; then
                    command_to_run=(/usr/bin/env PATH="${PATH}${missing_paths}" "${command_to_run[@]}");
                fi;
                command_to_run=(__rvm_sudo -p "%p password required for '$*': " "${command_to_run[@]}");
            else
                rvm_error "Running '$*' would require sudo, but 'sudo' is not found!";
                return 1;
            fi
        ;;
    esac;
    "${command_to_run[@]}" || return $? )
}
__rvm_unload () 
{ 
    \typeset _element;
    \typeset -a _list;
    __rvm_remove_rvm_from_path;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        __rvm_remove_from_array fpath "$rvm_path/scripts/extras/completion.zsh" "${fpath[@]}";
    fi;
    __rvm_unload_action unalias <<< "$(
    if [[ -n "${ZSH_VERSION:-}" ]]
    then alias | __rvm_awk -F"=" '/rvm/ {print $1}'
    else alias | __rvm_awk -F"[= ]" '/rvm/ {print $2}'
    fi
  )";
    __rvm_unload_action unset <<< "$(
    set |
      __rvm_awk -F"=" 'BEGIN{v=0;} /^[a-zA-Z_][a-zA-Z0-9_]*=/{v=1;} v==1&&$2~/^['\''\$]/{v=2;}
        v==1&&$2~/^\(/{v=3;} v==2&&/'\''$/&&!/'\'\''$/{v=1;} v==3&&/\)$/{v=1;} v{print;} v==1{v=0;}' |
      __rvm_awk -F"=" '/^[^ ]*(RUBY|GEM|IRB|gem|rubies|rvm)[^ ]*=/ {print $1} /^[^ ]*=.*rvm/ {print $1}' |
      __rvm_grep -vE "^PROMPT|^prompt|^PS|^BASH_SOURCE|^PATH"
  )";
    __rvm_unload_action __function_unset <<< "$(
    \typeset -f | __rvm_awk '$2=="()" {fun=$1} /rvm/{print fun}' | sort -u | __rvm_grep -v __rvm_unload_action
  )";
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        unset -f __rvm_unload_action;
        unset -f __function_unset;
        if [[ -n "${_comp_dumpfile:-}" ]]; then
            \command \rm -f "$_comp_dumpfile";
            compinit -d "$_comp_dumpfile";
        fi;
    else
        unset __rvm_unload_action __function_unset;
    fi
}
__rvm_unload_action () 
{ 
    \typeset _element IFS;
    \typeset -a _list;
    IFS='
';
    _list=($( \command \cat ${2:--} | sort -u ));
    for _element in "${_list[@]}";
    do
        $1 "${_element}";
    done
}
__rvm_unset_exports () 
{ 
    \typeset wrap_name name value;
    \typeset -a __variables_list;
    __rvm_read_lines __variables_list <<< "$(
    printenv | __rvm_sed '/^rvm_old_.*=/ { s/=.*$//; p; }; d;'
  )";
    for wrap_name in "${__variables_list[@]}";
    do
        eval "value=\"\${${wrap_name}}\"";
        name=${wrap_name#rvm_old_};
        if [[ -n "${value:-}" ]]; then
            export $name="${value}";
        else
            unset $name;
        fi;
        unset $wrap_name;
    done
}
__rvm_unset_ruby_variables () 
{ 
    unset rvm_env_string rvm_ruby_string rvm_ruby_strings rvm_ruby_binary rvm_ruby_gem_home rvm_ruby_gem_path rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_log_path rvm_ruby_major_version rvm_ruby_minor_version rvm_ruby_package_name rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_repo_branch rvm_ruby_revision rvm_ruby_selected_flag rvm_ruby_tag rvm_ruby_version rvm_head_flag rvm_ruby_package_file rvm_ruby_configure rvm_ruby_name rvm_ruby_url rvm_ruby_global_gems_path rvm_ruby_args rvm_ruby_name rvm_llvm_flag;
    __rvm_load_rvmrc
}
__rvm_untrust_rvmrc () 
{ 
    [[ -f "$1" ]] || return 1;
    __rvm_reset_rvmrc_trust "$1";
    __rvm_db_ "${rvm_user_path:-${rvm_path}/user}/rvmrcs" "$(__rvm_rvmrc_key "$1")" "0;$(__rvm_checksum_for_contents "$1")" > /dev/null 2>&1 || return $?
}
__rvm_use () 
{ 
    \typeset binary full_binary_path rvm_ruby_gem_home __path_prefix __path_suffix;
    __rvm_select "$@" || return $?;
    if [[ "system" == ${rvm_ruby_interpreter:="system"} ]]; then
        __rvm_use_system;
    else
        __rvm_use_ || return $?;
    fi;
    __rvm_use_common
}
__rvm_use_ () 
{ 
    rvm_ruby_home="${rvm_ruby_home%%@*}";
    if [[ ! -d "$rvm_ruby_home" ]]; then
        if [[ ${rvm_install_on_use_flag:-0} -eq 1 ]]; then
            rvm_warn "$rvm_ruby_string is not installed - installing.";
            __rvm_run_wrapper manage "install" "$rvm_ruby_string";
        else
            rvm_error "$rvm_ruby_string is not installed.";
            rvm_log "To install do: 'rvm install $rvm_ruby_string'";
            export rvm_recommended_ruby="rvm install $rvm_ruby_string";
            return 1;
        fi;
    fi;
    __rvm_gemset_use_ensure || return $?;
    export GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC;
    GEM_HOME="$rvm_ruby_gem_home";
    GEM_PATH="$rvm_ruby_gem_path";
    MY_RUBY_HOME="$rvm_ruby_home";
    RUBY_VERSION="$rvm_ruby_string";
    IRBRC="$rvm_ruby_irbrc";
    unset BUNDLE_PATH;
    if [[ "maglev" == "$rvm_ruby_interpreter" ]]; then
        GEM_PATH="$GEM_PATH:$MAGLEV_HOME/lib/maglev/gems/1.8/";
    fi;
    [[ -n "${IRBRC:-}" ]] || unset IRBRC;
    if (( ${rvm_use_flag:-1} >= 2 && ${rvm_internal_use_flag:-0} == 0 )) || (( ${rvm_use_flag:-1} == 1 && ${rvm_verbose_flag:-0} == 1 )); then
        rvm_log "Using ${GEM_HOME/${rvm_gemset_separator:-'@'}/ with gemset }";
    fi;
    if [[ "$GEM_HOME" != "$rvm_ruby_global_gems_path" ]]; then
        __path_prefix="$GEM_HOME/bin:$rvm_ruby_global_gems_path/bin:${rvm_ruby_binary%/*}:${rvm_bin_path}";
    else
        __path_prefix="$GEM_HOME/bin:${rvm_ruby_binary%/*}:${rvm_bin_path}";
    fi;
    __path_suffix=""
}
__rvm_use_common () 
{ 
    [[ -z "${rvm_ruby_string:-}" ]] || export rvm_ruby_string;
    [[ -z "${rvm_gemset_name:-}" ]] || export rvm_gemset_name;
    \typeset __save_PATH;
    __rvm_remove_rvm_from_path;
    __save_PATH=$PATH;
    if [[ -n "${_OLD_VIRTUAL_PATH}" ]]; then
        PATH="${_OLD_VIRTUAL_PATH}";
        __rvm_remove_rvm_from_path;
        _OLD_VIRTUAL_PATH="${__path_prefix:-}${__path_prefix:+:}${PATH}${__path_suffix:+:}${__path_suffix:-}";
    fi;
    PATH="${__path_prefix:-}${__path_prefix:+:}$__save_PATH${__path_suffix:+:}${__path_suffix:-}";
    export PATH;
    builtin hash -r;
    if [[ "$rvm_ruby_string" != "system" ]]; then
        case "${rvm_rvmrc_flag:-0}" in 
            rvmrc | versions_conf | ruby_version)
                __rvm_set_${rvm_rvmrc_flag}
            ;;
        esac;
        \typeset environment_id;
        environment_id="$(__rvm_env_string)";
        if (( ${rvm_default_flag:=0} == 1 )) && [[ "default" != "${rvm_ruby_interpreter:-}" ]] && [[ "system" != "${rvm_ruby_interpreter:-}" ]]; then
            "$rvm_scripts_path/alias" delete default &> /dev/null;
            "$rvm_scripts_path/alias" create default "$environment_id" &> /dev/null;
        fi;
        rvm_default_flag=0;
        if [[ -n "${rvm_ruby_alias:-}" ]]; then
            rvm_log "Attempting to alias $environment_id to $rvm_ruby_alias";
            "$rvm_scripts_path/alias" delete "$rvm_ruby_alias" > /dev/null 2>&1;
            rvm_alias_expanded=1 "$rvm_scripts_path/alias" create "$rvm_ruby_alias" "$environment_id" > /dev/null 2>&1;
            ruby_alias="";
            rvm_ruby_alias="";
        fi;
    else
        if (( ${rvm_default_flag:=0} == 1 )); then
            builtin command -v __rvm_reset >> /dev/null 2>&1 || source "$rvm_scripts_path/functions/reset";
            __rvm_reset;
        fi;
    fi;
    rvm_hook="after_use";
    source "$rvm_scripts_path/hook";
    return 0
}
__rvm_use_ruby_warnings () 
{ 
    if [[ "${rvm_ruby_string}" == "system" || "${rvm_ruby_string}" == "" ]]; then
        return 0;
    fi;
    \typeset __executable __gem_version;
    for __executable in ruby gem irb;
    do
        [[ -x "$MY_RUBY_HOME/bin/${__executable}" ]] || rvm_warn "Warning! Executable '${__executable}' missing, something went wrong with this ruby installation!";
    done;
    if [[ "${rvm_ruby_interpreter}" == "ruby" ]] && { 
        __rvm_version_compare "${rvm_ruby_version}" -ge 2.0.0 || [[ "${rvm_ruby_version}" == "head" ]]
    } && __rvm_which gem > /dev/null && __gem_version="$(RUBYGEMS_GEMDEPS= gem --version)" && [[ -n "${__gem_version}" ]] && __rvm_version_compare "${__gem_version}" -lt "2.0.0"; then
        rvm_warn "Warning! You have just used ruby 2.0.0 or newer, which is not fully compatible with rubygems 1.8.x or older,
         consider upgrading rubygems with: 'rvm rubygems latest'.";
    fi
}
__rvm_use_system () 
{ 
    unset GEM_HOME GEM_PATH MY_RUBY_HOME RUBY_VERSION IRBRC;
    if [[ -s "$rvm_path/config/system" ]]; then
        if __rvm_grep "MY_RUBY_HOME='$rvm_rubies_path" "$rvm_path/config/system" > /dev/null; then
            if [[ -f "$rvm_path/config/system" ]]; then
                \command \rm -f "$rvm_path/config/system";
            fi;
        else
            source "$rvm_path/config/system";
        fi;
    fi;
    if (( ${rvm_default_flag:=0} == 1 )); then
        "$rvm_scripts_path/alias" delete default &> /dev/null;
        __rvm_find "${rvm_bin_path}" -maxdepth 0 -name 'default_*' -exec rm '{}' \;;
        \command \rm -f "$rvm_path/config/default";
        \command \rm -f "$rvm_environments_path/default";
        __rvm_rm_rf "$rvm_wrappers_path/default";
    fi;
    rvm_verbose_log "Now using system ruby.";
    __path_prefix="";
    __path_suffix="${rvm_bin_path}";
    export rvm_ruby_string="system"
}
__rvm_using_gemset_globalcache () 
{ 
    __rvm_db_ "$rvm_user_path/db" "use_gemset_globalcache" | __rvm_grep '^true$' > /dev/null 2>&1;
    return $?
}
__rvm_version () 
{ 
    __rvm_meta;
    \typeset IFS release;
    IFS=':';
    rvm_meta_authors="${rvm_meta_authors[*]}";
    rvm_meta_authors="${rvm_meta_authors//:/, }";
    echo "rvm ${rvm_meta_version} by ${rvm_meta_authors} [${rvm_meta_website}]"
}
__rvm_version_compare () 
{ 
    \typeset first;
    first="$( \command \printf "%b" "$1\n$3\n" | __rvm_version_sort | \command \head -n1 )";
    case "$2" in 
        -eq | == | =)
            [[ "$1" == "$3" ]] || return $?
        ;;
        -ne | !=)
            [[ "$1" != "$3" ]] || return $?
        ;;
        -gt | \>)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$1" && "$1" != "$3" ]] || return $?;
            else
                [[ "$first" == "$3" && "$1" != "$3" ]] || return $?;
            fi
        ;;
        -ge | \>=)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$1" || "$1" == "$3" ]] || return $?;
            else
                [[ "$first" == "$3" || "$1" == "$3" ]] || return $?;
            fi
        ;;
        -lt | \<)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$3" && "$1" != "$3" ]] || return $?;
            else
                [[ "$first" == "$1" && "$1" != "$3" ]] || return $?;
            fi
        ;;
        -le | \<=)
            if [[ "$first" == "head" ]]; then
                [[ "$first" == "$3" || "$1" == "$3" ]] || return $?;
            else
                [[ "$first" == "$1" || "$1" == "$3" ]] || return $?;
            fi
        ;;
        *)
            rvm_error "Unsupported operator '$2'.";
            return 1
        ;;
    esac;
    return 0
}
__rvm_version_sort () 
{ 
    \command \awk -F'[.-]' -v OFS=. '{       # split on "." and "-", merge back with "."
    original=$0                            # save original to preserve it before the line is changed
    for (n=1; n<10; n++) {                 # iterate through max 9 components of version
      $n=tolower($n)                       # ignore case for sorting
      if ($n=="")         $n="0"           # treat non existing parts as 0
      if ($n ~ /^p[0-9]/) $n=substr($n, 2) # old ruby -p notation
      if ($n ~ /^[a-z]/)  $n=" "$n         # names go before numbers thanks to space
    }
    print $0"\t"original                   # print the transformed version and original separated by \t so we can extract original after sorting
  }' | LC_ALL=C \sort -t. -k 1,1d -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n | \awk -F'\t' '{print $2}'
}
__rvm_wait_anykey () 
{ 
    if [[ -n "${1:-}" ]]; then
        echo "$1";
    fi;
    \typeset _read_char_flag;
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        _read_char_flag=k;
    else
        _read_char_flag=n;
    fi;
    builtin read -${_read_char_flag} 1 -s -r anykey
}
__rvm_which () 
{ 
    \command \which "$@" || return $?
}
__rvm_with () 
{ 
    ( unset rvm_rvmrc_flag;
    export rvm_create_flag=1;
    export rvm_delete_flag=0;
    export rvm_internal_use_flag=1;
    export rvm_use_flag=0;
    __rvm_use "$1" || return $?;
    shift;
    "$@" || return $? )
}
__rvm_xargs () 
{ 
    \xargs "$@" || return $?
}
__rvmrc_full_path_to_file () 
{ 
    if [[ "$1" == "all.rvmrcs" || "$1" == "allGemfiles" ]]; then
        __rvmrc_warning_file="$1";
    else
        if [[ -d "$1" && -s "$1/.rvmrc" ]]; then
            __rvmrc_warning_file="$( __rvm_cd "$1" >/dev/null 2>&1; pwd )/.rvmrc";
        else
            if [[ -d "$1" && -s "$1/Gemfile" ]]; then
                __rvmrc_warning_file="$( __rvm_cd "$1" >/dev/null 2>&1; pwd )/Gemfile";
            else
                if [[ -f "$1" || "$1" == *".rvmrc" || "$1" == *"Gemfile" ]]; then
                    __rvmrc_warning_file="$( dirname "$1" )";
                    : __rvmrc_warning_file:${__rvmrc_warning_file:=$PWD};
                    __rvmrc_warning_file="${__rvmrc_warning_file}/${1##*/}";
                else
                    rvm_warn "Do not know how to handle '$1', please report: https://bit.ly/rvm-issues ~ __rvmrc_full_path_to_file" 1>&2;
                    return 1;
                fi;
            fi;
        fi;
    fi
}
__rvmrc_warning () 
{ 
    \typeset __rvmrc_warning_path __rvmrc_warning_file;
    __rvmrc_warning_path="$rvm_user_path/rvmrc_ignored";
    case "${1:-help}" in 
        list)
            __rvmrc_warning_$1 "${2:-}" || return $?
        ;;
        check | check_quiet | ignore | reset)
            __rvmrc_full_path_to_file "${2:-}" && __rvmrc_warning_$1 "${__rvmrc_warning_file:-${2:-}}" || return $?
        ;;
        help)
            rvm_help rvmrc warning
        ;;
        *)
            rvm_error_help "Unknown subcommand '$1'" rvmrc warning;
            return 1
        ;;
    esac
}
__rvmrc_warning_check () 
{ 
    if __rvmrc_warning_check_quiet "$1"; then
        rvm_log "path '$1' is ignored.";
    else
        \typeset ret=$?;
        rvm_log "path '$1' is not ignored.";
        return $ret;
    fi
}
__rvmrc_warning_check_quiet () 
{ 
    [[ -f "$__rvmrc_warning_path" ]] || return $?;
    \typeset __rvmrc_type;
    case "$1" in 
        all.rvmrcs | allGemfiles)
            true
        ;;
        *)
            __rvmrc_type="^all${1##*/}s";
            if __rvm_grep "${__rvmrc_type}$" "$__rvmrc_warning_path" > /dev/null; then
                return 0;
            fi
        ;;
    esac;
    __rvm_grep "^$1$" "$__rvmrc_warning_path" > /dev/null || return $?
}
__rvmrc_warning_display_for_Gemfile () 
{ 
    \typeset __rvmrc_warning_path __rvmrc_warning_file;
    __rvmrc_warning_path="$rvm_user_path/rvmrc_ignored";
    if [[ -t 2 ]] && __rvmrc_full_path_to_file "${1:-}" && ! __rvmrc_warning_check_quiet "${__rvmrc_warning_file:-${2:-}}"; then
        rvm_log "RVM used your Gemfile for selecting Ruby, it is all fine - Heroku does that too,
you can ignore these warnings with 'rvm rvmrc warning ignore $1'.
To ignore the warning for all files run 'rvm rvmrc warning ignore allGemfiles'.
" 1>&2;
    fi
}
__rvmrc_warning_display_for_rvmrc () 
{ 
    \typeset __rvmrc_warning_path __rvmrc_warning_file;
    __rvmrc_warning_path="$rvm_user_path/rvmrc_ignored";
    if [[ -t 2 ]] && __rvmrc_full_path_to_file "${1:-}" && ! __rvmrc_warning_check_quiet "${__rvmrc_warning_file:-${2:-}}"; then
        rvm_warn "You are using '.rvmrc', it requires trusting, it is slower and it is not compatible with other ruby managers,
you can switch to '.ruby-version' using 'rvm rvmrc to ruby-version'
or ignore this warning with 'rvm rvmrc warning ignore $1',
'.rvmrc' will continue to be the default project file in RVM 1 and RVM 2,
to ignore the warning for all files run 'rvm rvmrc warning ignore all.rvmrcs'.
" 1>&2;
    fi
}
__rvmrc_warning_ignore () 
{ 
    __rvmrc_warning_check_quiet "$1" || case "$1" in 
        all.rvmrcs | allGemfiles)
            echo "$1" >> "$__rvmrc_warning_path"
        ;;
        *)
            echo "$1" >> "$__rvmrc_warning_path"
        ;;
    esac
}
__rvmrc_warning_list () 
{ 
    rvm_log "# List of project files that ignore warnings:";
    if [[ -s "$__rvmrc_warning_path" ]]; then
        \command \cat "$__rvmrc_warning_path";
    fi
}
__rvmrc_warning_reset () 
{ 
    \typeset __rvmrc_type;
    case "${1:-}" in 
        all.rvmrcs | allGemfiles)
            if __rvmrc_warning_check_quiet "$1"; then
                __rvm_sed_i "$__rvmrc_warning_path" -e "\#^${1}\$# d" -e '/^$/ d';
                __rvmrc_type="${1#all}";
                __rvmrc_type="${__rvmrc_type%s}";
                __rvm_sed_i "$__rvmrc_warning_path" -e "\#/${__rvmrc_type}\$# d" -e '\#^$# d';
            else
                rvm_debug "Already removed warning ignore from '$1'.";
            fi
        ;;
        *)
            if __rvmrc_warning_check_quiet "$1"; then
                __rvm_sed_i "$__rvmrc_warning_path" -e "\#^${1}\$# d" -e '\#^$# d';
            else
                rvm_debug "Already removed warning ignore from '$1'.";
            fi
        ;;
    esac
}
__setup_lang_fallback () 
{ 
    if [[ -z "${LANG:-}" ]]; then
        LANG="$(
      {
        locale -a | __rvm_grep "^en_US.utf8" ||
        locale -a | __rvm_grep "^en_US" ||
        locale -a | __rvm_grep "^en" ||
        locale -a
      } 2>/dev/null | \command \head -n 1
    )";
        : LANG=${LANG:=en_US.utf-8};
        export LANG;
        rvm_warn "\$LANG was empty, setting up LANG=$LANG, if it fails again try setting LANG to something sane and try again.";
    fi
}
__tig_complete_file () 
{ 
    local pfx ls ref cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        ?*:*)
            ref="${cur%%:*}";
            cur="${cur#*:}";
            case "$cur" in 
                ?*/*)
                    pfx="${cur%/*}";
                    cur="${cur##*/}";
                    ls="$ref:$pfx";
                    pfx="$pfx/"
                ;;
                *)
                    ls="$ref"
                ;;
            esac;
            COMPREPLY=($(compgen -P "$pfx" 			-W "$(git --git-dir="$(__tigdir)" ls-tree "$ls" 				| sed '/^100... blob /s,^.*	,,
				       /^040000 tree /{
				           s,^.*	,,
				           s,$,/,
				       }
				       s/^.*	//')" 			-- "$cur"))
        ;;
        *)
            _tigcomp "$(__tig_refs)"
        ;;
    esac
}
__tig_complete_revlist () 
{ 
    local pfx cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        *...*)
            pfx="${cur%...*}...";
            cur="${cur#*...}";
            _tigcomp "$(__tig_refs)" "$pfx" "$cur"
        ;;
        *..*)
            pfx="${cur%..*}..";
            cur="${cur#*..}";
            _tigcomp "$(__tig_refs)" "$pfx" "$cur"
        ;;
        *.)
            _tigcomp "$cur."
        ;;
        *)
            _tigcomp "$(__tig_refs)"
        ;;
    esac
}
__tig_refs () 
{ 
    local cmd i is_hash=y dir="$(__tigdir "$1")";
    if [ -d "$dir" ]; then
        for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD;
        do
            if [ -e "$dir/$i" ]; then
                echo $i;
            fi;
        done;
        for i in $(git --git-dir="$dir" 			for-each-ref --format='%(refname)' 			refs/tags refs/heads refs/remotes);
        do
            case "$i" in 
                refs/tags/*)
                    echo "${i#refs/tags/}"
                ;;
                refs/heads/*)
                    echo "${i#refs/heads/}"
                ;;
                refs/remotes/*)
                    echo "${i#refs/remotes/}"
                ;;
                *)
                    echo "$i"
                ;;
            esac;
        done;
        return;
    fi;
    for i in $(git-ls-remote "$dir" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y;
                echo "${i#refs/tags/}"
            ;;
            n,refs/heads/*)
                is_hash=y;
                echo "${i#refs/heads/}"
            ;;
            n,refs/remotes/*)
                is_hash=y;
                echo "${i#refs/remotes/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
__tigdir () 
{ 
    if [ -z "$1" ]; then
        if [ -n "$__git_dir" ]; then
            echo "$__git_dir";
        else
            if [ -d .git ]; then
                echo .git;
            else
                git rev-parse --git-dir 2> /dev/null;
            fi;
        fi;
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}
__variables_definition () 
{ 
    \typeset -a __variables_list __array_list;
    \typeset __method;
    __method="$1";
    __variables_list=(rvm_head_flag rvm_ruby_selected_flag rvm_user_install_flag rvm_path_flag rvm_cron_flag rvm_static_flag rvm_default_flag rvm_loaded_flag rvm_llvm_flag rvm_skip_autoreconf_flag rvm_dynamic_extensions_flag rvm_18_flag rvm_19_flag rvm_20_flag rvm_21_flag rvm_force_autoconf_flag rvm_dump_environment_flag rvm_curl_flags rvm_rubygems_version rvm_verbose_flag rvm_debug_flag rvm_trace_flag __array_start rvm_skip_pristine_flag rvm_pretty_print_flag rvm_create_flag rvm_remove_flag rvm_movable_flag rvm_archive_flag rvm_gemdir_flag rvm_reload_flag rvm_auto_reload_flag rvm_disable_binary_flag rvm_ignore_gemsets_flag rvm_skip_gemsets_flag rvm_install_on_use_flag rvm_remote_flag rvm_verify_downloads_flag rvm_skip_openssl_flag rvm_gems_cache_path rvm_gems_path rvm_man_path rvm_ruby_gem_path rvm_ruby_log_path rvm_gems_cache_path rvm_archives_path rvm_docs_path rvm_environments_path rvm_examples_path rvm_gems_path rvm_gemsets_path rvm_help_path rvm_hooks_path rvm_lib_path rvm_log_path rvm_patches_path rvm_repos_path rvm_rubies_path rvm_scripts_path rvm_src_path rvm_tmp_path rvm_user_path rvm_usr_path rvm_wrappers_path rvm_stored_errexit rvm_ruby_strings rvm_ruby_binary rvm_ruby_gem_home rvm_ruby_home rvm_ruby_interpreter rvm_ruby_irbrc rvm_ruby_major_version rvm_ruby_minor_version rvm_ruby_package_name rvm_ruby_patch_level rvm_ruby_release_version rvm_ruby_repo_url rvm_ruby_repo_branch rvm_ruby_revision rvm_ruby_tag rvm_ruby_sha rvm_ruby_version rvm_ruby_package_file rvm_ruby_name rvm_ruby_name rvm_ruby_args rvm_ruby_user_tag rvm_ruby_patch detected_rvm_ruby_name __rvm_env_loaded next_token rvm_error_message rvm_gemset_name rvm_parse_break rvm_token rvm_action rvm_export_args rvm_gemset_separator rvm_expanding_aliases rvm_tar_command rvm_tar_options rvm_patch_original_pwd rvm_project_rvmrc rvm_archive_extension rvm_autoinstall_bundler_flag rvm_codesign_identity rvm_expected_gemset_name rvm_without_gems rvm_with_gems rvm_with_default_gems rvm_ignore_dotfiles_flag rvm_fuzzy_flag rvm_autolibs_flag rvm_autolibs_flag_number rvm_autolibs_flag_runner rvm_quiet_curl_flag rvm_max_time_flag rvm_error_clr rvm_warn_clr rvm_debug_clr rvm_notify_clr rvm_reset_clr rvm_error_color rvm_warn_color rvm_debug_color rvm_notify_color rvm_reset_color rvm_log_timestamp rvm_log_filesystem rvm_log_namelen rvm_show_log_lines_on_error);
    __array_list=(rvm_patch_names rvm_ree_options rvm_autoconf_flags rvm_architectures);
    case "${__method}" in 
        export)
            true
        ;;
        unset)
            unset "${__array_list[@]}" || true
        ;;
        *)
            rvm_error "Unknown action given to __variables_definition: ${__method}";
            return 1
        ;;
    esac;
    ${__method} "${__variables_list[@]}" || true;
    if [[ -n "${BASH_VERSION:-}" ]]; then
        export -fn __rvm_select_version_variables __rvm_ruby_string_parse_ __rvm_rm_rf_verbose __rvm_parse_args 2> /dev/null || true;
    fi
}
__zsh_like_cd () 
{ 
    \typeset __zsh_like_cd_hook;
    if builtin "$@"; then
        for __zsh_like_cd_hook in chpwd "${chpwd_functions[@]}";
        do
            if \typeset -f "$__zsh_like_cd_hook" > /dev/null 2>&1; then
                "$__zsh_like_cd_hook" || break;
            fi;
        done;
        true;
    else
        return $?;
    fi
}
_a2disconf () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_conf conf-enabled
}
_a2dismod () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_mods mods-enabled
}
_a2dissite () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_sites sites-enabled
}
_a2enconf () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_conf conf-available
}
_a2enmod () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_mods mods-available
}
_a2ensite () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _apache2_sites sites-available
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_apache2_allcomp () 
{ 
    command ls /etc/apache2/$1 2> /dev/null
}
_apache2_conf () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 \
               | sed -e 's/[.]conf$//' )' -- $cur  ))
}
_apache2_mods () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 \
               | sed -e 's/[.]load$//' -e 's/[.]conf$//' )' -- $cur  ))
}
_apache2_sites () 
{ 
    COMPREPLY=($( compgen -W '$( _apache2_allcomp $1 )' -- $cur  ))
}
_apt_file () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        list | show)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ));
            return 0
        ;;
        search | find)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -v -V -a -s -l -F -y -H -N -d \
				--cache --verbose --version --architecture \
				--sources-list --package-only --fixed-string \
				--architecture --cdrom-mount --non-interactive \
				--dummy --help' -- $cur ));
    else
        COMPREPLY=($( compgen -W 'update search list find \
	                        show purge' -- $cur ));
    fi;
    return 0
}
_available_interfaces () 
{ 
    local cmd PATH=$PATH:/sbin;
    if [[ ${1:-} == -w ]]; then
        cmd="iwconfig";
    else
        if [[ ${1:-} == -a ]]; then
            cmd="{ ifconfig || ip link show up; }";
        else
            cmd="{ ifconfig -a || ip link show; }";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_bzr_lazy () 
{ 
    unset _bzr;
    eval "$(bzr bash-completion)";
    if [[ $(type -t _bzr) == function ]]; then
        unset _bzr_lazy;
        _bzr;
        return $?;
    else
        return 1;
    fi
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_cdsitepackages_complete () 
{ 
    local cur="$2";
    COMPREPLY=($(cdsitepackages && compgen -d -- "${cur}" ))
}
_cdvirtualenv_complete () 
{ 
    local cur="$2";
    COMPREPLY=($(cdvirtualenv && compgen -d -- "${cur}" ))
}
_cmake () 
{ 
    local cur prev words cword split=false;
    _init_completion -n := || return;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in 
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in 
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                    cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in 
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  /{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policies 2>/dev/null |
                grep "^  CMP" 2>/dev/null )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i=0; i < $word_offset; i++ ))
    do
        for ((j=0; j <= ${#COMP_LINE}; j++ ))
        do
            [[ "$COMP_LINE" == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT-=${#COMP_WORDS[i]}));
    done;
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    ((COMP_CWORD -= $word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($( compgen -d -c -- "$cur" ));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$( complete -p $cmd 2>/dev/null );
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$( complete -p ${cmd##*/} 2>/dev/null );
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$( complete -p $compcmd 2>/dev/null );
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != $cspec ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($( eval compgen "$cspec" -- '$cur' ));
            fi;
        else
            if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
                _minimal;
            fi;
        fi;
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_complete_vim_addons () 
{ 
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    commands="list status install remove disable amend files show";
    any_command=$(echo $commands | sed -e 's/\s\+/|/g');
    options="-h --help -r --registry-dir -s --source-dir -t --target-dir -v --verbose -y --system-dir -w --system-wide -q --query";
    any_option=$(echo $options | sed -e 's/\s\+/|/g');
    if [[ "$prev" == 'vim-addons' ]] || [[ "$prev" == 'vim-addon-manager' ]] || [[ "$prev" == 'vam' ]]; then
        COMPREPLY=($( compgen -W "$commands" -- $cur ));
        return 0;
    fi;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$options" -- $cur));
        return 0;
    fi;
    if [[ "$prev" == @(-r|--registry-dir|-s|--source-dir|-t|--target-dir|-y|--system-dir) ]]; then
        COMPREPLY=($( compgen -o dirnames -- $cur ));
        return 0;
    fi;
    command='';
    target_dir='';
    system_wide='';
    system_dir='';
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++))
    do
        if [[ ${COMP_WORDS[i]} == @($any_command) ]]; then
            command=${COMP_WORDS[i]};
        fi;
        if [[ ${COMP_WORDS[i]} == @(-w|--system-wide) ]]; then
            system_wide="--system-wide";
        fi;
        if [[ $i -gt 0 ]]; then
            if [[ ${COMP_WORDS[i-1]} == @(-t|--target-dir) ]]; then
                target_dir="--target-dir ${COMP_WORDS[i]}";
            fi;
            if [[ ${COMP_WORDS[i-1]} == @(-y|--system-dir) ]]; then
                system_dir="--system-dir ${COMP_WORDS[i]}";
            fi;
        fi;
    done;
    query="vim-addons status --query $system_wide $system_dir $target_dir";
    if [[ -z "$command" ]]; then
        COMPREPLY=();
        return 0;
    fi;
    case "$command" in 
        list)
            COMPREPLY=()
        ;;
        install)
            COMPREPLY=($(  $query | grep -e "^$cur" | grep -v -e "installed$" | sed -e 's/^\(\S\+\).*/\1/' ))
        ;;
        remove | disable | amend)
            COMPREPLY=($(  $query | grep -e "^$cur" | grep -e "installed$" | sed -e 's/^\(\S\+\).*/\1/' ))
        ;;
        *)
            COMPREPLY=($(grep -h "^addon: $cur" /usr/share/vim/registry/*.yaml | sed -e 's/^addon:\s*//'))
        ;;
    esac
}
_completion_loader () 
{ 
    local compfile=./completions;
    [[ $BASH_SOURCE == */* ]] && compfile="${BASH_SOURCE%/*}/completions";
    compfile+="/${1##*/}";
    [[ -f "$compfile" ]] && . "$compfile" &> /dev/null && return 124;
    complete -F _minimal "$1" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpack () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_ctest () 
{ 
    local cur prev words cword;
    _init_completion -n = || return;
    case "$prev" in 
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude | --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_dvd_devices () 
{ 
    COMPREPLY+=($( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur 2> /dev/null;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 ]] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted x tmp;
    _quote_readline_by_ref "$cur" quoted;
    x=$( compgen -d -- "$quoted" ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.@($1|${1^^})"};
        x=$( compgen -f -X "$xspec" -- $quoted ) && while read -r tmp; do
            toks+=("$tmp");
        done <<< "$x";
    fi;
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && -n "$1" && "$1" != -d && ${#toks[@]} -lt 1 ]] && x=$( compgen -f -- $quoted ) && while read -r tmp; do
        toks+=("$tmp");
    done <<< "$x";
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return 0;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [[ -n $tmp ]] && printf '%s\n' $tmp
        done
        }
        ));
    if [[ ${#toks[@]} -ne 0 ]]; then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [[ -d /etc/fs ]] && command ls /etc/fs )";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($( compgen -W "$fss" -- "$cur" ))
}
_gem191 () 
{ 
    local cur prev completions;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    COMMANDS='build cert check cleanup contents dependency\
      environment fetch generate_index help install list\
      lock mirror outdated pristine query rdoc search server\
      sources specification uninstall unpack update which';
    GEM_OPTIONS='\
      -h --help\
      -v --version';
    COMMON_OPTIONS='\
      -h --help\
      -V --verbose --no-verbose\
      -q --quiet\
      --config-file\
      --backtrace\
      --debug';
    CERT_OPTIONS='\
      -a -add\
      -l --list\
      -r --remove\
      -b --build\
      -C --certificate\
      -K --private-key\
      -s --sign';
    CHECK_OPTIONS='\
      --verify\
      -a --alien\
      -t --test\
      -v --version';
    CLEANUP_OPTIONS='\
      -d --dry-run';
    CONTENTS_OPTIONS='\
      -v --version\
      -s --spec-dir\
      -l --lib-only --no-lib-only';
    DEPENDENCY_OPTIONS='\
      -v --version\
      --platform\
      -R --reverse-dependencies --no-reverse-dependencies\
      -p --pipe';
    ENVIRONMENT_OPTIONS='';
    FETCH_OPTIONS='\
      -v --version\
      --platform\
      -B --bulk-threshold\
      -p --http-proxy --no-http-proxy\
      --source';
    GENERATE_INDEX_OPTIONS='\
      -d --directory';
    HELP_OPTIONS=$COMMANDS;
    INSTALL_OPTIONS='\
      --platform\
      -v --version\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LIST_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    LOCK_OPTIONS='\
      -s --strict --no-strict';
    MIRROR_OPTIONS='';
    OUTDATED_OPTIONS='\
      --platform';
    PRISTINE_OPTIONS='\
      --all\
      -v --version';
    QUERY_OPTIONS='\
      -n --name-matches\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    RDOC_OPTIONS='\
      --all\
      --rdoc --no-rdoc\
      --ri --no-ri\
      -v --version';
    SEARCH_OPTIONS='\
      -d --details --no-details\
      --versions --no-versions\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    SERVER_OPTIONS='\
      -p --port\
      -d --dir\
      --daemon --no-daemon';
    SOURCES_OPTIONS='\
      -a --add\
      -l --list\
      -r --remove\
      -u --update\
      -c --clear-all';
    SPECIFICATION_OPTIONS='\
      -v --version\
      --platform\
      --all\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    UNINSTALL_OPTIONS='\
      -a --all --no-all\
      -i --ignore-dependencies --no-ignore-dependencies\
      -x --executables --no-executables\
      -v --version\
      --platform';
    UNPACK_OPTIONS='\
      --target\
      -v --version';
    UPDATE_OPTIONS='\
      --system\
      --platform\
      -i --install-dir\
      -d --rdoc --no-rdoc\
      --ri --no-ri\
      -E --env-shebang\
      -f --force --no-force\
      -t --test --no-test\
      -w --wrappers --no-wrappers\
      -P --trust-policy\
      --ignore-dependencies\
      -y --include-dependencies\
      --format-executable --no-format-executable\
      -l --local\
      -r --remote\
      -b --both\
      -B --bulk-threshold\
      --source\
      -p --http-proxy --no-http-proxy\
      -u --update-sources --no-update-sources';
    WHICH_OPTIONS='\
      -a --all --no-all\
      -g --gems-first --no-gems-first';
    case "${prev}" in 
        build)
            completions="$COMMON_OPTIONS $BUILD_OPTIONS"
        ;;
        cert)
            completions="$COMMON_OPTIONS $CERT_OPTIONS"
        ;;
        check)
            completions="$COMMON_OPTIONS $CHECK_OPTIONS"
        ;;
        cleanup)
            completions="$COMMON_OPTIONS $CLEANUP_OPTIONS"
        ;;
        contents)
            completions="$COMMON_OPTIONS $CONTENTS_OPTIONS"
        ;;
        dependency)
            completions="$COMMON_OPTIONS $DEPENDENCY_OPTIONS"
        ;;
        environment)
            completions="$COMMON_OPTIONS $ENVIRONMENT_OPTIONS"
        ;;
        fetch)
            completions="$COMMON_OPTIONS $FETCH_OPTIONS"
        ;;
        generate_index)
            completions="$COMMON_OPTIONS $GENERATE_INDEX_OPTIONS"
        ;;
        help)
            completions="$COMMON_OPTIONS $HELP_OPTIONS"
        ;;
        install)
            completions="$COMMON_OPTIONS $INSTALL_OPTIONS"
        ;;
        list)
            completions="$COMMON_OPTIONS $LIST_OPTIONS"
        ;;
        lock)
            completions="$COMMON_OPTIONS $LOCK_OPTIONS"
        ;;
        mirror)
            completions="$COMMON_OPTIONS $MIRROR_OPTIONS"
        ;;
        outdated)
            completions="$COMMON_OPTIONS $OUTDATED_OPTIONS"
        ;;
        pristine)
            completions="$COMMON_OPTIONS $PRISTINE_OPTIONS"
        ;;
        query)
            completions="$COMMON_OPTIONS $QUERY_OPTIONS"
        ;;
        rdoc)
            completions="$COMMON_OPTIONS $RDOC_OPTIONS"
        ;;
        search)
            completions="$COMMON_OPTIONS $SEARCH_OPTIONS"
        ;;
        server)
            completions="$COMMON_OPTIONS $SERVER_OPTIONS"
        ;;
        sources)
            completions="$COMMON_OPTIONS $SOURCES_OPTIONS"
        ;;
        specification)
            completions="$COMMON_OPTIONS $SPECIFICATION_OPTIONS"
        ;;
        uninstall)
            completions="$COMMON_OPTIONS $UNINSTALL_OPTIONS"
        ;;
        unpack)
            completions="$COMMON_OPTIONS $UNPACK_OPTIONS"
        ;;
        update)
            completions="$COMMON_OPTIONS $UPDATE_OPTIONS"
        ;;
        which)
            completions="$COMMON_OPTIONS $WHICH_OPTIONS"
        ;;
        *)
            completions="$COMMANDS $GEM_OPTIONS"
        ;;
    esac;
    COMPREPLY=($( compgen -W "$completions" -- $cur ));
    return 0
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [[ $COMP_CWORD -ge 1 ]]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_gnomeopen () 
{ 
    if [ -e "$@" ]; then
        c9 "$@";
        return;
    fi;
    command xdg-open "$@"
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_hg () 
{ 
    local cur prev cmd cmd_index opts i;
    local global_args='--cwd|-R|--repository';
    local hg="$1";
    local canonical=0;
    COMPREPLY=();
    cur="$2";
    prev="$3";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                cmd="${COMP_WORDS[i]}";
                cmd_index=$i;
                break;
            fi;
        fi;
    done;
    if [[ "$cur" == -* ]]; then
        if [ "$(type -t "_hg_opt_$cmd")" = function ] && "_hg_opt_$cmd"; then
            return;
        fi;
        opts=$(_hg_cmd debugcomplete --options "$cmd");
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$opts' -- "$cur"));
        return;
    fi;
    case "$prev" in 
        -R | --repository)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --cwd)
            return
        ;;
    esac;
    if [ -z "$cmd" ] || [ $COMP_CWORD -eq $i ]; then
        _hg_commands;
        return;
    fi;
    local help;
    if _hg_command_specific; then
        return;
    fi;
    help=$(_hg_cmd help "$cmd");
    if [ $? -ne 0 ]; then
        return;
    fi;
    cmd=${help#hg };
    cmd=${cmd%%[' 
']*};
    canonical=1;
    _hg_command_specific
}
_hg_bookmarks () 
{ 
    local bookmarks="$(_hg_cmd bookmarks -q)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$bookmarks' -- "$cur"))
}
_hg_cmd () 
{ 
    HGPLAIN=1 "$hg" "$@" 2> /dev/null
}
_hg_cmd_bisect () 
{ 
    local i subcmd;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                subcmd="${COMP_WORDS[i]}";
                break;
            fi;
        fi;
    done;
    if [ -z "$subcmd" ] || [ $COMP_CWORD -eq $i ] || [ "$subcmd" = help ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W 'bad good help init next reset' -- "$cur"));
        return;
    fi;
    case "$subcmd" in 
        good | bad)
            _hg_labels
        ;;
    esac;
    return
}
_hg_cmd_bookmarks () 
{ 
    if [[ "$prev" = @(-d|--delete|-m|--rename) ]]; then
        _hg_bookmarks;
        return;
    fi
}
_hg_cmd_email () 
{ 
    case "$prev" in 
        -c | --cc | -t | --to | -f | --from | --bcc)
            if [ "$(type -t _hg_emails)" = function ]; then
                local arg=to;
                if [[ "$prev" == @(-f|--from) ]]; then
                    arg=from;
                fi;
                local addresses=$(_hg_emails $arg);
                COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$addresses' -- "$cur"));
            fi;
            return
        ;;
        -m | --mbox)
            return
        ;;
        -s | --subject)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_qclone () 
{ 
    local count=$(_hg_count_non_option);
    if [ $count = 1 ]; then
        _hg_paths;
    fi;
    _hg_repos
}
_hg_cmd_qcommit () 
{ 
    local root=$(_hg_cmd root);
    local files=$(cd "$root/.hg/patches" && _hg_cmd status -nmar);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_cmd_qdelete () 
{ 
    local qcmd=qunapplied;
    if [[ "$prev" = @(-r|--rev) ]]; then
        qcmd=qapplied;
    fi;
    _hg_ext_mq_patchlist $qcmd
}
_hg_cmd_qfinish () 
{ 
    if [[ "$prev" = @(-a|--applied) ]]; then
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qfold () 
{ 
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qgoto () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qguard () 
{ 
    local prefix='';
    if [[ "$cur" == +* ]]; then
        prefix=+;
    else
        if [[ "$cur" == -* ]]; then
            prefix=-;
        fi;
    fi;
    local ncur=${cur#[-+]};
    if ! [ "$prefix" ]; then
        _hg_ext_mq_patchlist qseries;
        return;
    fi;
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -P $prefix -W '$guards' -- "$ncur"))
}
_hg_cmd_qheader () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qpop () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qapplied
}
_hg_cmd_qpush () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi;
    _hg_ext_mq_patchlist qunapplied
}
_hg_cmd_qqueue () 
{ 
    local q;
    local queues;
    local opts="--list --create --rename --delete --purge";
    queues=$( _hg_cmd qqueue --quiet );
    COMPREPLY=($( compgen -W "${opts} ${queues}" "${cur}" ))
}
_hg_cmd_qrename () 
{ 
    _hg_ext_mq_patchlist qseries
}
_hg_cmd_qsave () 
{ 
    if [[ "$prev" = @(-n|--name) ]]; then
        _hg_ext_mq_queues;
        return;
    fi
}
_hg_cmd_qselect () 
{ 
    local guards=$(_hg_ext_mq_guards);
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$guards' -- "$cur"))
}
_hg_cmd_rebase () 
{ 
    if [[ "$prev" = @(-s|--source|-d|--dest|-b|--base|-r|--rev) ]]; then
        _hg_labels;
        return;
    fi
}
_hg_cmd_shelve () 
{ 
    _hg_status "mard"
}
_hg_cmd_sign () 
{ 
    _hg_labels
}
_hg_cmd_strip () 
{ 
    _hg_labels
}
_hg_cmd_transplant () 
{ 
    case "$prev" in 
        -s | --source)
            _hg_paths;
            _hg_repos;
            return
        ;;
        --filter)
            return
        ;;
    esac;
    _hg_labels;
    return
}
_hg_cmd_unshelve () 
{ 
    _hg_shelves
}
_hg_command_specific () 
{ 
    if [ "$(type -t "_hg_cmd_$cmd")" = function ]; then
        "_hg_cmd_$cmd";
        return 0;
    fi;
    if [ "$cmd" != status ] && [ "$prev" = -r ] || [ "$prev" == --rev ]; then
        if [ $canonical = 1 ]; then
            _hg_labels;
            return 0;
        else
            if [[ status != "$cmd"* ]]; then
                _hg_labels;
                return 0;
            else
                return 1;
            fi;
        fi;
    fi;
    case "$cmd" in 
        help)
            _hg_commands
        ;;
        export)
            if _hg_ext_mq_patchlist qapplied && [ "${COMPREPLY[*]}" ]; then
                return 0;
            fi;
            _hg_labels
        ;;
        manifest | update | up | checkout | co)
            _hg_labels
        ;;
        pull | push | outgoing | incoming)
            _hg_paths;
            _hg_repos
        ;;
        paths)
            _hg_paths
        ;;
        add)
            _hg_status "u"
        ;;
        merge)
            _hg_labels
        ;;
        commit | ci | record)
            _hg_status "mar"
        ;;
        remove | rm)
            _hg_debugpathcomplete -n
        ;;
        forget)
            _hg_debugpathcomplete -fa
        ;;
        diff)
            _hg_status "mar"
        ;;
        revert)
            _hg_debugpathcomplete
        ;;
        clone)
            local count=$(_hg_count_non_option);
            if [ $count = 1 ]; then
                _hg_paths;
            fi;
            _hg_repos
        ;;
        debugindex | debugindexdot)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.i" -- "$cur"))
        ;;
        debugdata)
            COMPREPLY=(${COMPREPLY[@]:-} $(compgen -f -X "!*.d" -- "$cur"))
        ;;
        *)
            return 1
        ;;
    esac;
    return 0
}
_hg_commands () 
{ 
    local commands;
    commands="$(HGPLAINEXCEPT=alias _hg_cmd debugcomplete "$cur")" || commands="";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$commands' -- "$cur"))
}
_hg_count_non_option () 
{ 
    local i count=0;
    local filters="$1";
    for ((i=1; $i<=$COMP_CWORD; i++))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} == @($filters|$global_args) ]]; then
                continue;
            fi;
            count=$(($count + 1));
        fi;
    done;
    echo $(($count - 1))
}
_hg_debugpathcomplete () 
{ 
    local files="$(_hg_cmd debugpathcomplete $1 "$cur")";
    local IFS='
';
    compopt -o filenames 2> /dev/null;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_hg_ext_mq_guards () 
{ 
    _hg_cmd qselect --series | sed -e 's/^.//'
}
_hg_ext_mq_patchlist () 
{ 
    local patches;
    patches=$(_hg_cmd $1);
    if [ $? -eq 0 ] && [ "$patches" ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$patches' -- "$cur"));
        return 0;
    fi;
    return 1
}
_hg_ext_mq_queues () 
{ 
    local root=$(_hg_cmd root);
    local n;
    for n in $(cd "$root"/.hg && compgen -d -- "$cur");
    do
        if [ "$n" != patches ] && [ -e "$root/.hg/$n/series" ]; then
            COMPREPLY=(${COMPREPLY[@]:-} "$n");
        fi;
    done
}
_hg_labels () 
{ 
    local labels="$(_hg_cmd debuglabelcomplete "$cur")";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$labels' -- "$cur"))
}
_hg_opt_qguard () 
{ 
    local i;
    for ((i=cmd_index+1; i<=COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            if [[ ${COMP_WORDS[i-1]} != @($global_args) ]]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        else
            if [ "${COMP_WORDS[i]}" = -- ]; then
                _hg_cmd_qguard;
                return 0;
            fi;
        fi;
    done;
    return 1
}
_hg_paths () 
{ 
    local paths="$(_hg_cmd paths -q)";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$paths' -- "$cur"))
}
_hg_repos () 
{ 
    local i;
    for i in $(compgen -d -- "$cur");
    do
        test ! -d "$i"/.hg || COMPREPLY=(${COMPREPLY[@]:-} "$i");
    done
}
_hg_shelves () 
{ 
    local shelves="$(_hg_cmd unshelve -l .)";
    local IFS='
';
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$shelves' -- "$cur"))
}
_hg_status () 
{ 
    local files="$(_hg_cmd status -n$1 "glob:$cur**")";
    local IFS='
';
    compopt -o filenames 2> /dev/null;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W '$files' -- "$cur"))
}
_init_completion () 
{ 
    local exclude= flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || $prev == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=$errx
            ;;
            *'>'*)
                xspec=$outx
            ;;
            *'<'*)
                xspec=$inx
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=$errx
                    ;;
                    *'>'*)
                        xspec=$outx
                    ;;
                    *'<'*)
                        xspec=$inx
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            [[ $i -le $cword ]] && cword=$(( cword - skip ));
        else
            i=$(( ++i ));
        fi;
    done;
    [[ $cword -le 0 ]] && return 1;
    prev=${words[cword-1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip_addresses () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY+=($( compgen -W         "$( { LC_ALL=C ifconfig -a || ip addr show; } 2>/dev/null |
            sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'                 -ne 's|.*inet[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p' )"         -- "$cur" ))
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options+=" -c";
    _known_hosts_real $options -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [[ $# -lt $OPTIND ]] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [[ $# -ge $OPTIND ]] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [[ $# -ge $OPTIND ]]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    if [[ ${#config[@]} -gt 0 ]]; then
        local OIFS=$IFS IFS='
' j;
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        IFS=$OIFS;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ -z $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [[ -z $awkcur ]]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [[ ${#kh[@]} -gt 0 ]]; then
            COMPREPLY+=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {
            sub("^@[^ ]+ +", ""); \
            sub(" .*$", ""); \
            for (i=1; i<=NF; ++i) { \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i !~ /[*?]/ && $i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [[ ${#khd[@]} -gt 0 ]]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY+=($( compgen -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    COMPREPLY+=($( compgen -W         "$( ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }' )"         -- "$cur" ));
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return 0
        ;;
        --*dir*)
            _filedir -d;
            return 0
        ;;
        --*file* | --*path*)
            _filedir;
            return 0
        ;;
        --+([-a-z0-9_]))
            local argtype=$( $1 --help 2>&1 | sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p" );
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return 0
                ;;
                *file* | *path*)
                    _filedir;
                    return 0
                ;;
            esac
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}=\{0,1\}\).*/\1/p' | sort -u )"             -- "$cur" ));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_lsvirtualenv_usage () 
{ 
    echo "lsvirtualenv [-blh]";
    echo "  -b -- brief mode";
    echo "  -l -- long mode";
    echo "  -h -- this help message"
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(         { LC_ALL=C ifconfig -a || ip link show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne         "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
        ));
    COMPREPLY+=($( { arp -an || ip neigh show; } 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY+=($( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -RL $modpath 2>/dev/null |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_mvn () 
{ 
    local i prev c=1 cmd option optionArg=0 cmdcomplete=0;
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=();
    while [ $c -le $COMP_CWORD ]; do
        prev=$i;
        i="${COMP_WORDS[c]}";
        c=$((++c));
        optionArg=0;
        if [[ $prev == @(${__mvnoptsWithArg}) ]]; then
            optionArg=1;
            continue;
        fi;
        if [[ $cmdcomplete == -3 ]]; then
            cmdcomplete=1;
            break;
        fi;
        if [[ "$i" == "" ]]; then
            if [[ -n $cmd ]]; then
                cmdcomplete=1;
                break;
            fi;
            continue;
        fi;
        if [[ "$i" == ":" ]]; then
            if [[ -n $cmd ]]; then
                cmdcomplete=$((cmdcomplete-1));
                cmd="${cmd}:";
            fi;
            continue;
        fi;
        case "$i" in 
            --version | --help)
                return
            ;;
            -*)
                option="$i"
            ;;
            *)
                if [[ ! -n $cmd ]]; then
                    cmdcomplete=$((cmdcomplete-1));
                    cmd="$i";
                    local next=$c;
                    if [[ $next -lt $COMP_CWORD ]]; then
                        if [[ "${COMP_WORDS[next]}" != ":" ]]; then
                            break;
                        fi;
                    fi;
                else
                    cmdcomplete=$((cmdcomplete-1));
                    cmd="$cmd$i";
                fi
            ;;
        esac;
    done;
    if [[ ! -n $cmd && -n $option && ( $optionArg == 0 ) ]]; then
        case "$option" in 
            --file)
                __mvncomp "$(__mvnlist_poms)";
                return
            ;;
            --define)
                __mvncomp "maven.test.skip=true";
                return
            ;;
            --resume-from)
                __mvncomp "$(__mvnlist_projects)";
                return
            ;;
            --projects)
                case "${cur}" in 
                    *,*)
                        __mvncomp "$(__mvnlist_projects)" "$(__mvnprefix_comma $cur)" "${cur#*,}"
                    ;;
                    *)
                        __mvncomp "$(__mvnlist_projects)"
                    ;;
                esac;
                return
            ;;
            --settings | --global-settings)
                COMPREPLY=($( compgen -f -- $cur ));
                return
            ;;
            --*)
                COMPREPLY=()
            ;;
        esac;
    fi;
    if [ $cmdcomplete -lt 0 ]; then
        case "${cmd}" in 
            *:)
                local plugin="${cmd%%:}:";
                __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cmd)" ""
            ;;
            *:*)
                local plugin="${cmd%%:*}:";
                __mvncomp "$(__mvnlist_goals $plugin)" "$(__mvnprefix_colon $cmd)" "${cmd#*:}"
            ;;
            *)
                __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}"
            ;;
        esac;
        return;
    fi;
    if [ -z "$cmd" ]; then
        case "${cur}" in 
            -D*=*)
                COMPREPLY=()
            ;;
            -*)
                __mvncomp "${__mvnopts} ${__mvnparams}"
            ;;
            --*)
                __mvncomp "${__mvnopts}"
            ;;
            *)
                __mvncomp "${__mvnphases} ${__mvnall_plugin_and_goals}"
            ;;
        esac;
        return;
    fi;
    case "$cmd" in 
        *:help)
            local plugin="${cmd%%:*}:";
            __mvnplugin_help $plugin
        ;;
        help:describe)
            __mvnhelp_describe
        ;;
        deploy:deploy)
            __mvndeploy_deploy
        ;;
        deploy:deploy-file)
            __mvndeploy_deploy_file
        ;;
        archetype:generate)
            __mvnarchetype_generate
        ;;
        dependency:copy-dependencies)
            __mvndependency_x_dependencies
        ;;
        dependency:unpack-dependencies)
            __mvndependency_x_dependencies
        ;;
        dependency:resolve)
            __mvndependency_resolve
        ;;
        dependency:resolve-plugins)
            __mvndependency_resolve
        ;;
        dependency:source)
            __mvndependency_resolve
        ;;
        dependency:go-offline)
            __mvndependency_resolve
        ;;
        dependency:purge-local-repository)
            __mvndependency_purge_local_repository
        ;;
        dependency:analyze)
            __mvndependency_analyze
        ;;
        dependency:analyze-dep-mgt)
            __mvndependency_analyze_dep_mgt
        ;;
        exec:java)
            __mvnexec_java
        ;;
        install:install-file)
            __mvninstall_install_file
        ;;
        release:prepare)
            __mvnrelease_prepare
        ;;
        scm:checkin)
            __mvnscm_checkin
        ;;
        *)

        ;;
    esac
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$( getconf $var 2>/dev/null );
    printf %s ${n:-1}
}
_parse_help () 
{ 
    eval local cmd=$( quote "$1" );
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([ '	'])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd=$( quote "$1" );
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$( dequote "$cmd" )" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i=1; i < ${#option}; i++ ))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pci_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_quote_readline_by_ref () 
{ 
    if [ -z "$1" ]; then
        printf -v $2 %s "$1";
    else
        if [[ $1 == \'* ]]; then
            printf -v $2 %s "${1:1}";
        else
            if [[ $1 == \~* ]]; then
                printf -v $2 \~%q "${1:1}";
            else
                printf -v $2 %q "$1";
            fi;
        fi;
    fi;
    [[ ${!2} == *\\* ]] && printf -v $2 %s "${1//\\\\/\\}";
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_redis-cli () 
{ 
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    opts='bgrewriteaof bgsave dbsize debug decr decrby del echo exists expire expireat flushall flushdb get getset incr incrby info keys lastsave lindex llen lpop lpush lrange lrem lset ltrim mget move mset msetnx ping randomkey rename renamenx rewriteaof rpop rpoplpush rpush sadd save scard sdiff sdiffstore select set setnx shutdown sinter sinterstore sismember slaveof smembers smove sort spop srandmember srem sunion sunionstore ttl type zadd zcard zincrby zrange zrangebyscore zrem zremrangebyscore zrevrange zscore';
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
        return 0;
    fi
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    [[ $cword -gt 2 ]] && return 0;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($( compgen -W '`sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur" ));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local restore_nullglob=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($( printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions) ));
    $restore_nullglob;
    COMPREPLY+=($( systemctl list-units --full --all 2>/dev/null |         awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur" ))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($( compgen -P "$1" -A signal "SIG${cur#$1}" ));
    COMPREPLY+=("${sigs[@]/#${1}SIG/${1}}")
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds patch propdel pdel propedit pedit propget pget proplist";
    cmds="$cmds plist propset pset relocate resolve resolved revert status";
    cmds="$cmds  switch unlock update upgrade";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--cl|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local urlSchemas='file:/// http:// https:// svn:// svn+ssh://';
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd == @(co|checkout|ls|list) && $stat = 'arg' && $SVN_BASH_COMPL_EXT == *urls* ]]; then
        if [[ $cur == file:* ]]; then
            local where=${cur/file:/};
            COMPREPLY=($(compgen -d -S '/' -X '*/.*' -- $where ));
            return;
        else
            if [[ $cur == *:* ]]; then
                local urls= file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        local url=$(_svn_read_hashfile svn:realmstring < $file);
                        url=${url/*</};
                        url=${url/>*/};
                        urls="$urls $url";
                    fi;
                done;
                local prefix=${cur%:*} suffix=${cur#*:} c= choices=;
                for c in $urls;
                do
                    [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
                done;
                COMPREPLY=($(compgen -W "$choices" -- $suffix ));
                return;
            else
                COMPREPLY=($(compgen -W "$urlSchemas" -- $cur));
                return;
            fi;
        fi;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change 		   --ignore-all-space --ignore-eol-style --show-c-functions";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values="postpone base mine-full theirs-full edit launch 			mine-conflict theirs-conflict";
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive 	       --trust-server-cert --force-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cOpts="--cl --changelist";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts $cOpts                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock $cOpts --keep-changelists 		         --include-externals"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents 		         --ignore-externals"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize $cOpts --xml --git 		         --internal-diff --show-copies-as-adds 		         --ignore-properties --properties-only --no-diff-added 		         --patch-compatible"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals --ignore-keywords"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml $cOpts"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth --include-externals"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop --depth 		         --diff --diff-cmd -x --extensions --internal-diff 		         --with-no-revprops --search --search-and"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate 		         --allow-mixed-revisions -v --verbose"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --depth --show-revs -R --recursive"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents --allow-mixed-revisions"
        ;;
        patch)
            cmdOpts="$qOpts $pOpts --dry-run --ignore-whitespace 			--reverse-diff --strip"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts $cOpts                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict 		         $pOpts $cOpts --depth --xml --show-inherited-props";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts $cOpts --depth --xml --show-inherited-props"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force $cOpts --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        relocate)
            cmdOpts="--ignore-externals $pOpts"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts $cOpts                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          $cOpts"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth 		         --ignore-ancestry"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept $cOpts                          --parents --editor-cmd --set-depth"
        ;;
        upgrade)
            cmdOpts="$qOpts $pOpts"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump freeze help hotcopy list-dblogs \
	      list-unused-dblogs load lock lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid unlock upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type|-M|--memory-cache-size";
    optsParam="$optsParam|-F|--file";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible 		         --pre-1.6-compatible --compatible-version"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas 		         -M --memory-cache-size"
        ;;
        freeze)
            cmdOpts="-F --file"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook 		         --bypass-prop-validation -M --memory-cache-size"
        ;;
        lock | unlock)
            cmdOpts="--bypass-hooks"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -F)
                cmdOpts=${cmdOpts/ --file / }
            ;;
            --file)
                cmdOpts=${cmdOpts/ -F / }
            ;;
            -M)
                cmdOpts=${cmdOpts/ --memory-cache-size / }
            ;;
            --memory-cache-size)
                cmdOpts=${cmdOpts/ --M / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnversion () 
{ 
    local cmdOpts=" -n --no-newline -c --committed -h --help --version ";
    local cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=();
    local options= wcpath= trailurl= last='none' stat= opt= i=-1 isCur=;
    for opt in ${COMP_WORDS[@]};
    do
        [[ $i -eq $COMP_CWORD ]] && stat=$last;
        let i++;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        if [ $last = 'none' ]; then
            last='first';
            continue;
        fi;
        if [[ $last != 'arg' && $opt == -* ]]; then
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='arg';
            else
                options="$options $opt ";
                last='opt';
            fi;
            continue;
        fi;
        if [[ $opt != -* ]]; then
            last='arg';
            if [[ ! -n $wcpath ]]; then
                wcpath=$opt;
            else
                if [[ ! -n $trailurl ]]; then
                    trailurl=$opt;
                fi;
            fi;
        fi;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ $cur != -* || $stat = 'arg' ]]; then
        [[ -n $wcpath && -n $trailurl ]] && COMPREPLY=('');
        return 0;
    fi;
    for opt in $options;
    do
        cmdOpts=${cmdOpts/ $opt / };
        case $opt in 
            -n)
                cmdOpts=${cmdOpts/ --no-newline / }
            ;;
            --no-newline)
                cmdOpts=${cmdOpts/ -n / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --committed / }
            ;;
            --committed)
                cmdOpts=${cmdOpts/ -c / }
            ;;
        esac;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d)
}
_terms () 
{ 
    COMPREPLY+=($( compgen -W         "$( sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap             2>/dev/null )" -- "$cur" ));
    COMPREPLY+=($( compgen -W "$( { toe -a 2>/dev/null || toe 2>/dev/null; }         | awk '{ print $1 }' | sort -u )" -- "$cur" ))
}
_tig () 
{ 
    local i c=1 command __tig_dir;
    while [ $c -lt $COMP_CWORD ]; do
        i="${COMP_WORDS[c]}";
        case "$i" in 
            --)
                command="log";
                break
            ;;
            -*)

            ;;
            *)
                command="$i";
                break
            ;;
        esac;
        c=$((++c));
    done;
    if [ $c -eq $COMP_CWORD -a -z "$command" ]; then
        case "${COMP_WORDS[COMP_CWORD]}" in 
            --*=*)
                COMPREPLY=()
            ;;
            -*)
                _tig_options
            ;;
            *)
                _tigcomp "blame status show log $(__tig_refs)"
            ;;
        esac;
        return;
    fi;
    case "$command" in 
        blame)
            _tig_blame
        ;;
        show)
            _tig_show
        ;;
        status)

        ;;
        *)
            _tigcomp "
			$(__tig_complete_file)
			$(__tig_refs)
		"
        ;;
    esac
}
_tig_blame () 
{ 
    local reply="" ref=HEAD cur="${COMP_WORDS[COMP_CWORD]}";
    if test "$COMP_CWORD" -lt 3; then
        reply="$(__tig_refs)";
    else
        ref="${COMP_WORDS[2]}";
    fi;
    reply="$reply $(git --git-dir="$(__tigdir)" ls-tree "$ref" 			| sed '/^100... blob /s,^.*	,,
			       /^040000 tree /{
			           s,^.*	,,
			           s,$,/,
			       }
			       s/^.*	//')";
    _tigcomp "$reply"
}
_tig_options () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --pretty=*)
            _tigcomp "
			oneline short medium full fuller email raw
			" "" "${cur##--pretty=}";
            return
        ;;
        --*)
            _tigcomp "
			--max-count= --max-age= --since= --after=
			--min-age= --before= --until=
			--root --not --topo-order --date-order
			--no-merges
			--abbrev-commit --abbrev=
			--relative-date
			--author= --committer= --grep=
			--all-match
			--pretty= --name-status --name-only
			--not --all
			--help --version
			";
            return
        ;;
        -*)
            _tigcomp "-v -h";
            return
        ;;
    esac;
    __tig_complete_revlist
}
_tig_show () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "$cur" in 
        --pretty=*)
            _tigcomp "
			oneline short medium full fuller email raw
			" "" "${cur##--pretty=}";
            return
        ;;
        --*)
            _tigcomp "--pretty=";
            return
        ;;
    esac;
    __tig_complete_file
}
_tigcomp () 
{ 
    local all c s='
' IFS=' ''	''
';
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    for c in $1;
    do
        case "$c$4" in 
            --*=*)
                all="$all$c$4$s"
            ;;
            *.)
                all="$all$c$4$s"
            ;;
            *)
                all="$all$c$4 $s"
            ;;
        esac;
    done;
    IFS=$s;
    COMPREPLY=($(compgen -P "$2" -W "$all" -- "$cur"));
    return
}
_tilde () 
{ 
    local result=0;
    if [[ $1 == \~* && $1 != */* ]]; then
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
        [[ $result -gt 0 ]] && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_unp () 
{ 
    local cur;
    COMPREPLY=();
    cur="$(_get_cword)";
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W '-u' -- "$cur" ))
        ;;
        *)
            _filedir '@(zip|ZIP|jar|JAR|exe|EXE|pk3|war|wsz|ear|zargo|xpi|Z|gz|tgz|Gz|dz|lha|LHa|lhz|deb|ar|bz2|tbz2|rpm|shar|rar|arj|cab|ace|tnef|uu|mime|hqx|sea|zoo|pmd|cpio|afio|lzop|tar|lz|xz|lzma|7z)'
        ;;
    esac;
    return 0
}
_update_initramfs () 
{ 
    local cur prev valid_options;
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == '-k' ]]; then
        _kernel_versions;
        COMPREPLY=($( compgen -W '${COMPREPLY[@]} all' -- "$cur" ));
        return;
    fi;
    valid_options=$( update-initramfs -h 2>&1 | 		sed -e '/^ -/!d;s/^ \(-\w\+\).*/\1/' );
    COMPREPLY=($( compgen -W "$valid_options" -- $cur ))
}
_upstart_events () 
{ 
    ( cd /etc/init && egrep --color=auto '^[[:space:]]*emits ' *.conf | cut -d: -f2- | sed 's/^[[:space:]]*emits //g' | tr ' ' '\n' | awk '{print $NF}' | grep --color=auto -v ^$ | sort -u )
}
_upstart_initctl () 
{ 
    _get_comp_words_by_ref cur prev;
    COMPREPLY=();
    case "$prev" in 
        start)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_startable_jobs)" -- ${cur}));
            return 0
        ;;
        stop)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        emit)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_events)" -- ${cur}));
            return 0
        ;;
        -i | --ignore-events)
            for cmd in check-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        -e | --enumerate)
            for cmd in show-config;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
                    return 0;
                fi;
            done
        ;;
        reload | restart)
            COMPREPLY=($(compgen -W "-n --no-wait $(_upstart_stoppable_jobs)" -- ${cur}));
            return 0
        ;;
        status)
            COMPREPLY=($(compgen -W "$(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        check-config)
            COMPREPLY=($(compgen -W "-w --warn -i --ignore-events= $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        show-config)
            COMPREPLY=($(compgen -W "-e --enumerate $(_upstart_jobs)" -- ${cur}));
            return 0
        ;;
        -n | --no-wait)
            for cmd in start stop restart emit;
            do
                cwords=${COMP_WORDS[@]##};
                filtered_cwords=${COMP_WORDS[@]##${cmd}};
                if [ "$filtered_cwords" != "$cwords" ]; then
                    case "$cmd" in 
                        start)
                            COMPREPLY=($(compgen -W "$(_upstart_startable_jobs)" -- ${cur}))
                        ;;
                        stop)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        restart)
                            COMPREPLY=($(compgen -W "$(_upstart_stoppable_jobs)" -- ${cur}))
                        ;;
                        emit)
                            COMPREPLY=($(compgen -W "$(_upstart_events)" -- ${cur}))
                        ;;
                    esac;
                    return 0;
                fi;
            done
        ;;
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    cmds=$(initctl help|grep "^  [^ ]"|awk '{print $1}');
    COMPREPLY=($(compgen -W "${opts} ${cmds}" -- ${cur}))
}
_upstart_jobs () 
{ 
    initctl list | awk '{print $1}' | sort -u
}
_upstart_reload () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_restart () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_start () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_startable_jobs)" -- ${cur}));
    return 0
}
_upstart_startable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "stop/waiting" {print $1}'
}
_upstart_status () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q -d --detail -e --enumerate --quiet -v --verbose --session --system --dest=";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_jobs)" -- ${cur}));
    return 0
}
_upstart_stop () 
{ 
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    opts="--help --version -q --quiet -v --verbose --session --system --dest=         -n --no-wait";
    case "$prev" in 
        --help | --version)
            COMPREPLY=();
            return 0
        ;;
    esac;
    COMPREPLY=($(compgen -W "$opts $(_upstart_stoppable_jobs)" -- ${cur}));
    return 0
}
_upstart_stoppable_jobs () 
{ 
    initctl list | cut -d\, -f1 | awk '$2 == "start/running" {print $1}'
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$( uname -s );
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == $1 ]]
}
_valgrind () 
{ 
    local cur prev opts yesno tools choosen_tool i;
    yesno="--trace-children\= --child-silent-after-fork\= --track-fds\= --time-stamp\= --log-fd\=  --log-socket\=";
    opts="--tool\= ";
    opts+="-h --help --help-debug --version -q --quiet -v --verbose --log-file\= ";
    COMPREPLY=();
    for ((i=0; i < COMP_CWORD; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -- ]]; then
            _command_offset $((i + 1));
            return 0;
        fi;
    done;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == "--tool" ]]; then
            choosen_tool=${COMP_WORDS[i+2]};
        fi;
    done;
    case $choosen_tool in 
        'callgrind')
            opts+="--callgrind-out-file\= --dump-every-bb\= --dump-before\= --zero-before\= --dump-after\= --toggle-collect\= --separate-recs\= --separate-callers\= --fn-skip\= --fn-group< --separate-recs< --separate-callers< ";
            yesno+="--dump-instr\= --dump-line\= --compress-strings\= --compress-pos\= --combine-dumps\= --instr-atstart\= --collect-atstart\= --collect-jumps\= --separate-threads\= --skip-plt\= --simulate-cache\= --simulate-hwpref\= "
        ;;
        'cachegrind')
            opts+="--I1\= --D1\= --L2\= --cachegrind-out-file\= ";
            yesno+="--cache-sim\= --branch-sim\= "
        ;;
        'memcheck')
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
        *)
            yesno+="--undef-value-errors\= --track-origins\= --show-reachable\= --workaround-gcc296-bugs\= --partial-loads-ok\= ";
            opts+="--leak-check\= --leak-resolution\= --freelist-vol\= --malloc-fill\= --free-fill\= "
        ;;
    esac;
    opts+="$yesno ";
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD - 1]}";
    if [[ "$prev" == "=" ]]; then
        prev="${COMP_WORDS[COMP_CWORD - 2]}";
    else
        if [[ "$cur" == "=" ]]; then
            cur="";
        fi;
    fi;
    if [[ "$prev" == "--tool" ]]; then
        tools="memcheck cachegrind callgrind massif helgrind lackey none drd exp-bbv exp-ptrcheck";
        COMPREPLY=($(compgen -W "$tools" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    if [[ "${yesno}" == *$prev* ]]; then
        COMPREPLY=($(compgen -W "yes no" -- $cur ));
        COMPREPLY+=" ";
        return 0;
    fi;
    case "$prev" in 
        --log-file)
            _filedir;
            return 0
        ;;
        *)

        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "$opts" -- $cur));
        return 0;
    else
        _filedir;
        return 0;
    fi
}
_variables () 
{ 
    if [[ $cur =~ ^(\$\{?)([A-Za-z0-9_]*)$ ]]; then
        [[ $cur == *{* ]] && local suffix=} || local suffix=;
        COMPREPLY+=($( compgen -P ${BASH_REMATCH[1]} -S "$suffix" -v --             "${BASH_REMATCH[2]}" ));
        return 0;
    fi;
    return 1
}
_virtualenvs () 
{ 
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -W "`virtualenvwrapper_show_workon_options`" -- ${cur}))
}
_xdgopen () 
{ 
    if [ -e "$@" ]; then
        c9 "$@";
        return;
    fi;
    command xdg-open "$@"
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || { 
        local compdir=./completions;
        [[ $BASH_SOURCE == */* ]] && compdir="${BASH_SOURCE%/*}/completions";
        . "$compdir/$srcfile"
    };
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=/etc/xinetd.d;
    if [[ -d $xinetddir ]]; then
        local restore_nullglob=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($( printf '%s\n' $xinetddir/!($_backup_glob) ));
        $restore_nullglob;
        COMPREPLY+=($( compgen -W '${svcs[@]#$xinetddir/}' -- "$cur" ));
    fi
}
add2virtualenv () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    site_packages="`virtualenvwrapper_get_site_packages_dir`";
    if [ ! -d "${site_packages}" ]; then
        echo "ERROR: currently-active virtualenv does not appear to have a site-packages directory" 1>&2;
        return 1;
    fi;
    path_file="$site_packages/_virtualenv_path_extensions.pth";
    if [ "$*" = "" ]; then
        echo "Usage: add2virtualenv dir [dir ...]";
        if [ -f "$path_file" ]; then
            echo;
            echo "Existing paths:";
            cat "$path_file" | grep --color=auto -v "^import";
        fi;
        return 1;
    fi;
    remove=0;
    if [ "$1" = "-d" ]; then
        remove=1;
        shift;
    fi;
    if [ ! -f "$path_file" ]; then
        echo "import sys; sys.__plen = len(sys.path)" > "$path_file" || return 1;
        echo "import sys; new=sys.path[sys.__plen:]; del sys.path[sys.__plen:]; p=getattr(sys,'__egginsert',0); sys.path[p:p]=new; sys.__egginsert = p+len(new)" >> "$path_file" || return 1;
    fi;
    for pydir in "$@";
    do
        absolute_path="$(virtualenvwrapper_absolutepath "$pydir")";
        if [ "$absolute_path" != "$pydir" ]; then
            echo "Warning: Converting \"$pydir\" to \"$absolute_path\"" 1>&2;
        fi;
        if [ $remove -eq 1 ]; then
            sed -i.tmp "\:^$absolute_path$: d" "$path_file";
        else
            sed -i.tmp '1 a\
'"$absolute_path"'
' "$path_file";
        fi;
        rm -f "${path_file}.tmp";
    done;
    return 0
}
allvirtualenv () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    typeset d;
    virtualenvwrapper_show_workon_options | while read d; do
        [ ! -d "$WORKON_HOME/$d" ] && continue;
        echo "$d";
        echo "$d" | sed 's/./=/g';
        ( source "$WORKON_HOME/$d/bin/activate";
        cd "$VIRTUAL_ENV";
        $@ );
        echo;
    done
}
cd () 
{ 
    __zsh_like_cd cd "$@"
}
cdproject () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    if [ -f "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_PROJECT_FILENAME" ]; then
        typeset project_dir="$(cat "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_PROJECT_FILENAME")";
        if [ ! -z "$project_dir" ]; then
            cd "$project_dir";
        else
            echo "Project directory $project_dir does not exist" 1>&2;
            return 1;
        fi;
    else
        echo "No project set in $VIRTUAL_ENV/$VIRTUALENVWRAPPER_PROJECT_FILENAME" 1>&2;
        return 1;
    fi;
    return 0
}
cdsitepackages () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset site_packages="`virtualenvwrapper_get_site_packages_dir`";
    virtualenvwrapper_cd "$site_packages"/$1
}
cdvirtualenv () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    virtualenvwrapper_cd $VIRTUAL_ENV/$1
}
cpvirtualenv () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_virtualenv_clone || return 1;
    typeset src_name="$1";
    typeset trg_name="$2";
    typeset src;
    typeset trg;
    if [ "$src_name" = "" ]; then
        echo "Please provide a valid virtualenv to copy.";
        return 1;
    else
        if [ ! -e "$WORKON_HOME/$src_name" ]; then
            src="$(virtualenvwrapper_expandpath "$src_name")";
            if [ ! -e "$src" ]; then
                echo "Please provide a valid virtualenv to copy.";
                return 1;
            fi;
            src_name="$(basename "$src")";
        else
            src="$WORKON_HOME/$src_name";
        fi;
    fi;
    if [ "$trg_name" = "" ]; then
        trg="$WORKON_HOME/$src_name";
        trg_name="$src_name";
    else
        trg="$WORKON_HOME/$trg_name";
    fi;
    trg="$(virtualenvwrapper_expandpath "$trg")";
    if [ -e "$trg" ]; then
        echo "$trg_name virtualenv already exists.";
        return 1;
    fi;
    echo "Copying $src_name as $trg_name...";
    ( [ -n "$ZSH_VERSION" ] && setopt SH_WORD_SPLIT;
    virtualenvwrapper_cd "$WORKON_HOME" && "$VIRTUALENVWRAPPER_VIRTUALENV_CLONE" "$src" "$trg";
    [ -d "$trg" ] && virtualenvwrapper_run_hook "pre_cpvirtualenv" "$src" "$trg_name" && virtualenvwrapper_run_hook "pre_mkvirtualenv" "$trg_name" );
    typeset RC=$?;
    [ $RC -ne 0 ] && return $RC;
    [ ! -d "$WORKON_HOME/$trg_name" ] && return 1;
    workon "$trg_name";
    virtualenvwrapper_run_hook "post_mkvirtualenv";
    virtualenvwrapper_run_hook "post_cpvirtualenv"
}
deactivate () 
{ 
    typeset env_postdeactivate_hook;
    typeset old_env;
    virtualenvwrapper_run_hook "pre_deactivate";
    env_postdeactivate_hook="$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/postdeactivate";
    old_env=$(basename "$VIRTUAL_ENV");
    virtualenv_deactivate $1;
    virtualenvwrapper_run_hook "post_deactivate" "$old_env";
    if [ ! "$1" = "nondestructive" ]; then
        unset -f virtualenv_deactivate > /dev/null 2>&1;
        unset -f deactivate > /dev/null 2>&1;
    fi
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
file_exists_at_url () 
{ 
    ( if [[ -n "${1:-}" ]]; then
        unset curl;
        file_exists_at_url_command "$1" --insecure || { 
            \typeset __ret=$?;
            case ${__ret} in 
                60)
                    file_exists_at_url_command "$1" || return $?;
                    return 0
                ;;
                *)
                    return ${__ret}
                ;;
            esac
        };
    else
        rvm_warn "Warning: URL was not passed to file_exists_at_url";
        return 1;
    fi )
}
file_exists_at_url_command () 
{ 
    __rvm_curl --silent --insecure --location --list-only --max-time ${rvm_max_time_flag:-5} --head "$@" 2>&1 | __rvm_grep -E 'HTTP/[0-9\.]+ 200 OK' > /dev/null 2>&1 || { 
        \typeset __ret=$?;
        case ${__ret} in 
            28)
                rvm_warn "RVM was not able to check existence of remote files with timeout of ${rvm_max_time_flag:-3} seconds
you can increase the timeout by setting it in ~/.rvmrc => rvm_max_time_flag=10"
            ;;
        esac;
        return ${__ret}
    }
}
gem () 
{ 
    \typeset result;
    ( \typeset rvmrc;
    rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc");
    if [[ -n "${rvm_prefix:-}" ]] && ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]]; then
        rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc");
    fi;
    for rvmrc in "${rvm_rvmrc_files[@]}";
    do
        [[ -s "${rvmrc}" ]] && source "${rvmrc}" || true;
    done;
    unset rvm_rvmrc_files;
    command gem "$@" ) || result=$?;
    hash -r;
    return ${result:-0}
}
gem_install () 
{ 
    \typeset gem_name gem_version version_check;
    gem_version="";
    __rvm_parse_gems_args "$@";
    if [[ -z "${gem_version}" ]]; then
        __rvm_db "gem_${gem_name}_version" "gem_version";
    fi;
    if (( ${rvm_force_flag:-0} == 0 )) && is_gem_installed; then
        rvm_log "gem ${gem_name} ${gem_version:-} is already installed";
        return 0;
    else
        gem_install_force || return $?;
    fi;
    true
}
gem_install_force () 
{ 
    \typeset __available_gem;
    \typeset -a install_params;
    install_params=();
    __available_gem="$( ls -v1 "${rvm_path}/gem-cache"/${gem_name}-${version_check}.gem 2>/dev/null | tail -n 1 )";
    if [[ -n "${__available_gem}" ]]; then
        install_params+=(--local);
    else
        if [[ -n "${gem_version}" ]]; then
            install_params+=(-v "${gem_version}");
        fi;
    fi;
    install_params+=(--no-ri --no-rdoc $rvm_gem_options);
    __rvm_log_command "gem.install.${gem_name}${gem_version:+-}${gem_version:-}" "installing gem ${__available_gem:-${gem_name}} ${install_params[*]}" \command \gem install "${__available_gem:-${gem_name}}" "${install_params[@]}" || return $?
}
gemset_create () 
{ 
    \typeset gem_home gemset gemsets prefix;
    [[ -n "$rvm_ruby_string" ]] || __rvm_select;
    prefix="${rvm_ruby_gem_home%%${rvm_gemset_separator:-"@"}*}";
    for gemset in "$@";
    do
        if [[ -z "$rvm_ruby_string" || "$rvm_ruby_string" == "system" ]]; then
            rvm_error "Can not create gemset when using system ruby.  Try 'rvm use <some ruby>' first.";
            return 1;
        else
            if [[ "$gemset" == *"${rvm_gemset_separator:-"@"}"* ]]; then
                rvm_error "Can not create gemset '$gemset', it contains a \"${rvm_gemset_separator:-"@"}\".";
                return 2;
            else
                if [[ "$gemset" == *"${rvm_gemset_separator:-"@"}" ]]; then
                    rvm_error "Can not create gemset '$gemset', Missing name. ";
                    return 3;
                fi;
            fi;
        fi;
        gem_home="${prefix}${gemset:+${rvm_gemset_separator:-"@"}}${gemset}";
        __rvm_remove_broken_symlinks "$gem_home";
        [[ -d "$gem_home/bin" ]] || mkdir -p "$gem_home/bin";
        : rvm_gems_cache_path:${rvm_gems_cache_path:=${rvm_gems_path:-"$rvm_path/gems"}/cache};
        if __rvm_using_gemset_globalcache; then
            if [[ -d "$gem_home/cache" && ! -L "$gem_home/cache" ]]; then
                \command \mv "$gem_home/cache"/*.gem "$rvm_gems_cache_path/" 2> /dev/null;
            fi;
            __rvm_rm_rf "$gem_home/cache";
            ln -fs "$rvm_gems_cache_path" "$gem_home/cache";
        else
            __rvm_remove_broken_symlinks "$gem_home/cache";
            mkdir -p "$gem_home/cache";
        fi;
        rvm_log "$rvm_ruby_string - #gemset created $gem_home";
        if (( ${rvm_skip_gemsets_flag:-0} == 0 )); then
            __rvm_with "${rvm_ruby_string}${gemset:+@}${gemset}" gemset_initial ${gemset:-default};
        fi;
    done;
    if (( ${rvm_skip_gemsets_flag:-0} != 0 )); then
        rvm_log "Skipped importing default gemsets";
    fi
}
gemset_import () 
{ 
    \typeset __prefix rvm_file_name;
    unset -f gem;
    __rvm_select;
    __prefix="$1";
    if [[ -n "${2:-}" ]]; then
        rvm_file_name="${2%.gems*}.gems";
    else
        \typeset -a gem_file_names;
        gem_file_names=("${rvm_gemset_name}.gems" "default.gems" "system.gems" ".gems");
        __rvm_find_first_file rvm_file_name "${gem_file_names[@]}" || { 
            rvm_error "No *.gems file found.";
            return 1
        };
    fi;
    [[ -d "$rvm_ruby_gem_home/specifications/" ]] || mkdir -p "$rvm_ruby_gem_home/specifications/";
    [[ -d "$rvm_gems_cache_path" ]] || mkdir -p "$rvm_gems_cache_path";
    \typeset -a lines;
    lines=();
    if [[ -s "$rvm_file_name" ]]; then
        __rvm_read_lines lines "${rvm_file_name}";
        __rvm_lines_without_comments;
    fi;
    rvm_debug "lines from ${rvm_file_name}: ${lines[*]}";
    if [[ -n "${3:-}" ]]; then
        __rvm_lines_without_gems;
        __rvm_lines_with_gems "${3}";
        rvm_debug "recalculated lines($3): ${lines[*]}";
    fi;
    if (( ${#lines[@]} )); then
        __rvm_log_command "gemsets.import${3:+.}${3:-}" "${__prefix} $rvm_file_name" gemset_import_list "${lines[@]}";
    else
        rvm_log "${__prefix}file $rvm_file_name evaluated to empty gem list";
    fi
}
gemset_import_list () 
{ 
    case "${rvm_ruby_string}" in 
        *jruby*)
            \command \gem install "$@"
        ;;
        *)
            \typeset line;
            for line in "$@";
            do
                gem_install $line || rvm_error "there was an error installing gem $line";
            done
        ;;
    esac
}
gemset_initial () 
{ 
    \typeset gemsets gemset _iterator paths;
    true ${rvm_gemsets_path:="$rvm_path/gemsets"};
    [[ -d "$rvm_gems_path/${rvm_ruby_string}/cache" ]] || mkdir -p "$rvm_gems_path/${rvm_ruby_string}/cache" 2> /dev/null;
    __rvm_ensure_has_environment_files;
    paths=($( __rvm_ruby_string_paths_under "$rvm_gemsets_path" | sort -r ));
    for _iterator in "${paths[@]}";
    do
        if [[ -f "${_iterator}/$1.gems" ]]; then
            gemset_import "$rvm_ruby_string - #importing gemset" "${_iterator}/$1.gems" "$1";
            break;
        else
            rvm_debug "$rvm_ruby_string - #gemset definition does not exist ${_iterator}/$1.gems";
        fi;
    done;
    __rvm_log_command "gemset.wrappers.$1" "$rvm_ruby_string - #generating ${1} wrappers" run_gem_wrappers_regenerate 2> /dev/null || true
}
gemset_pristine () 
{ 
    if ( unset -f gem;
    builtin command -v gem > /dev/null ); then
        \typeset _gem _version _platforms;
        \typeset -a _failed _pristine_command;
        _failed=();
        _pristine_command=(\command \gem pristine);
        if __rvm_version_compare "$(\command \gem --version)" -ge 2.2.0; then
            _pristine_command+=(--extensions);
        fi;
        rvm_log "Restoring gems to pristine condition...";
        while read _gem _version _platforms; do
            printf "%b" "${_gem}-${_version} ";
            "${_pristine_command[@]}" "${_gem}" --version "${_version}" > /dev/null || _failed+=("${_gem} --version ${_version}");
        done <<< "$(
      GEM_PATH="$GEM_HOME" __rvm_list_gems         "${pristine_gems_filter:-"! gem.executables.empty? || ! gem.extensions.empty?"}"
    )";
        if (( ${#_failed[@]} > 0 )); then
            rvm_error "\n'${_pristine_command[*]} ${_failed[*]}' failed, you need to fix this gems manually.";
            return 1;
        else
            rvm_log "\nfinished.";
        fi;
    else
        rvm_error "'gem' command not found in PATH.";
        return 1;
    fi
}
gemset_reset_env () 
{ 
    ( export rvm_internal_use_flag=1;
    export rvm_use_flag=0;
    __rvm_use "${1:-}";
    __rvm_ensure_has_environment_files && run_gem_wrappers_regenerate )
}
iojs_version_has_solaris_binary () 
{ 
    local IOJS_VERSION;
    IOJS_VERSION="$1";
    local STRIPPED_IOJS_VERSION;
    STRIPPED_IOJS_VERSION="$(nvm_strip_iojs_prefix "$IOJS_VERSION")";
    if [ "_$STRIPPED_IOJS_VERSION" = "$IOJS_VERSION" ]; then
        return 1;
    fi;
    nvm_version_greater_than_or_equal_to "$STRIPPED_IOJS_VERSION" v3.3.1
}
is_a_function () 
{ 
    \typeset -f $1 > /dev/null 2>&1 || return $?
}
is_gem_installed () 
{ 
    \typeset gem_spec;
    gem_spec="gem '$gem_name'";
    if [[ -n "${gem_version}" ]]; then
        gem_spec+=", '$gem_version'";
        version_check="${gem_version#*=}";
    else
        version_check="*([[:digit:]\.])";
    fi;
    ls -ld "${rvm_ruby_gem_home}/gems"/${gem_name}-${version_check} > /dev/null 2>&1 || "${rvm_ruby_binary}" -rrubygems -e "$gem_spec" 2> /dev/null || return $?
}
is_parent_of () 
{ 
    \typeset name pid ppid pname;
    name=$1;
    pid=$2;
    while [[ -n "$pid" && "$pid" != "0" ]]; do
        case "`uname`" in 
            SunOS)
                read ppid pname <<< "$(\command \ps -p $pid -o ppid= -o comm=)"
            ;;
            *)
                read ppid pname <<< "$(\command \ps -p $pid -o ppid= -o ucomm=)"
            ;;
        esac;
        if [[ -n "$ppid" && -n "$pname" ]]; then
            if [[ "$pname" == "$name" ]]; then
                echo $pid;
                return 0;
            else
                pid=$ppid;
            fi;
        else
            break;
        fi;
    done;
    return 1
}
load_rvm_scripts () 
{ 
    \typeset -a scripts;
    scripts=(selector logging support utility init cleanup env rvmrc install environment gemset checksum list);
    source "${rvm_scripts_path}/initialize";
    for entry in ${scripts[@]};
    do
        [[ " ${rvm_base_except:-} " == *" $entry "* ]] || source "${rvm_scripts_path}/functions/$entry" || return $?;
    done;
    unset rvm_base_except
}
lssitepackages () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset site_packages="`virtualenvwrapper_get_site_packages_dir`";
    ls --color=auto -F $@ "$site_packages";
    path_file="$site_packages/_virtualenv_path_extensions.pth";
    if [ -f "$path_file" ]; then
        echo;
        echo "_virtualenv_path_extensions.pth:";
        cat "$path_file";
    fi
}
lsvirtualenv () 
{ 
    typeset long_mode=true;
    if command -v "getopts" &> /dev/null; then
        OPTIND=1;
        while getopts ":blh" opt "$@"; do
            case "$opt" in 
                l)
                    long_mode=true
                ;;
                b)
                    long_mode=false
                ;;
                h)
                    _lsvirtualenv_usage;
                    return 1
                ;;
                ?)
                    echo "Invalid option: -$OPTARG" 1>&2;
                    _lsvirtualenv_usage;
                    return 1
                ;;
            esac;
        done;
    else
        typeset -a args;
        args=($(getopt blh "$@"));
        if [ $? != 0 ]; then
            _lsvirtualenv_usage;
            return 1;
        fi;
        for opt in $args;
        do
            case "$opt" in 
                -l)
                    long_mode=true
                ;;
                -b)
                    long_mode=false
                ;;
                -h)
                    _lsvirtualenv_usage;
                    return 1
                ;;
            esac;
        done;
    fi;
    if $long_mode; then
        allvirtualenv showvirtualenv "$env_name";
    else
        virtualenvwrapper_show_workon_options;
    fi
}
mkproject () 
{ 
    typeset -a in_args;
    typeset -a out_args;
    typeset -i i;
    typeset tst;
    typeset a;
    typeset t;
    typeset templates;
    in_args=("$@");
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in 
            -h | --help)
                virtualenvwrapper_mkproject_help;
                return
            ;;
            -t)
                i=$(( $i + 1 ));
                templates="$templates ${in_args[$i]}"
            ;;
            *)
                if [ ${#out_args} -gt 0 ]; then
                    out_args=("${out_args[@]-}" "$a");
                else
                    out_args=("$a");
                fi
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    set -- "${out_args[@]}";
    eval "typeset envname=\$$#";
    virtualenvwrapper_verify_project_home || return 1;
    if [ -d "$PROJECT_HOME/$envname" ]; then
        echo "Project $envname already exists." 1>&2;
        return 1;
    fi;
    mkvirtualenv "$@" || return 1;
    cd "$PROJECT_HOME";
    virtualenvwrapper_run_hook "project.pre_mkproject" $envname;
    echo "Creating $PROJECT_HOME/$envname";
    mkdir -p "$PROJECT_HOME/$envname";
    setvirtualenvproject "$VIRTUAL_ENV" "$PROJECT_HOME/$envname";
    cd "$PROJECT_HOME/$envname";
    for t in $templates;
    do
        echo;
        echo "Applying template $t";
        virtualenvwrapper_run_hook --name $(echo $t | sed 's/^ //') "project.template" "$envname" "$PROJECT_HOME/$envname";
    done;
    virtualenvwrapper_run_hook "project.post_mkproject"
}
mktmpenv () 
{ 
    typeset tmpenvname;
    typeset RC;
    tmpenvname=$("$VIRTUALENVWRAPPER_PYTHON" -c 'import uuid,sys; sys.stdout.write(uuid.uuid4()+"\n")' 2>/dev/null);
    if [ -z "$tmpenvname" ]; then
        tmpenvname=$("$VIRTUALENVWRAPPER_PYTHON" -c 'import random,sys; sys.stdout.write(hex(random.getrandbits(64))[2:-1]+"\n")' 2>/dev/null);
    fi;
    mkvirtualenv "$@" "$tmpenvname";
    RC=$?;
    if [ $RC -ne 0 ]; then
        return $RC;
    fi;
    cdvirtualenv;
    echo "This is a temporary environment. It will be deleted when you run 'deactivate'." | tee "$VIRTUAL_ENV/README.tmpenv";
    cat - >> "$VIRTUAL_ENV/bin/postdeactivate"  <<EOF
if [ -f "$VIRTUAL_ENV/README.tmpenv" ]
then
    echo "Removing temporary environment:" $(basename "$VIRTUAL_ENV")
    rmvirtualenv $(basename "$VIRTUAL_ENV")
fi
EOF

}
mkvirtualenv () 
{ 
    typeset -a in_args;
    typeset -a out_args;
    typeset -i i;
    typeset tst;
    typeset a;
    typeset envname;
    typeset requirements;
    typeset packages;
    typeset interpreter;
    in_args=("$@");
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in 
            -a)
                i=$(( $i + 1 ));
                project="${in_args[$i]}"
            ;;
            -h | --help)
                virtualenvwrapper_mkvirtualenv_help $a;
                return
            ;;
            -i)
                i=$(( $i + 1 ));
                packages="$packages ${in_args[$i]}"
            ;;
            -p | --python*)
                if echo "$a" | grep --color=auto -q "="; then
                    interpreter="$(echo "$a" | cut -f2 -d=)";
                else
                    i=$(( $i + 1 ));
                    interpreter="${in_args[$i]}";
                fi;
                interpreter="$(virtualenvwrapper_absolutepath "$interpreter")"
            ;;
            -r)
                i=$(( $i + 1 ));
                requirements="${in_args[$i]}";
                requirements="$(virtualenvwrapper_expandpath "$requirements")"
            ;;
            *)
                if [ ${#out_args} -gt 0 ]; then
                    out_args=("${out_args[@]-}" "$a");
                else
                    out_args=("$a");
                fi
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    if [ ! -z $interpreter ]; then
        out_args=("--python=$interpreter" ${out_args[@]});
    fi;
    set -- "${out_args[@]}";
    eval "envname=\$$#";
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_virtualenv || return 1;
    ( [ -n "$ZSH_VERSION" ] && setopt SH_WORD_SPLIT;
    virtualenvwrapper_cd "$WORKON_HOME" && "$VIRTUALENVWRAPPER_VIRTUALENV" $VIRTUALENVWRAPPER_VIRTUALENV_ARGS "$@" && [ -d "$WORKON_HOME/$envname" ] && virtualenvwrapper_run_hook "pre_mkvirtualenv" "$envname" );
    typeset RC=$?;
    [ $RC -ne 0 ] && return $RC;
    [ ! -d "$WORKON_HOME/$envname" ] && return 0;
    if [ ! -z "$project" ]; then
        setvirtualenvproject "$WORKON_HOME/$envname" "$project";
    fi;
    workon "$envname";
    if [ ! -z "$requirements" ]; then
        pip install -r "$requirements";
    fi;
    for a in $packages;
    do
        pip install $a;
    done;
    virtualenvwrapper_run_hook "post_mkvirtualenv"
}
node_version_has_solaris_binary () 
{ 
    local NODE_VERSION;
    NODE_VERSION="$1";
    local STRIPPED_IOJS_VERSION;
    STRIPPED_IOJS_VERSION="$(nvm_strip_iojs_prefix "$NODE_VERSION")";
    if [ "_$STRIPPED_IOJS_VERSION" != "_$NODE_VERSION" ]; then
        return 1;
    fi;
    nvm_version_greater_than_or_equal_to "$NODE_VERSION" v0.8.6 && ! nvm_version_greater_than_or_equal_to "$NODE_VERSION" v1.0.0
}
nvm () 
{ 
    if [ $# -lt 1 ]; then
        nvm help;
        return;
    fi;
    local GREP_OPTIONS;
    GREP_OPTIONS='';
    local VERSION;
    local ADDITIONAL_PARAMETERS;
    local ALIAS;
    case $1 in 
        "help")
            local NVM_IOJS_PREFIX;
            NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
            local NVM_NODE_PREFIX;
            NVM_NODE_PREFIX="$(nvm_node_prefix)";
            echo;
            echo "Node Version Manager";
            echo;
            echo 'Note: <version> refers to any version-like string nvm understands. This includes:';
            echo '  - full or partial version numbers, starting with an optional "v" (0.10, v0.1.2, v1)';
            echo "  - default (built-in) aliases: $NVM_NODE_PREFIX, stable, unstable, $NVM_IOJS_PREFIX, system";
            echo '  - custom aliases you define with `nvm alias foo`';
            echo;
            echo 'Usage:';
            echo '  nvm help                                  Show this message';
            echo '  nvm --version                             Print out the latest released version of nvm';
            echo '  nvm install [-s] <version>                Download and install a <version>, [-s] from source. Uses .nvmrc if available';
            echo '    --reinstall-packages-from=<version>     When installing, reinstall packages installed in <node|iojs|node version number>';
            echo '  nvm uninstall <version>                   Uninstall a version';
            echo '  nvm use [--silent] <version>              Modify PATH to use <version>. Uses .nvmrc if available';
            echo '  nvm exec [--silent] <version> [<command>] Run <command> on <version>. Uses .nvmrc if available';
            echo '  nvm run [--silent] <version> [<args>]     Run `node` on <version> with <args> as arguments. Uses .nvmrc if available';
            echo '  nvm current                               Display currently activated version';
            echo '  nvm ls                                    List installed versions';
            echo '  nvm ls <version>                          List versions matching a given description';
            echo '  nvm ls-remote                             List remote versions available for install';
            echo '  nvm version <version>                     Resolve the given description to a single local version';
            echo '  nvm version-remote <version>              Resolve the given description to a single remote version';
            echo '  nvm deactivate                            Undo effects of `nvm` on current shell';
            echo '  nvm alias [<pattern>]                     Show all aliases beginning with <pattern>';
            echo '  nvm alias <name> <version>                Set an alias named <name> pointing to <version>';
            echo '  nvm unalias <name>                        Deletes the alias named <name>';
            echo '  nvm reinstall-packages <version>          Reinstall global `npm` packages contained in <version> to current version';
            echo '  nvm unload                                Unload `nvm` from shell';
            echo '  nvm which [<version>]                     Display path to installed node version. Uses .nvmrc if available';
            echo;
            echo 'Example:';
            echo '  nvm install v0.10.32                  Install a specific version number';
            echo '  nvm use 0.10                          Use the latest available 0.10.x release';
            echo '  nvm run 0.10.32 app.js                Run app.js using node v0.10.32';
            echo '  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32';
            echo '  nvm alias default 0.10.32             Set default node version on a shell';
            echo;
            echo 'Note:';
            echo '  to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)';
            echo
        ;;
        "debug")
            local ZHS_HAS_SHWORDSPLIT_UNSET;
            ZHS_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
                setopt shwordsplit;
            fi;
            echo "nvm --version: v$(nvm --version)" 1>&2;
            echo "\$SHELL: $SHELL" 1>&2;
            echo "\$HOME: $HOME" 1>&2;
            echo "\$NVM_DIR: '$(nvm_sanitize_path "$NVM_DIR")'" 1>&2;
            echo "\$PREFIX: '$(nvm_sanitize_path "$PREFIX")'" 1>&2;
            echo "\$NPM_CONFIG_PREFIX: '$(nvm_sanitize_path "$NPM_CONFIG_PREFIX")'" 1>&2;
            local NVM_DEBUG_OUTPUT;
            for NVM_DEBUG_COMMAND in 'nvm current' 'which node' 'which iojs' 'which npm' 'npm config get prefix' 'npm root -g';
            do
                NVM_DEBUG_OUTPUT="$($NVM_DEBUG_COMMAND 2>&1)";
                echo "$NVM_DEBUG_COMMAND: $(nvm_sanitize_path "$NVM_DEBUG_OUTPUT")" 1>&2;
            done;
            if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi;
            return 42
        ;;
        "install" | "i")
            local version_not_provided;
            version_not_provided=0;
            local NVM_OS;
            NVM_OS="$(nvm_get_os)";
            if ! nvm_has "curl" && ! nvm_has "wget"; then
                echo 'nvm needs curl or wget to proceed.' 1>&2;
                return 1;
            fi;
            if [ $# -lt 2 ]; then
                version_not_provided=1;
                nvm_rc_version;
                if [ -z "$NVM_RC_VERSION" ]; then
                    nvm help 1>&2;
                    return 127;
                fi;
            fi;
            shift;
            local nobinary;
            nobinary=0;
            local make_jobs;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    -s)
                        shift;
                        nobinary=1
                    ;;
                    -j)
                        shift;
                        nvm_get_make_jobs "$1";
                        shift
                    ;;
                    *)
                        break
                    ;;
                esac;
            done;
            local provided_version;
            provided_version="$1";
            if [ -z "$provided_version" ]; then
                if [ $version_not_provided -ne 1 ]; then
                    nvm_rc_version;
                fi;
                provided_version="$NVM_RC_VERSION";
            else
                shift;
            fi;
            VERSION="$(nvm_remote_version "$provided_version")";
            if [ "_$VERSION" = "_N/A" ]; then
                echo "Version '$provided_version' not found - try \`nvm ls-remote\` to browse available versions." 1>&2;
                return 3;
            fi;
            ADDITIONAL_PARAMETERS='';
            local PROVIDED_REINSTALL_PACKAGES_FROM;
            local REINSTALL_PACKAGES_FROM;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    --reinstall-packages-from=*)
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(echo "$1" | command cut -c 27-)";
                        REINSTALL_PACKAGES_FROM="$(nvm_version "$PROVIDED_REINSTALL_PACKAGES_FROM")"
                    ;;
                    --copy-packages-from=*)
                        PROVIDED_REINSTALL_PACKAGES_FROM="$(echo "$1" | command cut -c 22-)";
                        REINSTALL_PACKAGES_FROM="$(nvm_version "$PROVIDED_REINSTALL_PACKAGES_FROM")"
                    ;;
                    *)
                        ADDITIONAL_PARAMETERS="$ADDITIONAL_PARAMETERS $1"
                    ;;
                esac;
                shift;
            done;
            if [ "_$(nvm_ensure_version_prefix "$PROVIDED_REINSTALL_PACKAGES_FROM")" = "_$VERSION" ]; then
                echo "You can't reinstall global packages from the same version of node you're installing." 1>&2;
                return 4;
            else
                if [ ! -z "$PROVIDED_REINSTALL_PACKAGES_FROM" ] && [ "_$REINSTALL_PACKAGES_FROM" = "_N/A" ]; then
                    echo "If --reinstall-packages-from is provided, it must point to an installed version of node." 1>&2;
                    return 5;
                fi;
            fi;
            local NVM_NODE_MERGED;
            local NVM_IOJS;
            if nvm_is_iojs_version "$VERSION"; then
                NVM_IOJS=true;
            else
                if nvm_is_merged_node_version "$VERSION"; then
                    NVM_NODE_MERGED=true;
                fi;
            fi;
            local VERSION_PATH;
            VERSION_PATH="$(nvm_version_path "$VERSION")";
            if [ -d "$VERSION_PATH" ]; then
                echo "$VERSION is already installed." 1>&2;
                if nvm use "$VERSION" && [ ! -z "$REINSTALL_PACKAGES_FROM" ] && [ "_$REINSTALL_PACKAGES_FROM" != "_N/A" ]; then
                    nvm reinstall-packages "$REINSTALL_PACKAGES_FROM";
                fi;
                nvm_ensure_default_set "$provided_version";
                return $?;
            fi;
            if [ "_$NVM_OS" = "_freebsd" ]; then
                nobinary=1;
                echo "Currently, there is no binary for $NVM_OS" 1>&2;
            else
                if [ "_$NVM_OS" = "_sunos" ]; then
                    if ! nvm_has_solaris_binary "$VERSION"; then
                        nobinary=1;
                        echo "Currently, there is no binary of version $VERSION for $NVM_OS" 1>&2;
                    fi;
                fi;
            fi;
            local NVM_INSTALL_SUCCESS;
            if [ $nobinary -ne 1 ] && nvm_binary_available "$VERSION"; then
                if [ "$NVM_IOJS" = true ] && nvm_install_iojs_binary std "$VERSION" "$REINSTALL_PACKAGES_FROM"; then
                    NVM_INSTALL_SUCCESS=true;
                else
                    if [ "$NVM_NODE_MERGED" = true ] && nvm_install_merged_node_binary std "$VERSION" "$REINSTALL_PACKAGES_FROM"; then
                        NVM_INSTALL_SUCCESS=true;
                    else
                        if [ "$NVM_IOJS" != true ] && nvm_install_node_binary "$VERSION" "$REINSTALL_PACKAGES_FROM"; then
                            NVM_INSTALL_SUCCESS=true;
                        fi;
                    fi;
                fi;
            fi;
            if [ "$NVM_INSTALL_SUCCESS" != true ]; then
                if [ -z "${NVM_MAKE_JOBS-}" ]; then
                    nvm_get_make_jobs;
                fi;
                if [ "$NVM_IOJS" != true ] && [ "$NVM_NODE_MERGED" != true ]; then
                    if nvm_install_node_source "$VERSION" "$NVM_MAKE_JOBS" "$ADDITIONAL_PARAMETERS"; then
                        NVM_INSTALL_SUCCESS=true;
                    fi;
                else
                    if [ "$NVM_IOJS" = true ]; then
                        echo "Installing iojs from source is not currently supported" 1>&2;
                        return 105;
                    else
                        if [ "$NVM_NODE_MERGED" = true ]; then
                            echo "Installing node v1.0 and greater from source is not currently supported" 1>&2;
                            return 106;
                        fi;
                    fi;
                fi;
            fi;
            if [ "$NVM_INSTALL_SUCCESS" = true ] && nvm use "$VERSION"; then
                nvm_ensure_default_set "$provided_version";
                if [ ! -z "$REINSTALL_PACKAGES_FROM" ] && [ "_$REINSTALL_PACKAGES_FROM" != "_N/A" ]; then
                    nvm reinstall-packages "$REINSTALL_PACKAGES_FROM";
                fi;
            fi;
            return $?
        ;;
        "uninstall")
            if [ $# -ne 2 ]; then
                nvm help 1>&2;
                return 127;
            fi;
            local PATTERN;
            PATTERN="$2";
            case "_$PATTERN" in 
                "_$(nvm_iojs_prefix)" | "_$(nvm_iojs_prefix)-" | "_$(nvm_node_prefix)" | "_$(nvm_node_prefix)-")
                    VERSION="$(nvm_version "$PATTERN")"
                ;;
                *)
                    VERSION="$(nvm_version "$PATTERN")"
                ;;
            esac;
            if [ "_$VERSION" = "_$(nvm_ls_current)" ]; then
                if nvm_is_iojs_version "$VERSION"; then
                    echo "nvm: Cannot uninstall currently-active io.js version, $VERSION (inferred from $PATTERN)." 1>&2;
                else
                    echo "nvm: Cannot uninstall currently-active node version, $VERSION (inferred from $PATTERN)." 1>&2;
                fi;
                return 1;
            fi;
            local VERSION_PATH;
            VERSION_PATH="$(nvm_version_path "$VERSION")";
            if [ ! -d "$VERSION_PATH" ]; then
                echo "$VERSION version is not installed..." 1>&2;
                return;
            fi;
            t="$VERSION-$(nvm_get_os)-$(nvm_get_arch)";
            local NVM_PREFIX;
            local NVM_SUCCESS_MSG;
            if nvm_is_iojs_version "$VERSION"; then
                NVM_PREFIX="$(nvm_iojs_prefix)";
                NVM_SUCCESS_MSG="Uninstalled io.js $(nvm_strip_iojs_prefix "$VERSION")";
            else
                NVM_PREFIX="$(nvm_node_prefix)";
                NVM_SUCCESS_MSG="Uninstalled node $VERSION";
            fi;
            command rm -rf "$NVM_DIR/src/$NVM_PREFIX-$VERSION" "$NVM_DIR/src/$NVM_PREFIX-$VERSION.tar.*" "$NVM_DIR/bin/$NVM_PREFIX-${t}" "$NVM_DIR/bin/$NVM_PREFIX-${t}.tar.*" "$VERSION_PATH" 2> /dev/null;
            echo "$NVM_SUCCESS_MSG";
            for ALIAS in $(command grep -l "$VERSION" "$(nvm_alias_path)/*" 2>/dev/null);
            do
                nvm unalias "$(command basename "$ALIAS")";
            done
        ;;
        "deactivate")
            local NEWPATH;
            NEWPATH="$(nvm_strip_path "$PATH" "/bin")";
            if [ "_$PATH" = "_$NEWPATH" ]; then
                echo "Could not find $NVM_DIR/*/bin in \$PATH" 1>&2;
            else
                export PATH="$NEWPATH";
                hash -r;
                echo "$NVM_DIR/*/bin removed from \$PATH";
            fi;
            if [ -n "${MANPATH-}" ]; then
                NEWPATH="$(nvm_strip_path "$MANPATH" "/share/man")";
                if [ "_$MANPATH" = "_$NEWPATH" ]; then
                    echo "Could not find $NVM_DIR/*/share/man in \$MANPATH" 1>&2;
                else
                    export MANPATH="$NEWPATH";
                    echo "$NVM_DIR/*/share/man removed from \$MANPATH";
                fi;
            fi;
            if [ -n "${NODE_PATH-}" ]; then
                NEWPATH="$(nvm_strip_path "$NODE_PATH" "/lib/node_modules")";
                if [ "_$NODE_PATH" != "_$NEWPATH" ]; then
                    export NODE_PATH="$NEWPATH";
                    echo "$NVM_DIR/*/lib/node_modules removed from \$NODE_PATH";
                fi;
            fi
        ;;
        "use")
            local PROVIDED_VERSION;
            local NVM_USE_SILENT;
            NVM_USE_SILENT=0;
            local NVM_DELETE_PREFIX;
            NVM_DELETE_PREFIX=0;
            shift;
            while [ $# -ne 0 ]; do
                case "$1" in 
                    --silent)
                        NVM_USE_SILENT=1
                    ;;
                    --delete-prefix)
                        NVM_DELETE_PREFIX=1
                    ;;
                    *)
                        if [ -n "$1" ]; then
                            PROVIDED_VERSION="$1";
                        fi
                    ;;
                esac;
                shift;
            done;
            if [ -z "$PROVIDED_VERSION" ]; then
                nvm_rc_version;
                if [ -n "$NVM_RC_VERSION" ]; then
                    PROVIDED_VERSION="$NVM_RC_VERSION";
                    VERSION="$(nvm_version "$PROVIDED_VERSION")";
                fi;
            else
                VERSION="$(nvm_match_version "$PROVIDED_VERSION")";
            fi;
            if [ -z "$VERSION" ]; then
                nvm help 1>&2;
                return 127;
            fi;
            if [ "_$VERSION" = '_system' ]; then
                if nvm_has_system_node && nvm deactivate > /dev/null 2>&1; then
                    if [ $NVM_USE_SILENT -ne 1 ]; then
                        echo "Now using system version of node: $(node -v 2>/dev/null)$(nvm_print_npm_version)";
                    fi;
                    return;
                else
                    if nvm_has_system_iojs && nvm deactivate > /dev/null 2>&1; then
                        if [ $NVM_USE_SILENT -ne 1 ]; then
                            echo "Now using system version of io.js: $(iojs --version 2>/dev/null)$(nvm_print_npm_version)";
                        fi;
                        return;
                    else
                        if [ $NVM_USE_SILENT -ne 1 ]; then
                            echo "System version of node not found." 1>&2;
                        fi;
                        return 127;
                    fi;
                fi;
            else
                if [ "_$VERSION" = "_" ]; then
                    if [ $NVM_USE_SILENT -ne 1 ]; then
                        echo "The alias \"$PROVIDED_VERSION\" leads to an infinite loop. Aborting." 1>&2;
                    fi;
                    return 8;
                fi;
            fi;
            nvm_ensure_version_installed "$PROVIDED_VERSION";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" != "0" ]; then
                return $EXIT_CODE;
            fi;
            local NVM_VERSION_DIR;
            NVM_VERSION_DIR="$(nvm_version_path "$VERSION")";
            PATH="$(nvm_strip_path "$PATH" "/bin")";
            PATH="$(nvm_prepend_path "$PATH" "$NVM_VERSION_DIR/bin")";
            if nvm_has manpath; then
                if [ -z "$MANPATH" ]; then
                    MANPATH=$(manpath);
                fi;
                MANPATH="$(nvm_strip_path "$MANPATH" "/share/man")";
                MANPATH="$(nvm_prepend_path "$MANPATH" "$NVM_VERSION_DIR/share/man")";
                export MANPATH;
            fi;
            export PATH;
            hash -r;
            export NVM_PATH="$NVM_VERSION_DIR/lib/node";
            export NVM_BIN="$NVM_VERSION_DIR/bin";
            if [ "${NVM_SYMLINK_CURRENT-}" = true ]; then
                command rm -f "$NVM_DIR/current" && ln -s "$NVM_VERSION_DIR" "$NVM_DIR/current";
            fi;
            local NVM_USE_OUTPUT;
            if [ $NVM_USE_SILENT -ne 1 ]; then
                if nvm_is_iojs_version "$VERSION"; then
                    NVM_USE_OUTPUT="Now using io.js $(nvm_strip_iojs_prefix "$VERSION")$(nvm_print_npm_version)";
                else
                    NVM_USE_OUTPUT="Now using node $VERSION$(nvm_print_npm_version)";
                fi;
            fi;
            if [ "_$VERSION" != "_system" ]; then
                local NVM_USE_CMD;
                NVM_USE_CMD="nvm use --delete-prefix";
                if [ -n "$PROVIDED_VERSION" ]; then
                    NVM_USE_CMD="$NVM_USE_CMD $VERSION";
                fi;
                if [ $NVM_USE_SILENT -eq 1 ]; then
                    NVM_USE_CMD="$NVM_USE_CMD --silent";
                fi;
                if ! nvm_die_on_prefix "$NVM_DELETE_PREFIX" "$NVM_USE_CMD"; then
                    return 11;
                fi;
            fi;
            if [ -n "$NVM_USE_OUTPUT" ]; then
                echo "$NVM_USE_OUTPUT";
            fi
        ;;
        "run")
            local provided_version;
            local has_checked_nvmrc;
            has_checked_nvmrc=0;
            shift;
            local NVM_SILENT;
            NVM_SILENT=0;
            if [ "_$1" = "_--silent" ]; then
                NVM_SILENT=1;
                shift;
            fi;
            if [ $# -lt 1 ]; then
                if [ "$NVM_SILENT" -eq 1 ]; then
                    nvm_rc_version > /dev/null 2>&1 && has_checked_nvmrc=1;
                else
                    nvm_rc_version && has_checked_nvmrc=1;
                fi;
                if [ -n "$NVM_RC_VERSION" ]; then
                    VERSION="$(nvm_version "$NVM_RC_VERSION")";
                else
                    VERSION='N/A';
                fi;
                if [ $VERSION = "N/A" ]; then
                    nvm help 1>&2;
                    return 127;
                fi;
            fi;
            provided_version="$1";
            if [ -n "$provided_version" ]; then
                VERSION="$(nvm_version "$provided_version")";
                if [ "_$VERSION" = "_N/A" ] && ! nvm_is_valid_version "$provided_version"; then
                    provided_version='';
                    if [ $has_checked_nvmrc -ne 1 ]; then
                        if [ "$NVM_SILENT" -eq 1 ]; then
                            nvm_rc_version > /dev/null 2>&1 && has_checked_nvmrc=1;
                        else
                            nvm_rc_version && has_checked_nvmrc=1;
                        fi;
                    fi;
                    VERSION="$(nvm_version "$NVM_RC_VERSION")";
                else
                    shift;
                fi;
            fi;
            local NVM_IOJS;
            if nvm_is_iojs_version "$VERSION"; then
                NVM_IOJS=true;
            fi;
            local ARGS;
            ARGS="$@";
            local OUTPUT;
            local EXIT_CODE;
            local ZHS_HAS_SHWORDSPLIT_UNSET;
            ZHS_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
                setopt shwordsplit;
            fi;
            if [ "_$VERSION" = "_N/A" ]; then
                nvm_ensure_version_installed "$provided_version";
                EXIT_CODE=$?;
            else
                if [ -z "$ARGS" ]; then
                    if [ "$NVM_IOJS" = true ]; then
                        nvm exec "$VERSION" iojs;
                    else
                        nvm exec "$VERSION" node;
                    fi;
                    EXIT_CODE="$?";
                else
                    if [ "$NVM_IOJS" = true ]; then
                        [ $NVM_SILENT -eq 1 ] || echo "Running io.js $(nvm_strip_iojs_prefix "$VERSION")$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
                        OUTPUT="$(nvm use "$VERSION" >/dev/null && iojs $ARGS)";
                        EXIT_CODE="$?";
                    else
                        [ $NVM_SILENT -eq 1 ] || echo "Running node $VERSION$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
                        OUTPUT="$(nvm use "$VERSION" >/dev/null && node $ARGS)";
                        EXIT_CODE="$?";
                    fi;
                fi;
            fi;
            if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi;
            if [ -n "$OUTPUT" ]; then
                echo "$OUTPUT";
            fi;
            return $EXIT_CODE
        ;;
        "exec")
            shift;
            local NVM_SILENT;
            NVM_SILENT=0;
            if [ "_$1" = "_--silent" ]; then
                NVM_SILENT=1;
                shift;
            fi;
            local provided_version;
            provided_version="$1";
            if [ -n "$provided_version" ]; then
                VERSION="$(nvm_version "$provided_version")";
                if [ "_$VERSION" = "_N/A" ] && ! nvm_is_valid_version "$provided_version"; then
                    if [ "$NVM_SILENT" -eq 1 ]; then
                        nvm_rc_version > /dev/null 2>&1;
                    else
                        nvm_rc_version;
                    fi;
                    provided_version="$NVM_RC_VERSION";
                    VERSION="$(nvm_version "$provided_version")";
                else
                    shift;
                fi;
            fi;
            nvm_ensure_version_installed "$provided_version";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" != "0" ]; then
                return $EXIT_CODE;
            fi;
            [ $NVM_SILENT -eq 1 ] || echo "Running node $VERSION$(nvm use --silent "$VERSION" && nvm_print_npm_version)";
            NODE_VERSION="$VERSION" "$NVM_DIR/nvm-exec" "$@"
        ;;
        "ls" | "list")
            local NVM_LS_OUTPUT;
            local NVM_LS_EXIT_CODE;
            NVM_LS_OUTPUT=$(nvm_ls "${2-}");
            NVM_LS_EXIT_CODE=$?;
            nvm_print_versions "$NVM_LS_OUTPUT";
            if [ $# -eq 1 ]; then
                nvm alias;
            fi;
            return $NVM_LS_EXIT_CODE
        ;;
        "ls-remote" | "list-remote")
            local PATTERN;
            PATTERN="${2-}";
            local NVM_IOJS_PREFIX;
            NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
            local NVM_NODE_PREFIX;
            NVM_NODE_PREFIX="$(nvm_node_prefix)";
            local NVM_FLAVOR;
            case "_$PATTERN" in 
                "_$NVM_IOJS_PREFIX" | "_$NVM_NODE_PREFIX")
                    NVM_FLAVOR="$PATTERN";
                    PATTERN="$3"
                ;;
            esac;
            local NVM_LS_REMOTE_EXIT_CODE;
            NVM_LS_REMOTE_EXIT_CODE=0;
            local NVM_LS_REMOTE_PRE_MERGED_OUTPUT;
            NVM_LS_REMOTE_PRE_MERGED_OUTPUT='';
            local NVM_LS_REMOTE_POST_MERGED_OUTPUT;
            NVM_LS_REMOTE_POST_MERGED_OUTPUT='';
            if [ "_$NVM_FLAVOR" != "_$NVM_IOJS_PREFIX" ]; then
                local NVM_LS_REMOTE_OUTPUT;
                NVM_LS_REMOTE_OUTPUT=$(nvm_ls_remote "$PATTERN");
                NVM_LS_REMOTE_PRE_MERGED_OUTPUT="${NVM_LS_REMOTE_OUTPUT%%v4\.0\.0*}";
                NVM_LS_REMOTE_POST_MERGED_OUTPUT="${NVM_LS_REMOTE_OUTPUT#$NVM_LS_REMOTE_PRE_MERGED_OUTPUT}";
                NVM_LS_REMOTE_EXIT_CODE=$?;
            fi;
            local NVM_LS_REMOTE_IOJS_EXIT_CODE;
            NVM_LS_REMOTE_IOJS_EXIT_CODE=0;
            local NVM_LS_REMOTE_IOJS_OUTPUT;
            NVM_LS_REMOTE_IOJS_OUTPUT='';
            if [ "_$NVM_FLAVOR" != "_$NVM_NODE_PREFIX" ]; then
                NVM_LS_REMOTE_IOJS_OUTPUT=$(nvm_ls_remote_iojs "$PATTERN");
                NVM_LS_REMOTE_IOJS_EXIT_CODE=$?;
            fi;
            local NVM_OUTPUT;
            NVM_OUTPUT="$(echo "$NVM_LS_REMOTE_PRE_MERGED_OUTPUT
$NVM_LS_REMOTE_IOJS_OUTPUT
$NVM_LS_REMOTE_POST_MERGED_OUTPUT" | command grep -v "N/A" | command sed '/^$/d')";
            if [ -n "$NVM_OUTPUT" ]; then
                nvm_print_versions "$NVM_OUTPUT";
                return $NVM_LS_REMOTE_EXIT_CODE || $NVM_LS_REMOTE_IOJS_EXIT_CODE;
            else
                nvm_print_versions "N/A";
                return 3;
            fi
        ;;
        "current")
            nvm_version current
        ;;
        "which")
            local provided_version;
            provided_version="$2";
            if [ $# -eq 1 ]; then
                nvm_rc_version;
                if [ -n "$NVM_RC_VERSION" ]; then
                    provided_version="$NVM_RC_VERSION";
                    VERSION=$(nvm_version "$NVM_RC_VERSION");
                fi;
            else
                if [ "_$2" != '_system' ]; then
                    VERSION="$(nvm_version "$provided_version")";
                else
                    VERSION="$2";
                fi;
            fi;
            if [ -z "$VERSION" ]; then
                nvm help 1>&2;
                return 127;
            fi;
            if [ "_$VERSION" = '_system' ]; then
                if nvm_has_system_iojs > /dev/null 2>&1 || nvm_has_system_node > /dev/null 2>&1; then
                    local NVM_BIN;
                    NVM_BIN="$(nvm use system >/dev/null 2>&1 && command which node)";
                    if [ -n "$NVM_BIN" ]; then
                        echo "$NVM_BIN";
                        return;
                    else
                        return 1;
                    fi;
                else
                    echo "System version of node not found." 1>&2;
                    return 127;
                fi;
            else
                if [ "_$VERSION" = "_" ]; then
                    echo "The alias \"$2\" leads to an infinite loop. Aborting." 1>&2;
                    return 8;
                fi;
            fi;
            nvm_ensure_version_installed "$provided_version";
            EXIT_CODE=$?;
            if [ "$EXIT_CODE" != "0" ]; then
                return $EXIT_CODE;
            fi;
            local NVM_VERSION_DIR;
            NVM_VERSION_DIR="$(nvm_version_path "$VERSION")";
            echo "$NVM_VERSION_DIR/bin/node"
        ;;
        "alias")
            local NVM_ALIAS_DIR;
            NVM_ALIAS_DIR="$(nvm_alias_path)";
            command mkdir -p "$NVM_ALIAS_DIR";
            if [ $# -le 2 ]; then
                local DEST;
                for ALIAS_PATH in "$NVM_ALIAS_DIR"/"${2-}"*;
                do
                    ALIAS="$(command basename "$ALIAS_PATH")";
                    DEST="$(nvm_alias "$ALIAS" 2> /dev/null)";
                    if [ -n "$DEST" ]; then
                        VERSION="$(nvm_version "$DEST")";
                        if [ "_$DEST" = "_$VERSION" ]; then
                            echo "$ALIAS -> $DEST";
                        else
                            echo "$ALIAS -> $DEST (-> $VERSION)";
                        fi;
                    fi;
                done;
                for ALIAS in "$(nvm_node_prefix)" "stable" "unstable" "$(nvm_iojs_prefix)";
                do
                    if [ ! -f "$NVM_ALIAS_DIR/$ALIAS" ]; then
                        if [ $# -lt 2 ] || [ "~$ALIAS" = "~$2" ]; then
                            DEST="$(nvm_print_implicit_alias local "$ALIAS")";
                            if [ "_$DEST" != "_" ]; then
                                VERSION="$(nvm_version "$DEST")";
                                if [ "_$DEST" = "_$VERSION" ]; then
                                    echo "$ALIAS -> $DEST (default)";
                                else
                                    echo "$ALIAS -> $DEST (-> $VERSION) (default)";
                                fi;
                            fi;
                        fi;
                    fi;
                done;
                return;
            fi;
            if [ -z "${3-}" ]; then
                command rm -f "$NVM_ALIAS_DIR/$2";
                echo "$2 -> *poof*";
                return;
            fi;
            VERSION="$(nvm_version "$3")";
            if [ $? -ne 0 ]; then
                echo "! WARNING: Version '$3' does not exist." 1>&2;
            fi;
            echo "$3" | tee "$NVM_ALIAS_DIR/$2" > /dev/null;
            if [ ! "_$3" = "_$VERSION" ]; then
                echo "$2 -> $3 (-> $VERSION)";
            else
                echo "$2 -> $3";
            fi
        ;;
        "unalias")
            local NVM_ALIAS_DIR;
            NVM_ALIAS_DIR="$(nvm_alias_path)";
            command mkdir -p "$NVM_ALIAS_DIR";
            if [ $# -ne 2 ]; then
                nvm help 1>&2;
                return 127;
            fi;
            [ ! -f "$NVM_ALIAS_DIR/$2" ] && echo "Alias $2 doesn't exist!" 1>&2 && return;
            local NVM_ALIAS_ORIGINAL;
            NVM_ALIAS_ORIGINAL="$(nvm_alias "$2")";
            command rm -f "$NVM_ALIAS_DIR/$2";
            echo "Deleted alias $2 - restore it with \`nvm alias $2 "$NVM_ALIAS_ORIGINAL"\`"
        ;;
        "reinstall-packages" | "copy-packages")
            if [ $# -ne 2 ]; then
                nvm help 1>&2;
                return 127;
            fi;
            local PROVIDED_VERSION;
            PROVIDED_VERSION="$2";
            if [ "$PROVIDED_VERSION" = "$(nvm_ls_current)" ] || [ "$(nvm_version "$PROVIDED_VERSION")" = "$(nvm_ls_current)" ]; then
                echo 'Can not reinstall packages from the current version of node.' 1>&2;
                return 2;
            fi;
            local VERSION;
            if [ "_$PROVIDED_VERSION" = "_system" ]; then
                if ! nvm_has_system_node && ! nvm_has_system_iojs; then
                    echo 'No system version of node or io.js detected.' 1>&2;
                    return 3;
                fi;
                VERSION="system";
            else
                VERSION="$(nvm_version "$PROVIDED_VERSION")";
            fi;
            local NPMLIST;
            NPMLIST="$(nvm_npm_global_modules "$VERSION")";
            local INSTALLS;
            local LINKS;
            INSTALLS="${NPMLIST%% //// *}";
            LINKS="${NPMLIST##* //// }";
            echo "Reinstalling global packages from $VERSION...";
            echo "$INSTALLS" | command xargs npm install -g --quiet;
            echo "Linking global packages from $VERSION...";
            set -f;
            IFS='
';
            for LINK in $LINKS;
            do
                set +f;
                unset IFS;
                if [ -n "$LINK" ]; then
                    ( cd "$LINK" && npm link );
                fi;
            done;
            set +f;
            unset IFS
        ;;
        "clear-cache")
            command rm -f "$NVM_DIR/v*" "$(nvm_version_dir)" 2> /dev/null;
            echo "Cache cleared."
        ;;
        "version")
            nvm_version "$2"
        ;;
        "version-remote")
            nvm_remote_version "$2"
        ;;
        "--version")
            echo "0.31.0"
        ;;
        "unload")
            unset -f nvm nvm_print_versions nvm_checksum nvm_iojs_prefix nvm_node_prefix nvm_add_iojs_prefix nvm_strip_iojs_prefix nvm_is_iojs_version nvm_is_alias nvm_ls_remote nvm_ls_remote_iojs nvm_ls_remote_index_tab nvm_ls nvm_remote_version nvm_remote_versions nvm_install_iojs_binary nvm_install_node_binary nvm_install_node_source nvm_version nvm_rc_version nvm_match_version nvm_ensure_default_set nvm_get_arch nvm_get_os nvm_print_implicit_alias nvm_validate_implicit_alias nvm_resolve_alias nvm_ls_current nvm_alias nvm_binary_available nvm_prepend_path nvm_strip_path nvm_num_version_groups nvm_format_version nvm_ensure_version_prefix nvm_normalize_version nvm_is_valid_version nvm_ensure_version_installed nvm_version_path nvm_alias_path nvm_version_dir nvm_find_nvmrc nvm_find_up nvm_tree_contains_path nvm_version_greater nvm_version_greater_than_or_equal_to nvm_print_npm_version nvm_npm_global_modules nvm_has_system_node nvm_has_system_iojs nvm_download nvm_get_latest nvm_has nvm_get_latest nvm_supports_source_options nvm_auto nvm_supports_xz nvm_process_parameters > /dev/null 2>&1;
            unset RC_VERSION NVM_NODEJS_ORG_MIRROR NVM_DIR NVM_CD_FLAGS > /dev/null 2>&1
        ;;
        *)
            nvm help 1>&2;
            return 127
        ;;
    esac
}
nvm_add_iojs_prefix () 
{ 
    command echo "$(nvm_iojs_prefix)-$(nvm_ensure_version_prefix "$(nvm_strip_iojs_prefix "$1")")"
}
nvm_alias () 
{ 
    local ALIAS;
    ALIAS="$1";
    if [ -z "$ALIAS" ]; then
        echo 'An alias is required.' 1>&2;
        return 1;
    fi;
    local NVM_ALIAS_PATH;
    NVM_ALIAS_PATH="$(nvm_alias_path)/$ALIAS";
    if [ ! -f "$NVM_ALIAS_PATH" ]; then
        echo 'Alias does not exist.' 1>&2;
        return 2;
    fi;
    command cat "$NVM_ALIAS_PATH"
}
nvm_alias_path () 
{ 
    echo "$(nvm_version_dir old)/alias"
}
nvm_auto () 
{ 
    local NVM_MODE;
    NVM_MODE="${1-}";
    local VERSION;
    if [ "_$NVM_MODE" = '_install' ]; then
        VERSION="$(nvm_alias default 2>/dev/null || echo)";
        if [ -n "$VERSION" ]; then
            nvm install "$VERSION" > /dev/null;
        else
            if nvm_rc_version > /dev/null 2>&1; then
                nvm install > /dev/null;
            fi;
        fi;
    else
        if [ "_$NVM_MODE" = '_use' ]; then
            VERSION="$(nvm_alias default 2>/dev/null || echo)";
            if [ -n "$VERSION" ]; then
                nvm use --silent "$VERSION" > /dev/null;
            else
                if nvm_rc_version > /dev/null 2>&1; then
                    nvm use --silent > /dev/null;
                fi;
            fi;
        else
            if [ "_$NVM_MODE" != '_none' ]; then
                echo 'Invalid auto mode supplied.' 1>&2;
                return 1;
            fi;
        fi;
    fi
}
nvm_binary_available () 
{ 
    local FIRST_VERSION_WITH_BINARY;
    FIRST_VERSION_WITH_BINARY="0.8.6";
    nvm_version_greater_than_or_equal_to "$(nvm_strip_iojs_prefix "$1")" "$FIRST_VERSION_WITH_BINARY"
}
nvm_checksum () 
{ 
    local NVM_CHECKSUM;
    if [ -z "$3" ] || [ "$3" == "sha1" ]; then
        if nvm_has "sha1sum" && ! nvm_is_alias "sha1sum"; then
            NVM_CHECKSUM="$(command sha1sum "$1" | command awk '{print $1}')";
        else
            if nvm_has "sha1" && ! nvm_is_alias "sha1"; then
                NVM_CHECKSUM="$(command sha1 -q "$1")";
            else
                if nvm_has "shasum" && ! nvm_is_alias "shasum"; then
                    NVM_CHECKSUM="$(shasum "$1" | command awk '{print $1}')";
                else
                    echo "Unaliased sha1sum, sha1, or shasum not found." 1>&2;
                    return 2;
                fi;
            fi;
        fi;
    else
        if nvm_has "sha256sum" && ! nvm_is_alias "sha256sum"; then
            NVM_CHECKSUM="$(sha256sum "$1" | awk '{print $1}')";
        else
            if nvm_has "shasum" && ! nvm_is_alias "shasum"; then
                NVM_CHECKSUM="$(shasum -a 256 "$1" | awk '{print $1}')";
            else
                if nvm_has "sha256" && ! nvm_is_alias "sha256"; then
                    NVM_CHECKSUM="$(sha256 -q "$1" | awk '{print $1}')";
                else
                    if nvm_has "gsha256sum" && ! nvm_is_alias "gsha256sum"; then
                        NVM_CHECKSUM="$(gsha256sum "$1" | awk '{print $1}')";
                    else
                        if nvm_has "openssl" && ! nvm_is_alias "openssl"; then
                            NVM_CHECKSUM="$(openssl dgst -sha256 "$1" | rev | awk '{print $1}' | rev)";
                        else
                            if nvm_has "libressl" && ! nvm_is_alias "libressl"; then
                                NVM_CHECKSUM="$(libressl dgst -sha256 "$1" | rev | awk '{print $1}' | rev)";
                            else
                                if nvm_has "bssl" && ! nvm_is_alias "bssl"; then
                                    NVM_CHECKSUM="$(bssl sha256sum "$1" | awk '{print $1}')";
                                else
                                    echo "Unaliased sha256sum, shasum, sha256, gsha256sum, openssl, libressl, or bssl not found." 1>&2;
                                    echo "WARNING: Continuing *without checksum verification*" 1>&2;
                                    return;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    if [ "_$NVM_CHECKSUM" = "_$2" ]; then
        return;
    else
        if [ -z "$2" ]; then
            echo 'Checksums empty';
            return;
        else
            echo 'Checksums do not match.' 1>&2;
            return 1;
        fi;
    fi
}
nvm_die_on_prefix () 
{ 
    local NVM_DELETE_PREFIX;
    NVM_DELETE_PREFIX="$1";
    case "$NVM_DELETE_PREFIX" in 
        0 | 1)

        ;;
        *)
            echo 'First argument "delete the prefix" must be zero or one' 1>&2;
            return 1
        ;;
    esac;
    local NVM_COMMAND;
    NVM_COMMAND="$2";
    if [ -z "$NVM_COMMAND" ]; then
        echo 'Second argument "nvm command" must be nonempty' 1>&2;
        return 2;
    fi;
    if [ -n "${PREFIX-}" ] && ! ( nvm_tree_contains_path "$NVM_DIR" "$PREFIX" > /dev/null 2>&1 ); then
        nvm deactivate > /dev/null 2>&1;
        echo "nvm is not compatible with the \"PREFIX\" environment variable: currently set to \"$PREFIX\"" 1>&2;
        echo "Run \`unset PREFIX\` to unset it." 1>&2;
        return 3;
    fi;
    if [ -n "${NPM_CONFIG_PREFIX-}" ] && ! ( nvm_tree_contains_path "$NVM_DIR" "$NPM_CONFIG_PREFIX" > /dev/null 2>&1 ); then
        nvm deactivate > /dev/null 2>&1;
        echo "nvm is not compatible with the \"NPM_CONFIG_PREFIX\" environment variable: currently set to \"$NPM_CONFIG_PREFIX\"" 1>&2;
        echo "Run \`unset NPM_CONFIG_PREFIX\` to unset it." 1>&2;
        return 4;
    fi;
    if ! nvm_has 'npm'; then
        return;
    fi;
    local NVM_NPM_PREFIX;
    NVM_NPM_PREFIX="$(NPM_CONFIG_LOGLEVEL=warn npm config get prefix)";
    if ! ( nvm_tree_contains_path "$NVM_DIR" "$NVM_NPM_PREFIX" > /dev/null 2>&1 ); then
        if [ "_$NVM_DELETE_PREFIX" = "_1" ]; then
            NPM_CONFIG_LOGLEVEL=warn npm config delete prefix;
        else
            nvm deactivate > /dev/null 2>&1;
            echo "nvm is not compatible with the npm config \"prefix\" option: currently set to \"$NVM_NPM_PREFIX\"" 1>&2;
            if nvm_has 'npm'; then
                echo "Run \`npm config delete prefix\` or \`$NVM_COMMAND\` to unset it." 1>&2;
            else
                echo "Run \`$NVM_COMMAND\` to unset it." 1>&2;
            fi;
            return 10;
        fi;
    fi
}
nvm_download () 
{ 
    if nvm_has "curl"; then
        curl -q $*;
    else
        if nvm_has "wget"; then
            ARGS=$(echo "$*" | command sed -e 's/--progress-bar /--progress=bar /'                            -e 's/-L //'                            -e 's/-I /--server-response /'                            -e 's/-s /-q /'                            -e 's/-o /-O /'                            -e 's/-C - /-c /');
            eval wget $ARGS;
        fi;
    fi
}
nvm_ensure_default_set () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "$VERSION" ]; then
        echo 'nvm_ensure_default_set: a version is required' 1>&2;
        return 1;
    fi;
    if nvm_alias default > /dev/null 2>&1; then
        return 0;
    fi;
    local OUTPUT;
    OUTPUT="$(nvm alias default "$VERSION")";
    local EXIT_CODE;
    EXIT_CODE="$?";
    echo "Creating default alias: $OUTPUT";
    return $EXIT_CODE
}
nvm_ensure_version_installed () 
{ 
    local PROVIDED_VERSION;
    PROVIDED_VERSION="$1";
    local LOCAL_VERSION;
    local EXIT_CODE;
    LOCAL_VERSION="$(nvm_version "$PROVIDED_VERSION")";
    EXIT_CODE="$?";
    local NVM_VERSION_DIR;
    if [ "_$EXIT_CODE" = "_0" ]; then
        NVM_VERSION_DIR="$(nvm_version_path "$LOCAL_VERSION")";
    fi;
    if [ "_$EXIT_CODE" != "_0" ] || [ ! -d "$NVM_VERSION_DIR" ]; then
        VERSION="$(nvm_resolve_alias "$PROVIDED_VERSION")";
        if [ $? -eq 0 ]; then
            echo "N/A: version \"$PROVIDED_VERSION -> $VERSION\" is not yet installed" 1>&2;
        else
            local PREFIXED_VERSION;
            PREFIXED_VERSION="$(nvm_ensure_version_prefix "$PROVIDED_VERSION")";
            echo "N/A: version \"${PREFIXED_VERSION:-$PROVIDED_VERSION}\" is not yet installed" 1>&2;
        fi;
        return 1;
    fi
}
nvm_ensure_version_prefix () 
{ 
    local NVM_VERSION;
    NVM_VERSION="$(nvm_strip_iojs_prefix "$1" | command sed -e 's/^\([0-9]\)/v\1/g')";
    if nvm_is_iojs_version "$1"; then
        nvm_add_iojs_prefix "$NVM_VERSION";
    else
        echo "$NVM_VERSION";
    fi
}
nvm_find_nvmrc () 
{ 
    local dir;
    dir="$(nvm_find_up '.nvmrc')";
    if [ -e "$dir/.nvmrc" ]; then
        echo "$dir/.nvmrc";
    fi
}
nvm_find_up () 
{ 
    local path;
    path=$PWD;
    while [ "$path" != "" ] && [ ! -f "$path/$1" ]; do
        path=${path%/*};
    done;
    echo "$path"
}
nvm_format_version () 
{ 
    local VERSION;
    VERSION="$(nvm_ensure_version_prefix "$1")";
    local NUM_GROUPS;
    NUM_GROUPS="$(nvm_num_version_groups "$VERSION")";
    if [ $NUM_GROUPS -lt 3 ]; then
        nvm_format_version "${VERSION%.}.0";
    else
        echo "$VERSION" | cut -f1-3 -d.;
    fi
}
nvm_get_arch () 
{ 
    local HOST_ARCH;
    local NVM_OS;
    local EXIT_CODE;
    NVM_OS="$(nvm_get_os)";
    if [ "_$NVM_OS" = "_sunos" ]; then
        HOST_ARCH=$(pkg_info -Q MACHINE_ARCH pkg_install);
        EXIT_CODE=$?;
        if [ $EXIT_CODE -ne 0 ]; then
            HOST_ARCH=$(isainfo -n);
        fi;
    else
        HOST_ARCH="$(uname -m)";
    fi;
    local NVM_ARCH;
    case "$HOST_ARCH" in 
        x86_64 | amd64)
            NVM_ARCH="x64"
        ;;
        i*86)
            NVM_ARCH="x86"
        ;;
        *)
            NVM_ARCH="$HOST_ARCH"
        ;;
    esac;
    echo "$NVM_ARCH"
}
nvm_get_latest () 
{ 
    local NVM_LATEST_URL;
    if nvm_has "curl"; then
        NVM_LATEST_URL="$(curl -q -w "%{url_effective}\n" -L -s -S http://latest.nvm.sh -o /dev/null)";
    else
        if nvm_has "wget"; then
            NVM_LATEST_URL="$(wget http://latest.nvm.sh --server-response -O /dev/null 2>&1 | command awk '/^  Location: /{DEST=$2} END{ print DEST }')";
        else
            echo 'nvm needs curl or wget to proceed.' 1>&2;
            return 1;
        fi;
    fi;
    if [ "_$NVM_LATEST_URL" = "_" ]; then
        echo "http://latest.nvm.sh did not redirect to the latest release on Github" 1>&2;
        return 2;
    else
        echo "$NVM_LATEST_URL" | command awk -F '/' '{print $NF}';
    fi
}
nvm_get_make_jobs () 
{ 
    if nvm_is_natural_num "${1-}"; then
        NVM_MAKE_JOBS="$1";
        echo "number of \`make\` jobs: $NVM_MAKE_JOBS";
        return;
    else
        if [ -n "${1-}" ]; then
            unset NVM_MAKE_JOBS;
            echo "$1 is invalid for number of \`make\` jobs, must be a natural number" 1>&2;
        fi;
    fi;
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local NVM_CPU_THREADS;
    if [ "_$NVM_OS" = "_linux" ]; then
        NVM_CPU_THREADS="$(grep -c 'core id' /proc/cpuinfo)";
    else
        if [ "_$NVM_OS" = "_freebsd" ] || [ "_$NVM_OS" = "_darwin" ]; then
            NVM_CPU_THREADS="$(sysctl -n hw.ncpu)";
        else
            if [ "_$NVM_OS" = "_sunos" ]; then
                NVM_CPU_THREADS="$(psrinfo | wc -l)";
            fi;
        fi;
    fi;
    if ! nvm_is_natural_num "$NVM_CPU_THREADS"; then
        echo "Can not determine how many thread(s) we can use, set to only 1 now." 1>&2;
        echo "Please report an issue on GitHub to help us make it better and run it faster on your computer!" 1>&2;
        NVM_MAKE_JOBS=1;
    else
        echo "Detected that you have $NVM_CPU_THREADS CPU thread(s)";
        if [ $NVM_CPU_THREADS -gt 2 ]; then
            NVM_MAKE_JOBS=$(($NVM_CPU_THREADS - 1));
            echo "Set the number of jobs to $NVM_CPU_THREADS - 1 = $NVM_MAKE_JOBS jobs to speed up the build";
        else
            NVM_MAKE_JOBS=1;
            echo "Number of CPU thread(s) less or equal to 2 will have only one job a time for 'make'";
        fi;
    fi
}
nvm_get_minor_version () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "$VERSION" ]; then
        echo 'a version is required' 1>&2;
        return 1;
    fi;
    case "$VERSION" in 
        v | .* | *..* | v*[!.0123456789]* | [!v]*[!.0123456789]* | [!v0123456789]* | v[!0123456789]*)
            echo 'invalid version number' 1>&2;
            return 2
        ;;
    esac;
    local PREFIXED_VERSION;
    PREFIXED_VERSION="$(nvm_format_version "$VERSION")";
    local MINOR;
    MINOR="$(echo "$PREFIXED_VERSION" | command grep -e '^v' | command cut -c2- | command cut -d . -f 1,2)";
    if [ -z "$MINOR" ]; then
        echo 'invalid version number! (please report this)' 1>&2;
        return 3;
    fi;
    echo "$MINOR"
}
nvm_get_os () 
{ 
    local NVM_UNAME;
    NVM_UNAME="$(uname -a)";
    local NVM_OS;
    case "$NVM_UNAME" in 
        Linux\ *)
            NVM_OS=linux
        ;;
        Darwin\ *)
            NVM_OS=darwin
        ;;
        SunOS\ *)
            NVM_OS=sunos
        ;;
        FreeBSD\ *)
            NVM_OS=freebsd
        ;;
    esac;
    echo "$NVM_OS"
}
nvm_has () 
{ 
    type "$1" > /dev/null 2>&1
}
nvm_has_solaris_binary () 
{ 
    local VERSION=$1;
    if nvm_is_merged_node_version "$VERSION"; then
        return 0;
    else
        if nvm_is_iojs_version "$VERSION"; then
            iojs_version_has_solaris_binary "$VERSION";
        else
            node_version_has_solaris_binary "$VERSION";
        fi;
    fi
}
nvm_has_system_iojs () 
{ 
    [ "$(nvm deactivate >/dev/null 2>&1 && command -v iojs)" != '' ]
}
nvm_has_system_node () 
{ 
    [ "$(nvm deactivate >/dev/null 2>&1 && command -v node)" != '' ]
}
nvm_install_iojs_binary () 
{ 
    local NVM_IOJS_TYPE;
    NVM_IOJS_TYPE="$1";
    local MIRROR;
    if [ "_$NVM_IOJS_TYPE" = "_std" ]; then
        MIRROR="$NVM_IOJS_ORG_MIRROR";
    else
        echo "unknown type of io.js release" 1>&2;
        return 4;
    fi;
    local PREFIXED_VERSION;
    PREFIXED_VERSION="$2";
    local REINSTALL_PACKAGES_FROM;
    REINSTALL_PACKAGES_FROM="$3";
    if ! nvm_is_iojs_version "$PREFIXED_VERSION"; then
        echo 'nvm_install_iojs_binary requires an iojs-prefixed version.' 1>&2;
        return 10;
    fi;
    local VERSION;
    VERSION="$(nvm_strip_iojs_prefix "$PREFIXED_VERSION")";
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$PREFIXED_VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local t;
    local url;
    local sum;
    local compression;
    compression="gz";
    local tar_compression_flag;
    tar_compression_flag="x";
    if nvm_supports_xz "$VERSION"; then
        compression="xz";
        tar_compression_flag="J";
    fi;
    if [ -n "$NVM_OS" ]; then
        if nvm_binary_available "$VERSION"; then
            t="$VERSION-$NVM_OS-$(nvm_get_arch)";
            url="$MIRROR/$VERSION/$(nvm_iojs_prefix)-${t}.tar.${compression}";
            sum="$(nvm_download -L -s "$MIRROR/$VERSION/SHASUMS256.txt" -o - | command grep "$(nvm_iojs_prefix)-${t}.tar.${compression}" | command awk '{print $1}')";
            local tmpdir;
            tmpdir="$NVM_DIR/bin/iojs-${t}";
            local tmptarball;
            tmptarball="$tmpdir/iojs-${t}.tar.${compression}";
            local NVM_INSTALL_ERRORED;
            command mkdir -p "$tmpdir" && echo "Downloading $url..." && nvm_download -L -C - --progress-bar "$url" -o "$tmptarball" || NVM_INSTALL_ERRORED=true;
            if grep --color=auto '404 Not Found' "$tmptarball" > /dev/null; then
                NVM_INSTALL_ERRORED=true;
                echo "HTTP 404 at URL $url" 1>&2;
            fi;
            if ( [ "$NVM_INSTALL_ERRORED" != true ] && nvm_checksum "$tmptarball" "$sum" "sha256" && command tar -x${tar_compression_flag}f "$tmptarball" -C "$tmpdir" --strip-components 1 && command rm -f "$tmptarball" && command mkdir -p "$VERSION_PATH" && command mv "$tmpdir"/* "$VERSION_PATH" ); then
                return 0;
            else
                echo "Binary download failed, trying source." 1>&2 1>&2;
                command rm -rf "$tmptarball" "$tmpdir";
                return 1;
            fi;
        fi;
    fi;
    return 2
}
nvm_install_merged_node_binary () 
{ 
    local NVM_NODE_TYPE;
    NVM_NODE_TYPE="$1";
    local MIRROR;
    if [ "_$NVM_NODE_TYPE" = "_std" ]; then
        MIRROR="$NVM_NODEJS_ORG_MIRROR";
    else
        echo "unknown type of node.js release" 1>&2;
        return 4;
    fi;
    local VERSION;
    VERSION="$2";
    local REINSTALL_PACKAGES_FROM;
    REINSTALL_PACKAGES_FROM="$3";
    if ! nvm_is_merged_node_version "$VERSION" || nvm_is_iojs_version "$VERSION"; then
        echo 'nvm_install_merged_node_binary requires a node version v4.0 or greater.' 1>&2;
        return 10;
    fi;
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local t;
    local url;
    local sum;
    local NODE_PREFIX;
    local compression;
    compression="gz";
    local tar_compression_flag;
    tar_compression_flag="x";
    if nvm_supports_xz "$VERSION"; then
        compression="xz";
        tar_compression_flag="J";
    fi;
    NODE_PREFIX="$(nvm_node_prefix)";
    if [ -n "$NVM_OS" ]; then
        t="$VERSION-$NVM_OS-$(nvm_get_arch)";
        url="$MIRROR/$VERSION/$NODE_PREFIX-${t}.tar.${compression}";
        sum="$(nvm_download -L -s "$MIRROR/$VERSION/SHASUMS256.txt" -o - | command grep "${NODE_PREFIX}-${t}.tar.${compression}" | command awk '{print $1}')";
        local tmpdir;
        tmpdir="$NVM_DIR/bin/node-${t}";
        local tmptarball;
        tmptarball="$tmpdir/node-${t}.tar.${compression}";
        local NVM_INSTALL_ERRORED;
        command mkdir -p "$tmpdir" && echo "Downloading $url..." && nvm_download -L -C - --progress-bar "$url" -o "$tmptarball" || NVM_INSTALL_ERRORED=true;
        if grep --color=auto '404 Not Found' "$tmptarball" > /dev/null; then
            NVM_INSTALL_ERRORED=true;
            echo "HTTP 404 at URL $url" 1>&2;
        fi;
        if ( [ "$NVM_INSTALL_ERRORED" != true ] && nvm_checksum "$tmptarball" "$sum" "sha256" && command tar -x${tar_compression_flag}f "$tmptarball" -C "$tmpdir" --strip-components 1 && command rm -f "$tmptarball" && command mkdir -p "$VERSION_PATH" && command mv "$tmpdir"/* "$VERSION_PATH" ); then
            return 0;
        else
            echo "Binary download failed, trying source." 1>&2 1>&2;
            command rm -rf "$tmptarball" "$tmpdir";
            return 1;
        fi;
    fi;
    return 2
}
nvm_install_node_binary () 
{ 
    local VERSION;
    VERSION="$1";
    local REINSTALL_PACKAGES_FROM;
    REINSTALL_PACKAGES_FROM="$2";
    if nvm_is_iojs_version "$VERSION"; then
        echo 'nvm_install_node_binary does not allow an iojs-prefixed version.' 1>&2;
        return 10;
    fi;
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local t;
    local url;
    local sum;
    if [ -n "$NVM_OS" ]; then
        if nvm_binary_available "$VERSION"; then
            local NVM_ARCH;
            NVM_ARCH="$(nvm_get_arch)";
            if [ "_$NVM_ARCH" = '_armv6l' ] || [ "_$NVM_ARCH" = 'armv7l' ]; then
                NVM_ARCH="arm-pi";
            fi;
            t="$VERSION-$NVM_OS-$NVM_ARCH";
            url="$NVM_NODEJS_ORG_MIRROR/$VERSION/node-${t}.tar.gz";
            sum=$(nvm_download -L -s "$NVM_NODEJS_ORG_MIRROR/$VERSION/SHASUMS.txt" -o - | command grep "node-${t}.tar.gz" | command awk '{print $1}');
            local tmpdir;
            tmpdir="$NVM_DIR/bin/node-${t}";
            local tmptarball;
            tmptarball="$tmpdir/node-${t}.tar.gz";
            local NVM_INSTALL_ERRORED;
            command mkdir -p "$tmpdir" && nvm_download -L -C - --progress-bar "$url" -o "$tmptarball" || NVM_INSTALL_ERRORED=true;
            if grep --color=auto '404 Not Found' "$tmptarball" > /dev/null; then
                NVM_INSTALL_ERRORED=true;
                echo "HTTP 404 at URL $url" 1>&2;
            fi;
            if ( [ "$NVM_INSTALL_ERRORED" != true ] && nvm_checksum "$tmptarball" "$sum" && command tar -xzf "$tmptarball" -C "$tmpdir" --strip-components 1 && command rm -f "$tmptarball" && command mkdir -p "$VERSION_PATH" && command mv "$tmpdir"/* "$VERSION_PATH" ); then
                return 0;
            else
                echo "Binary download failed, trying source." 1>&2;
                command rm -rf "$tmptarball" "$tmpdir";
                return 1;
            fi;
        fi;
    fi;
    return 2
}
nvm_install_node_source () 
{ 
    local VERSION;
    VERSION="$1";
    local NVM_MAKE_JOBS;
    NVM_MAKE_JOBS="$2";
    local ADDITIONAL_PARAMETERS;
    ADDITIONAL_PARAMETERS="$3";
    local NVM_ARCH;
    NVM_ARCH="$(nvm_get_arch)";
    if [ "_$NVM_ARCH" = '_armv6l' ] || [ "_$NVM_ARCH" = '_armv7l' ]; then
        ADDITIONAL_PARAMETERS="--without-snapshot $ADDITIONAL_PARAMETERS";
    fi;
    if [ -n "$ADDITIONAL_PARAMETERS" ]; then
        echo "Additional options while compiling: $ADDITIONAL_PARAMETERS";
    fi;
    local VERSION_PATH;
    VERSION_PATH="$(nvm_version_path "$VERSION")";
    local NVM_OS;
    NVM_OS="$(nvm_get_os)";
    local tarball;
    tarball='';
    local sum;
    sum='';
    local make;
    make='make';
    if [ "_$NVM_OS" = "_freebsd" ]; then
        make='gmake';
        MAKE_CXX="CXX=c++";
    fi;
    local tmpdir;
    tmpdir="$NVM_DIR/src";
    local tmptarball;
    tmptarball="$tmpdir/node-$VERSION.tar.gz";
    if [ "$(nvm_download -L -s -I "$NVM_NODEJS_ORG_MIRROR/$VERSION/node-$VERSION.tar.gz" -o - 2>&1 | command grep '200 OK')" != '' ]; then
        tarball="$NVM_NODEJS_ORG_MIRROR/$VERSION/node-$VERSION.tar.gz";
        sum=$(nvm_download -L -s "$NVM_NODEJS_ORG_MIRROR/$VERSION/SHASUMS.txt" -o - | command grep "node-${VERSION}.tar.gz" | command awk '{print $1}');
    else
        if [ "$(nvm_download -L -s -I "$NVM_NODEJS_ORG_MIRROR/node-$VERSION.tar.gz" -o - | command grep '200 OK')" != '' ]; then
            tarball="$NVM_NODEJS_ORG_MIRROR/node-$VERSION.tar.gz";
        fi;
    fi;
    if ( [ -n "$tarball" ] && command mkdir -p "$tmpdir" && echo "Downloading $tarball..." && nvm_download -L --progress-bar "$tarball" -o "$tmptarball" && nvm_checksum "$tmptarball" "$sum" && command tar -xzf "$tmptarball" -C "$tmpdir" && cd "$tmpdir/node-$VERSION" && ./configure --prefix="$VERSION_PATH" $ADDITIONAL_PARAMETERS && $make -j $NVM_MAKE_JOBS ${MAKE_CXX-} && command rm -f "$VERSION_PATH" 2> /dev/null && $make -j $NVM_MAKE_JOBS ${MAKE_CXX-} install ); then
        if ! nvm_has "npm"; then
            echo "Installing npm...";
            if nvm_version_greater 0.2.0 "$VERSION"; then
                echo "npm requires node v0.2.3 or higher" 1>&2;
            else
                if nvm_version_greater_than_or_equal_to "$VERSION" 0.2.0; then
                    if nvm_version_greater 0.2.3 "$VERSION"; then
                        echo "npm requires node v0.2.3 or higher" 1>&2;
                    else
                        nvm_download -L https://npmjs.org/install.sh -o - | clean=yes npm_install=0.2.19 sh;
                    fi;
                else
                    nvm_download -L https://npmjs.org/install.sh -o - | clean=yes sh;
                fi;
            fi;
        fi;
    else
        echo "nvm: install $VERSION failed!" 1>&2;
        return 1;
    fi;
    return $?
}
nvm_iojs_prefix () 
{ 
    echo "iojs"
}
nvm_is_alias () 
{ 
    \alias "$1" > /dev/null 2>&1
}
nvm_is_iojs_version () 
{ 
    case "$1" in 
        iojs-*)
            return 0
        ;;
    esac;
    return 1
}
nvm_is_merged_node_version () 
{ 
    nvm_version_greater_than_or_equal_to "$1" v4.0.0
}
nvm_is_natural_num () 
{ 
    if [ -z "$1" ]; then
        return 4;
    fi;
    case "$1" in 
        0)
            return 1
        ;;
        -*)
            return 3
        ;;
        *)
            [ $1 -eq $1 ] 2> /dev/null
        ;;
    esac
}
nvm_is_valid_version () 
{ 
    if nvm_validate_implicit_alias "$1" 2> /dev/null; then
        return 0;
    fi;
    case "$1" in 
        "$(nvm_iojs_prefix)" | "$(nvm_node_prefix)")
            return 0
        ;;
        *)
            local VERSION;
            VERSION="$(nvm_strip_iojs_prefix "$1")";
            nvm_version_greater "$VERSION"
        ;;
    esac
}
nvm_ls () 
{ 
    local PATTERN;
    PATTERN="${1-}";
    local VERSIONS;
    VERSIONS='';
    if [ "$PATTERN" = 'current' ]; then
        nvm_ls_current;
        return;
    fi;
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local NVM_VERSION_DIR_IOJS;
    NVM_VERSION_DIR_IOJS="$(nvm_version_dir "$NVM_IOJS_PREFIX")";
    local NVM_VERSION_DIR_NEW;
    NVM_VERSION_DIR_NEW="$(nvm_version_dir new)";
    local NVM_VERSION_DIR_OLD;
    NVM_VERSION_DIR_OLD="$(nvm_version_dir old)";
    case "$PATTERN" in 
        "$NVM_IOJS_PREFIX" | "$NVM_NODE_PREFIX")
            PATTERN="$PATTERN-"
        ;;
        *)
            if nvm_resolve_local_alias "$PATTERN"; then
                return;
            fi;
            PATTERN="$(nvm_ensure_version_prefix "$PATTERN")"
        ;;
    esac;
    if [ "_$PATTERN" = "_N/A" ]; then
        return;
    fi;
    local NVM_PATTERN_STARTS_WITH_V;
    case $PATTERN in 
        v*)
            NVM_PATTERN_STARTS_WITH_V=true
        ;;
        *)
            NVM_PATTERN_STARTS_WITH_V=false
        ;;
    esac;
    if [ $NVM_PATTERN_STARTS_WITH_V = true ] && [ "_$(nvm_num_version_groups "$PATTERN")" = "_3" ]; then
        if [ -d "$(nvm_version_path "$PATTERN")" ]; then
            VERSIONS="$PATTERN";
        else
            if [ -d "$(nvm_version_path "$(nvm_add_iojs_prefix "$PATTERN")")" ]; then
                VERSIONS="$(nvm_add_iojs_prefix "$PATTERN")";
            fi;
        fi;
    else
        case "$PATTERN" in 
            "$NVM_IOJS_PREFIX-" | "$NVM_NODE_PREFIX-" | "system")

            ;;
            *)
                local NUM_VERSION_GROUPS;
                NUM_VERSION_GROUPS="$(nvm_num_version_groups "$PATTERN")";
                if [ "_$NUM_VERSION_GROUPS" = "_2" ] || [ "_$NUM_VERSION_GROUPS" = "_1" ]; then
                    PATTERN="${PATTERN%.}.";
                fi
            ;;
        esac;
        local ZHS_HAS_SHWORDSPLIT_UNSET;
        ZHS_HAS_SHWORDSPLIT_UNSET=1;
        if nvm_has "setopt"; then
            ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
            setopt shwordsplit;
        fi;
        local NVM_DIRS_TO_SEARCH1;
        NVM_DIRS_TO_SEARCH1='';
        local NVM_DIRS_TO_SEARCH2;
        NVM_DIRS_TO_SEARCH2='';
        local NVM_DIRS_TO_SEARCH3;
        NVM_DIRS_TO_SEARCH3='';
        local NVM_ADD_SYSTEM;
        NVM_ADD_SYSTEM=false;
        if nvm_is_iojs_version "$PATTERN"; then
            NVM_DIRS_TO_SEARCH1="$NVM_VERSION_DIR_IOJS";
            PATTERN="$(nvm_strip_iojs_prefix "$PATTERN")";
            if nvm_has_system_iojs; then
                NVM_ADD_SYSTEM=true;
            fi;
        else
            if [ "_$PATTERN" = "_$NVM_NODE_PREFIX-" ]; then
                NVM_DIRS_TO_SEARCH1="$NVM_VERSION_DIR_OLD";
                NVM_DIRS_TO_SEARCH2="$NVM_VERSION_DIR_NEW";
                PATTERN='';
                if nvm_has_system_node; then
                    NVM_ADD_SYSTEM=true;
                fi;
            else
                NVM_DIRS_TO_SEARCH1="$NVM_VERSION_DIR_OLD";
                NVM_DIRS_TO_SEARCH2="$NVM_VERSION_DIR_NEW";
                NVM_DIRS_TO_SEARCH3="$NVM_VERSION_DIR_IOJS";
                if nvm_has_system_iojs || nvm_has_system_node; then
                    NVM_ADD_SYSTEM=true;
                fi;
            fi;
        fi;
        if ! [ -d "$NVM_DIRS_TO_SEARCH1" ]; then
            NVM_DIRS_TO_SEARCH1='';
        fi;
        if ! [ -d "$NVM_DIRS_TO_SEARCH2" ]; then
            NVM_DIRS_TO_SEARCH2="$NVM_DIRS_TO_SEARCH1";
        fi;
        if ! [ -d "$NVM_DIRS_TO_SEARCH3" ]; then
            NVM_DIRS_TO_SEARCH3="$NVM_DIRS_TO_SEARCH2";
        fi;
        if [ -z "$PATTERN" ]; then
            PATTERN='v';
        fi;
        if [ -n "$NVM_DIRS_TO_SEARCH1$NVM_DIRS_TO_SEARCH2$NVM_DIRS_TO_SEARCH3" ]; then
            VERSIONS="$(command find "$NVM_DIRS_TO_SEARCH1" "$NVM_DIRS_TO_SEARCH2" "$NVM_DIRS_TO_SEARCH3" -maxdepth 1 -type d -name "$PATTERN*"         | command sed "
            s#$NVM_VERSION_DIR_IOJS/#$NVM_IOJS_PREFIX-#;
            \#$NVM_VERSION_DIR_IOJS# d;
            s#^$NVM_DIR/##;
            \#^versions\$# d;
            s#^versions/##;
            s#^v#$NVM_NODE_PREFIX-v#;
            s#^\($NVM_IOJS_PREFIX\)[-/]v#\1.v#;
            s#^\($NVM_NODE_PREFIX\)[-/]v#\1.v#"         | command sort -t. -u -k 2.2,2n -k 3,3n -k 4,4n         | command sed "
            s/^\($NVM_IOJS_PREFIX\)\./\1-/;
            s/^$NVM_NODE_PREFIX\.//"       )";
        fi;
        if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
            unsetopt shwordsplit;
        fi;
    fi;
    if [ "${NVM_ADD_SYSTEM-}" = true ]; then
        if [ -z "$PATTERN" ] || [ "_$PATTERN" = "_v" ]; then
            VERSIONS="$VERSIONS$(command printf '\n%s' 'system')";
        else
            if [ "$PATTERN" = 'system' ]; then
                VERSIONS="$(command printf '%s' 'system')";
            fi;
        fi;
    fi;
    if [ -z "$VERSIONS" ]; then
        echo "N/A";
        return 3;
    fi;
    echo "$VERSIONS"
}
nvm_ls_current () 
{ 
    local NVM_LS_CURRENT_NODE_PATH;
    NVM_LS_CURRENT_NODE_PATH="$(command which node 2> /dev/null)";
    if [ $? -ne 0 ]; then
        echo 'none';
    else
        if nvm_tree_contains_path "$(nvm_version_dir iojs)" "$NVM_LS_CURRENT_NODE_PATH"; then
            nvm_add_iojs_prefix "$(iojs --version 2>/dev/null)";
        else
            if nvm_tree_contains_path "$NVM_DIR" "$NVM_LS_CURRENT_NODE_PATH"; then
                local VERSION;
                VERSION="$(node --version 2>/dev/null)";
                if [ "$VERSION" = "v0.6.21-pre" ]; then
                    echo "v0.6.21";
                else
                    echo "$VERSION";
                fi;
            else
                echo 'system';
            fi;
        fi;
    fi
}
nvm_ls_remote () 
{ 
    local PATTERN;
    PATTERN="$1";
    if nvm_validate_implicit_alias "$PATTERN" 2> /dev/null; then
        PATTERN="$(nvm_ls_remote "$(nvm_print_implicit_alias remote "$PATTERN")" | command tail -n1)";
    else
        if [ -n "$PATTERN" ]; then
            PATTERN="$(nvm_ensure_version_prefix "$PATTERN")";
        else
            PATTERN=".*";
        fi;
    fi;
    nvm_ls_remote_index_tab node std "$NVM_NODEJS_ORG_MIRROR" "$PATTERN"
}
nvm_ls_remote_index_tab () 
{ 
    if [ "$#" -lt 4 ]; then
        echo "not enough arguments" 1>&2;
        return 5;
    fi;
    local TYPE;
    TYPE="$1";
    local PREFIX;
    PREFIX='';
    case "$TYPE-$2" in 
        iojs-std)
            PREFIX="$(nvm_iojs_prefix)-"
        ;;
        node-std)
            PREFIX=''
        ;;
        iojs-*)
            echo "unknown type of io.js release" 1>&2;
            return 4
        ;;
        node-*)
            echo "unknown type of node.js release" 1>&2;
            return 4
        ;;
    esac;
    local SORT_COMMAND;
    SORT_COMMAND='sort';
    case "$TYPE" in 
        node)
            SORT_COMMAND='sort -t. -u -k 1.2,1n -k 2,2n -k 3,3n'
        ;;
    esac;
    local MIRROR;
    MIRROR="$3";
    local PATTERN;
    PATTERN="$4";
    local VERSIONS;
    if [ -n "$PATTERN" ]; then
        if [ "_$TYPE" = "_iojs" ]; then
            PATTERN="$(nvm_ensure_version_prefix "$(nvm_strip_iojs_prefix "$PATTERN")")";
        else
            PATTERN="$(nvm_ensure_version_prefix "$PATTERN")";
        fi;
    else
        PATTERN=".*";
    fi;
    ZHS_HAS_SHWORDSPLIT_UNSET=1;
    if nvm_has "setopt"; then
        ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
        setopt shwordsplit;
    fi;
    VERSIONS="$(nvm_download -L -s "$MIRROR/index.tab" -o -     | command sed "
        1d;
        s/^/$PREFIX/;
        s/[[:blank:]].*//"     | command grep -w "$PATTERN"     | $SORT_COMMAND)";
    if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
        unsetopt shwordsplit;
    fi;
    if [ -z "$VERSIONS" ]; then
        echo "N/A";
        return 3;
    fi;
    echo "$VERSIONS"
}
nvm_ls_remote_iojs () 
{ 
    nvm_ls_remote_index_tab iojs std "$NVM_IOJS_ORG_MIRROR" "$1"
}
nvm_match_version () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local PROVIDED_VERSION;
    PROVIDED_VERSION="$1";
    case "_$PROVIDED_VERSION" in 
        "_$NVM_IOJS_PREFIX" | "_io.js")
            nvm_version "$NVM_IOJS_PREFIX"
        ;;
        "_system")
            echo "system"
        ;;
        *)
            nvm_version "$PROVIDED_VERSION"
        ;;
    esac
}
nvm_node_prefix () 
{ 
    echo "node"
}
nvm_normalize_version () 
{ 
    echo "${1#v}" | command awk -F. '{ printf("%d%06d%06d\n", $1,$2,$3); }'
}
nvm_npm_global_modules () 
{ 
    local NPMLIST;
    local VERSION;
    VERSION="$1";
    if [ "_$VERSION" = "_system" ]; then
        NPMLIST=$(nvm use system > /dev/null && npm list -g --depth=0 2> /dev/null | command tail -n +2);
    else
        NPMLIST=$(nvm use "$VERSION" > /dev/null && npm list -g --depth=0 2> /dev/null | command tail -n +2);
    fi;
    local INSTALLS;
    INSTALLS=$(echo "$NPMLIST" | command sed -e '/ -> / d' -e '/\(empty\)/ d' -e 's/^.* \(.*@[^ ]*\).*/\1/' -e '/^npm@[^ ]*.*$/ d' | command xargs);
    local LINKS;
    LINKS="$(echo "$NPMLIST" | command sed -n 's/.* -> \(.*\)/\1/ p')";
    echo "$INSTALLS //// $LINKS"
}
nvm_num_version_groups () 
{ 
    local VERSION;
    VERSION="$1";
    VERSION="${VERSION#v}";
    VERSION="${VERSION%.}";
    if [ -z "$VERSION" ]; then
        echo "0";
        return;
    fi;
    local NVM_NUM_DOTS;
    NVM_NUM_DOTS=$(echo "$VERSION" | command sed -e 's/[^\.]//g');
    local NVM_NUM_GROUPS;
    NVM_NUM_GROUPS=".$NVM_NUM_DOTS";
    echo "${#NVM_NUM_GROUPS}"
}
nvm_prepend_path () 
{ 
    if [ -z "$1" ]; then
        echo "$2";
    else
        echo "$2:$1";
    fi
}
nvm_print_implicit_alias () 
{ 
    if [ "_$1" != "_local" ] && [ "_$1" != "_remote" ]; then
        echo "nvm_print_implicit_alias must be specified with local or remote as the first argument." 1>&2;
        return 1;
    fi;
    local NVM_IMPLICIT;
    NVM_IMPLICIT="$2";
    if ! nvm_validate_implicit_alias "$NVM_IMPLICIT"; then
        return 2;
    fi;
    local ZHS_HAS_SHWORDSPLIT_UNSET;
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    local NVM_COMMAND;
    local NVM_ADD_PREFIX_COMMAND;
    local LAST_TWO;
    case "$NVM_IMPLICIT" in 
        "$NVM_IOJS_PREFIX")
            NVM_COMMAND="nvm_ls_remote_iojs";
            NVM_ADD_PREFIX_COMMAND="nvm_add_iojs_prefix";
            if [ "_$1" = "_local" ]; then
                NVM_COMMAND="nvm_ls $NVM_IMPLICIT";
            fi;
            ZHS_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
                setopt shwordsplit;
            fi;
            local NVM_IOJS_VERSION;
            local EXIT_CODE;
            NVM_IOJS_VERSION="$($NVM_COMMAND)";
            EXIT_CODE="$?";
            if [ "_$EXIT_CODE" = "_0" ]; then
                NVM_IOJS_VERSION="$(echo "$NVM_IOJS_VERSION" | sed "s/^$NVM_IMPLICIT-//" | command grep -e '^v' | command cut -c2- | command cut -d . -f 1,2 | uniq | command tail -1)";
            fi;
            if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi;
            if [ "_$NVM_IOJS_VERSION" = "_N/A" ]; then
                echo "N/A";
            else
                $NVM_ADD_PREFIX_COMMAND "$NVM_IOJS_VERSION";
            fi;
            return $EXIT_CODE
        ;;
        "$NVM_NODE_PREFIX")
            echo "stable";
            return
        ;;
        *)
            NVM_COMMAND="nvm_ls_remote";
            if [ "_$1" = "_local" ]; then
                NVM_COMMAND="nvm_ls node";
            fi;
            ZHS_HAS_SHWORDSPLIT_UNSET=1;
            if nvm_has "setopt"; then
                ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
                setopt shwordsplit;
            fi;
            LAST_TWO=$($NVM_COMMAND | command grep -e '^v' | command cut -c2- | command cut -d . -f 1,2 | uniq);
            if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
                unsetopt shwordsplit;
            fi
        ;;
    esac;
    local MINOR;
    local STABLE;
    local UNSTABLE;
    local MOD;
    local NORMALIZED_VERSION;
    ZHS_HAS_SHWORDSPLIT_UNSET=1;
    if nvm_has "setopt"; then
        ZHS_HAS_SHWORDSPLIT_UNSET=$(setopt | command grep shwordsplit > /dev/null ; echo $?);
        setopt shwordsplit;
    fi;
    for MINOR in $LAST_TWO;
    do
        NORMALIZED_VERSION="$(nvm_normalize_version "$MINOR")";
        if [ "_0${NORMALIZED_VERSION#?}" != "_$NORMALIZED_VERSION" ]; then
            STABLE="$MINOR";
        else
            MOD=$(expr "$NORMALIZED_VERSION" \/ 1000000 \% 2);
            if [ "$MOD" -eq 0 ]; then
                STABLE="$MINOR";
            else
                if [ "$MOD" -eq 1 ]; then
                    UNSTABLE="$MINOR";
                fi;
            fi;
        fi;
    done;
    if [ "$ZHS_HAS_SHWORDSPLIT_UNSET" -eq 1 ] && nvm_has "unsetopt"; then
        unsetopt shwordsplit;
    fi;
    if [ "_$2" = '_stable' ]; then
        echo "${STABLE}";
    else
        if [ "_$2" = '_unstable' ]; then
            echo "${UNSTABLE}";
        fi;
    fi
}
nvm_print_npm_version () 
{ 
    if nvm_has "npm"; then
        echo " (npm v$(npm --version 2>/dev/null))";
    fi
}
nvm_print_versions () 
{ 
    local VERSION;
    local FORMAT;
    local NVM_CURRENT;
    NVM_CURRENT=$(nvm_ls_current);
    echo "$1" | while read -r VERSION; do
        if [ "_$VERSION" = "_$NVM_CURRENT" ]; then
            FORMAT='\033[0;32m-> %12s\033[0m';
        else
            if [ "$VERSION" = "system" ]; then
                FORMAT='\033[0;33m%15s\033[0m';
            else
                if [ -d "$(nvm_version_path "$VERSION" 2> /dev/null)" ]; then
                    FORMAT='\033[0;34m%15s\033[0m';
                else
                    FORMAT='%15s';
                fi;
            fi;
        fi;
        command printf "$FORMAT\n" "$VERSION";
    done
}
nvm_process_parameters () 
{ 
    local NVM_AUTO_MODE;
    NVM_AUTO_MODE='use';
    if nvm_supports_source_options; then
        while [ $# -ne 0 ]; do
            case "$1" in 
                --install)
                    NVM_AUTO_MODE='install'
                ;;
                --no-use)
                    NVM_AUTO_MODE='none'
                ;;
            esac;
            shift;
        done;
    fi;
    nvm_auto "$NVM_AUTO_MODE"
}
nvm_rc_version () 
{ 
    export NVM_RC_VERSION='';
    local NVMRC_PATH;
    NVMRC_PATH="$(nvm_find_nvmrc)";
    if [ -e "$NVMRC_PATH" ]; then
        read -r NVM_RC_VERSION < "$NVMRC_PATH";
        echo "Found '$NVMRC_PATH' with version <$NVM_RC_VERSION>";
    else
        echo "No .nvmrc file found" 1>&2;
        return 1;
    fi
}
nvm_remote_version () 
{ 
    local PATTERN;
    PATTERN="$1";
    local VERSION;
    if nvm_validate_implicit_alias "$PATTERN" 2> /dev/null; then
        case "_$PATTERN" in 
            "_$(nvm_iojs_prefix)")
                VERSION="$(nvm_ls_remote_iojs | command tail -n1)"
            ;;
            *)
                VERSION="$(nvm_ls_remote "$PATTERN")"
            ;;
        esac;
    else
        VERSION="$(nvm_remote_versions "$PATTERN" | command tail -n1)";
    fi;
    echo "$VERSION";
    if [ "_$VERSION" = '_N/A' ]; then
        return 3;
    fi
}
nvm_remote_versions () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local PATTERN;
    PATTERN="$1";
    case "_$PATTERN" in 
        "_$NVM_IOJS_PREFIX" | "_io.js")
            VERSIONS="$(nvm_ls_remote_iojs)"
        ;;
        "_$(nvm_node_prefix)")
            VERSIONS="$(nvm_ls_remote)"
        ;;
        *)
            if nvm_validate_implicit_alias "$PATTERN" 2> /dev/null; then
                echo "Implicit aliases are not supported in nvm_remote_versions." 1>&2;
                return 1;
            fi;
            VERSIONS="$(echo "$(nvm_ls_remote "$PATTERN")
$(nvm_ls_remote_iojs "$PATTERN")" | command grep -v "N/A" | command sed '/^$/d')"
        ;;
    esac;
    if [ -z "$VERSIONS" ]; then
        echo "N/A";
        return 3;
    else
        echo "$VERSIONS";
    fi
}
nvm_resolve_alias () 
{ 
    if [ -z "$1" ]; then
        return 1;
    fi;
    local PATTERN;
    PATTERN="$1";
    local ALIAS;
    ALIAS="$PATTERN";
    local ALIAS_TEMP;
    local SEEN_ALIASES;
    SEEN_ALIASES="$ALIAS";
    while true; do
        ALIAS_TEMP="$(nvm_alias "$ALIAS" 2> /dev/null)";
        if [ -z "$ALIAS_TEMP" ]; then
            break;
        fi;
        if [ -n "$ALIAS_TEMP" ] && command printf "$SEEN_ALIASES" | command grep -e "^$ALIAS_TEMP$" > /dev/null; then
            ALIAS="";
            break;
        fi;
        SEEN_ALIASES="$SEEN_ALIASES\n$ALIAS_TEMP";
        ALIAS="$ALIAS_TEMP";
    done;
    if [ -n "$ALIAS" ] && [ "_$ALIAS" != "_$PATTERN" ]; then
        local NVM_IOJS_PREFIX;
        NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
        local NVM_NODE_PREFIX;
        NVM_NODE_PREFIX="$(nvm_node_prefix)";
        case "_$ALIAS" in 
            "_" | "_$NVM_IOJS_PREFIX" | "_$NVM_IOJS_PREFIX-" | "_$NVM_NODE_PREFIX")
                echo "$ALIAS"
            ;;
            *)
                nvm_ensure_version_prefix "$ALIAS"
            ;;
        esac;
        return 0;
    fi;
    if nvm_validate_implicit_alias "$PATTERN" 2> /dev/null; then
        local IMPLICIT;
        IMPLICIT="$(nvm_print_implicit_alias local "$PATTERN" 2> /dev/null)";
        if [ -n "$IMPLICIT" ]; then
            nvm_ensure_version_prefix "$IMPLICIT";
        fi;
    fi;
    return 2
}
nvm_resolve_local_alias () 
{ 
    if [ -z "$1" ]; then
        return 1;
    fi;
    local VERSION;
    local EXIT_CODE;
    VERSION="$(nvm_resolve_alias "$1")";
    EXIT_CODE=$?;
    if [ -z "$VERSION" ]; then
        return $EXIT_CODE;
    fi;
    if [ "_$VERSION" != "_" ]; then
        nvm_version "$VERSION";
    else
        echo "$VERSION";
    fi
}
nvm_sanitize_path () 
{ 
    local SANITIZED_PATH;
    SANITIZED_PATH="$1";
    if [ "_$1" != "_$NVM_DIR" ]; then
        SANITIZED_PATH="$(echo "$SANITIZED_PATH" | command sed "s#$NVM_DIR#\$NVM_DIR#g")";
    fi;
    echo "$SANITIZED_PATH" | command sed "s#$HOME#\$HOME#g"
}
nvm_strip_iojs_prefix () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    if [ "_$1" = "_$NVM_IOJS_PREFIX" ]; then
        echo;
    else
        echo "${1#"$NVM_IOJS_PREFIX"-}";
    fi
}
nvm_strip_path () 
{ 
    echo "$1" | command sed -e "s#$NVM_DIR/[^/]*$2[^:]*:##g" -e "s#:$NVM_DIR/[^/]*$2[^:]*##g" -e "s#$NVM_DIR/[^/]*$2[^:]*##g" -e "s#$NVM_DIR/versions/[^/]*/[^/]*$2[^:]*:##g" -e "s#:$NVM_DIR/versions/[^/]*/[^/]*$2[^:]*##g" -e "s#$NVM_DIR/versions/[^/]*/[^/]*$2[^:]*##g"
}
nvm_supports_source_options () 
{ 
    [ "_$(echo '[ $# -gt 0 ] && echo $1' | . /dev/stdin yes 2> /dev/null)" = "_yes" ]
}
nvm_supports_xz () 
{ 
    command which xz > /dev/null 2>&1 && nvm_version_greater_than_or_equal_to "$1" "2.3.2"
}
nvm_tree_contains_path () 
{ 
    local tree;
    tree="$1";
    local node_path;
    node_path="$2";
    if [ "@$tree@" = "@@" ] || [ "@$node_path@" = "@@" ]; then
        echo "both the tree and the node path are required" 1>&2;
        return 2;
    fi;
    local pathdir;
    pathdir=$(dirname "$node_path");
    while [ "$pathdir" != "" ] && [ "$pathdir" != "." ] && [ "$pathdir" != "/" ] && [ "$pathdir" != "$tree" ]; do
        pathdir=$(dirname "$pathdir");
    done;
    [ "$pathdir" = "$tree" ]
}
nvm_validate_implicit_alias () 
{ 
    local NVM_IOJS_PREFIX;
    NVM_IOJS_PREFIX="$(nvm_iojs_prefix)";
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    case "$1" in 
        "stable" | "unstable" | "$NVM_IOJS_PREFIX" | "$NVM_NODE_PREFIX")
            return
        ;;
        *)
            echo "Only implicit aliases 'stable', 'unstable', '$NVM_IOJS_PREFIX', and '$NVM_NODE_PREFIX' are supported." 1>&2;
            return 1
        ;;
    esac
}
nvm_version () 
{ 
    local PATTERN;
    PATTERN="$1";
    local VERSION;
    if [ -z "$PATTERN" ]; then
        PATTERN='current';
    fi;
    if [ "$PATTERN" = "current" ]; then
        nvm_ls_current;
        return $?;
    fi;
    local NVM_NODE_PREFIX;
    NVM_NODE_PREFIX="$(nvm_node_prefix)";
    case "_$PATTERN" in 
        "_$NVM_NODE_PREFIX" | "_$NVM_NODE_PREFIX-")
            PATTERN="stable"
        ;;
    esac;
    VERSION="$(nvm_ls "$PATTERN" | command tail -n1)";
    if [ -z "$VERSION" ] || [ "_$VERSION" = "_N/A" ]; then
        echo "N/A";
        return 3;
    else
        echo "$VERSION";
    fi
}
nvm_version_dir () 
{ 
    local NVM_WHICH_DIR;
    NVM_WHICH_DIR="$1";
    if [ -z "$NVM_WHICH_DIR" ] || [ "_$NVM_WHICH_DIR" = "_new" ]; then
        echo "$NVM_DIR/versions/node";
    else
        if [ "_$NVM_WHICH_DIR" = "_iojs" ]; then
            echo "$NVM_DIR/versions/io.js";
        else
            if [ "_$NVM_WHICH_DIR" = "_old" ]; then
                echo "$NVM_DIR";
            else
                echo "unknown version dir" 1>&2;
                return 3;
            fi;
        fi;
    fi
}
nvm_version_greater () 
{ 
    local LHS;
    LHS="$(nvm_normalize_version "$1")";
    local RHS;
    RHS="$(nvm_normalize_version "$2")";
    [ "$LHS" -gt "$RHS" ]
}
nvm_version_greater_than_or_equal_to () 
{ 
    local LHS;
    LHS="$(nvm_normalize_version "$1")";
    local RHS;
    RHS="$(nvm_normalize_version "$2")";
    [ "$LHS" -ge "$RHS" ]
}
nvm_version_path () 
{ 
    local VERSION;
    VERSION="$1";
    if [ -z "$VERSION" ]; then
        echo "version is required" 1>&2;
        return 3;
    else
        if nvm_is_iojs_version "$VERSION"; then
            echo "$(nvm_version_dir iojs)/$(nvm_strip_iojs_prefix "$VERSION")";
        else
            if nvm_version_greater 0.12.0 "$VERSION"; then
                echo "$(nvm_version_dir old)/$VERSION";
            else
                echo "$(nvm_version_dir new)/$VERSION";
            fi;
        fi;
    fi
}
popd () 
{ 
    __zsh_like_cd popd "$@"
}
pushd () 
{ 
    __zsh_like_cd pushd "$@"
}
pydoc () 
{ 
    python -m pydoc "$@"
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
rmvirtualenv () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    if [ ${#@} = 0 ]; then
        echo "Please specify an enviroment." 1>&2;
        return 1;
    fi;
    typeset env_name;
    for env_name in $@;
    do
        echo "Removing $env_name...";
        typeset env_dir="$WORKON_HOME/$env_name";
        if [ "$VIRTUAL_ENV" = "$env_dir" ]; then
            echo "ERROR: You cannot remove the active environment ('$env_name')." 1>&2;
            echo "Either switch to another environment, or run 'deactivate'." 1>&2;
            return 1;
        fi;
        typeset prior_dir="$(pwd)";
        virtualenvwrapper_cd "$WORKON_HOME";
        virtualenvwrapper_run_hook "pre_rmvirtualenv" "$env_name";
        command \rm -rf "$env_dir";
        virtualenvwrapper_run_hook "post_rmvirtualenv" "$env_name";
        if [ -d "$prior_dir" ]; then
            virtualenvwrapper_cd "$prior_dir";
        fi;
    done
}
rubygems_detect_ruby_lib_gem_path () 
{ 
    \typeset ruby_path;
    ruby_path="$( __rvm_which "${1:-ruby}" )" || { 
        rvm_error "Missing 'ruby' in 'rubygems_detect_ruby_lib_gem_path'.";
        return 1
    };
    ruby_lib_gem_path="$(
    unset GEM_HOME GEM_PATH
    "$ruby_path" -rrubygems -e 'puts Gem.default_dir' 2>/dev/null
  )" || ruby_lib_gem_path="";
    [[ -n "$ruby_lib_gem_path" ]] || rubygems_detect_ruby_lib_gem_path_fallback || return $?
}
rubygems_detect_ruby_lib_gem_path_fallback () 
{ 
    rubygems_detect_ruby_lib_gem_path_from "rubylib" || rubygems_detect_ruby_lib_gem_path_from "lib" || return $?;
    ruby_lib_gem_path+="/gems";
    \typeset ruby_version;
    ruby_version="$( __rvm_ruby_config_get ruby_version "$ruby_path")" || ruby_version="";
    if [[ -n "${ruby_version:-}" && -d "${ruby_lib_gem_path}/${ruby_version:-}" ]]; then
        ruby_lib_gem_path+="$ruby_version";
    else
        if [[ -d "${ruby_lib_gem_path}/shared" ]]; then
            ruby_lib_gem_path+="shared";
        else
            return 3;
        fi;
    fi
}
rubygems_detect_ruby_lib_gem_path_from () 
{ 
    ruby_lib_gem_path="$( __rvm_ruby_config_get ${1}prefix "$ruby_path" )" || ruby_lib_gem_path="";
    [[ -z "${ruby_lib_gem_path:-}" ]] || { 
        ruby_lib_gem_path="$( __rvm_ruby_config_get ${1}dir  "$ruby_path" )" || ruby_lib_gem_path="";
        ruby_lib_gem_path="${ruby_lib_gem_path%/*}"
    };
    [[ -n "${ruby_lib_gem_path:-}" ]] || return 1;
    [[ -d "${ruby_lib_gem_path}/gems" ]] || return 2
}
run_gem_wrappers_regenerate () 
{ 
    gem_install gem-wrappers && gem wrappers regenerate || return $?
}
rvm () 
{ 
    \typeset result current_result;
    rvm_ruby_args=();
    __rvm_teardown_if_broken;
    __rvm_cli_posix_check || return $?;
    __rvm_cli_load_rvmrc || return $?;
    __rvm_cli_version_check "$@" || return $?;
    __rvm_path_match_gem_home_check;
    __rvm_initialize;
    __rvm_setup;
    __rvm_cli_autoupdate "$@" || return $?;
    next_token="$1";
    (( $# == 0 )) || shift;
    __rvm_parse_args "$@";
    result=$?;
    : rvm_ruby_args:${#rvm_ruby_args[@]}:${rvm_ruby_args[*]}:;
    (( ${rvm_trace_flag:-0} == 0 )) || set -o xtrace;
    (( result )) || case "${rvm_action:=help}" in 
        use)
            if rvm_is_a_shell_function; then
                __rvm_use && __rvm_use_ruby_warnings;
            fi
        ;;
        switch)
            if rvm_is_a_shell_function; then
                __rvm_switch "${rvm_ruby_args[@]}";
            fi
        ;;
        inspect | strings | version | remote_version)
            __rvm_${rvm_action}
        ;;
        ls | list)
            "$rvm_scripts_path/list" "${rvm_ruby_args[@]}"
        ;;
        debug)
            rvm_is_not_a_shell_function="${rvm_is_not_a_shell_function}" "$rvm_scripts_path/info" '' debug
        ;;
        info)
            rvm_is_not_a_shell_function="${rvm_is_not_a_shell_function}" "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}"
        ;;
        reset)
            source "$rvm_scripts_path/functions/${rvm_action}";
            __rvm_${rvm_action}
        ;;
        update)
            printf "%b" "ERROR: rvm update has been removed. Try 'rvm get head' or see the 'rvm get' and rvm 'rubygems' CLI API instead\n"
        ;;
        implode | seppuku)
            source "$rvm_scripts_path/functions/implode";
            __rvm_implode
        ;;
        get)
            next_token="${1:-}";
            (( $# == 0 )) || shift;
            [[ "$next_token" == "${rvm_action}" ]] && shift;
            __rvm_cli_rvm_get "${rvm_ruby_args[@]}"
        ;;
        current)
            __rvm_env_string
        ;;
        help | rtfm | env | list | monitor | notes | pkg | requirements)
            next_token="${1:-}";
            (( $# == 0 )) || shift;
            if (( $# )) && [[ "$next_token" == "${rvm_action}" ]]; then
                shift;
            fi;
            "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}"
        ;;
        cleanup | tools | snapshot | disk-usage | repair | alias | docs | rubygems | migrate | cron | group)
            "$rvm_scripts_path/${rvm_action}" "${rvm_ruby_args[@]}"
        ;;
        upgrade)
            __rvm_fix_selected_ruby __rvm_run_wrapper "$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        autolibs | osx-ssl-certs | fix-permissions)
            __rvm_run_wrapper "$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        wrapper)
            "$rvm_scripts_path/wrapper" "$rvm_ruby_string" "$rvm_wrapper_name" "${rvm_ruby_args[@]}";
            result=$?;
            unset rvm_wrapper_name
        ;;
        do)
            old_rvm_ruby_string=${rvm_ruby_string:-};
            unset rvm_ruby_string;
            export rvm_ruby_strings rvm_in_flag;
            result=0;
            if rvm_is_a_shell_function no_warning; then
                "$rvm_scripts_path/set" "$rvm_action" "${rvm_ruby_args[@]}" || result=$?;
            else
                exec "$rvm_scripts_path/set" "$rvm_action" "${rvm_ruby_args[@]}" || result=$?;
            fi;
            [[ -n "$old_rvm_ruby_string" ]] && rvm_ruby_string=$old_rvm_ruby_string;
            unset old_rvm_ruby_string
        ;;
        rvmrc)
            __rvm_rvmrc_tools "${rvm_ruby_args[@]}"
        ;;
        config-get)
            \typeset __ruby __var;
            __ruby=$( __rvm_which ruby );
            for __var in "${rvm_ruby_args[@]}";
            do
                __rvm_ruby_config_get "${__var}" "${__ruby}";
            done
        ;;
        gemset_use)
            if rvm_is_a_shell_function; then
                __rvm_gemset_use;
            fi
        ;;
        gemset)
            export rvm_ruby_strings;
            "$rvm_scripts_path/gemsets" "${rvm_ruby_args[@]}";
            result=$?;
            rvm_ruby_strings="";
            if rvm_is_a_shell_function no_warning; then
                if [[ ${rvm_delete_flag:-0} -eq 1 ]]; then
                    if [[ "${GEM_HOME:-""}" == "${GEM_HOME%%${rvm_gemset_separator:-@}*}${rvm_gemset_separator:-@}${rvm_gemset_name}" ]]; then
                        rvm_delete_flag=0;
                        __rvm_use "@default";
                    fi;
                    unset gem_prefix;
                else
                    if [[ "${rvm_ruby_args[*]}" == rename* ]]; then
                        \typeset _command _from _to;
                        read _command _from _to <<< "${rvm_ruby_args[*]}";
                        if [[ "${GEM_HOME:-""}" == "${GEM_HOME%%${rvm_gemset_separator:-@}*}${rvm_gemset_separator:-@}${_from}" ]]; then
                            __rvm_use "@${_to}";
                        fi;
                    fi;
                fi;
            fi
        ;;
        reload)
            rvm_reload_flag=1
        ;;
        tests | specs)
            rvm_action="rake";
            __rvm_do
        ;;
        remove)
            export rvm_path;
            if [[ -n "${rvm_ruby_strings}" ]]; then
                __rvm_run_wrapper manage "$rvm_action" "${rvm_ruby_strings//*-- }";
            else
                __rvm_run_wrapper manage "$rvm_action";
            fi;
            __rvm_use default
        ;;
        fetch | uninstall | reinstall)
            export rvm_path;
            if [[ -n "${rvm_ruby_strings}" ]]; then
                __rvm_run_wrapper manage "$rvm_action" "${rvm_ruby_strings//*-- }";
            else
                __rvm_run_wrapper manage "$rvm_action";
            fi
        ;;
        try_install | install)
            export rvm_path;
            __rvm_cli_install_ruby "${rvm_ruby_strings}"
        ;;
        automount)
            if [[ -n "$rvm_ruby_string" ]]; then
                rvm_ruby_args=("$rvm_ruby_string" "${rvm_ruby_args[@]}");
            fi;
            "${rvm_scripts_path}/mount" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        mount | prepare)
            if [[ -n "$rvm_ruby_string" ]]; then
                rvm_ruby_args=("$rvm_ruby_string" "${rvm_ruby_args[@]}");
            fi;
            "${rvm_scripts_path}/$rvm_action" "$rvm_action" "${rvm_ruby_args[@]}"
        ;;
        export)
            __rvm_export "$rvm_export_args"
        ;;
        unexport)
            __rvm_unset_exports
        ;;
        error)
            false
        ;;
        which)
            __rvm_which "${rvm_ruby_args[@]}"
        ;;
        *)
            rvm_error "unknown action '$rvm_action'";
            false
        ;;
    esac;
    current_result=$?;
    (( result )) || result=${current_result};
    (( result )) || case "$rvm_action" in 
        reinstall | try_install | install)
            if [[ -n "${rvm_ruby_string}" ]];
            rvm_is_a_shell_function no_warning; then
                if [[ -e "${rvm_environments_path}/default" ]]; then
                    rvm_verbose_flag=0 __rvm_use;
                else
                    rvm_verbose_flag=0 rvm_default_flag=1 __rvm_use;
                fi;
            fi
        ;;
    esac;
    current_result=$?;
    (( result )) || result=${current_result};
    \typeset __local_rvm_trace_flag;
    __local_rvm_trace_flag=${rvm_trace_flag:-0};
    __rvm_cli_autoreload;
    if (( __local_rvm_trace_flag > 0 )); then
        set +o verbose;
        set +o xtrace;
        [[ -n "${ZSH_VERSION:-""}" ]] || set +o errtrace;
    fi;
    return ${result:-0}
}
rvm_debug () 
{ 
    (( ${rvm_debug_flag:-0} )) || return 0;
    if rvm_pretty_print stderr; then
        printf "%b" "${rvm_debug_clr:-}$*${rvm_reset_clr:-}\n";
    else
        printf "%b" "$*\n";
    fi 1>&2
}
rvm_debug_stream () 
{ 
    if (( ${rvm_debug_flag:-0} == 0 && ${rvm_trace_flag:-0} == 0 )); then
        cat - > /dev/null;
    else
        if rvm_pretty_print stdout; then
            \command \cat - | __rvm_awk '{print "'"${rvm_debug_clr:-}"'"$0"'"${rvm_reset_clr:-}"'"}' 1>&2;
        else
            \command \cat - 1>&2;
        fi;
    fi
}
rvm_error () 
{ 
    if rvm_pretty_print stderr; then
        printf "%b" "${rvm_error_clr:-}$*${rvm_reset_clr:-}\n";
    else
        printf "%b" "$*\n";
    fi 1>&2
}
rvm_error_help () 
{ 
    rvm_error "$1";
    shift;
    rvm_help "$@"
}
rvm_fail () 
{ 
    rvm_error "$1";
    exit "${2:-1}"
}
rvm_help () 
{ 
    "${rvm_scripts_path}/help" "$@"
}
rvm_install_gpg_setup () 
{ 
    { 
        rvm_gpg_command="$( \which gpg2 2>/dev/null )" && [[ ${rvm_gpg_command} != "/cygdrive/"* ]]
    } || rvm_gpg_command="";
    rvm_debug "Detected GPG program: '$rvm_gpg_command'";
    [[ -n "$rvm_gpg_command" ]] || return $?
}
rvm_is_a_shell_function () 
{ 
    \typeset _message;
    if (( ${rvm_is_not_a_shell_function:-0} )) && [[ "${1:-}" != "no_warning" ]]; then
        if rvm_pretty_print stderr; then
            rvm_log "";
        fi;
        if rvm_pretty_print stderr; then
            rvm_log "RVM is not a function, selecting rubies with '${rvm_error_clr:-}rvm use ...${rvm_notify_clr:-}' will not work." 1>&2;
        else
            rvm_error "RVM is not a function, selecting rubies with 'rvm use ...' will not work.";
        fi;
        rvm_warn '
You need to change your terminal emulator preferences to allow login shell.
Sometimes it is required to use `/bin/bash --login` as the command.
Please visit https://rvm.io/integration/gnome-terminal/ for an example.
';
    fi;
    return ${rvm_is_not_a_shell_function:-0}
}
rvm_log () 
{ 
    [[ ${rvm_quiet_flag} == 1 ]] && return;
    if rvm_pretty_print stdout; then
        printf "%b" "${rvm_notify_clr:-}$*${rvm_reset_clr:-}\n";
    else
        printf "%b" "$*\n";
    fi
}
rvm_out () 
{ 
    printf "$*\n"
}
rvm_pretty_print () 
{ 
    case "${rvm_pretty_print_flag:=auto}" in 
        0 | no)
            return 1
        ;;
        1 | auto)
            case "${TERM:-dumb}" in 
                dumb | unknown)
                    return 1
                ;;
            esac;
            case "$1" in 
                stdout)
                    [[ -t 1 ]] || return 1
                ;;
                stderr)
                    [[ -t 2 ]] || return 1
                ;;
                [0-9])
                    [[ -t $1 ]] || return 1
                ;;
                any)
                    [[ -t 1 || -t 2 ]] || return 1
                ;;
                *)
                    [[ -t 1 && -t 2 ]] || return 1
                ;;
            esac;
            return 0
        ;;
        2 | force)
            return 0
        ;;
    esac
}
rvm_verbose_log () 
{ 
    if (( ${rvm_verbose_flag:=0} == 1 )); then
        rvm_log "$@";
    fi
}
rvm_warn () 
{ 
    if rvm_pretty_print stdout; then
        printf "%b" "${rvm_warn_clr:-}$*${rvm_reset_clr:-}\n" 1>&2;
    else
        printf "%b" "$*\n" 1>&2;
    fi
}
setvirtualenvproject () 
{ 
    typeset venv="$1";
    typeset prj="$2";
    if [ -z "$venv" ]; then
        venv="$VIRTUAL_ENV";
    fi;
    if [ -z "$prj" ]; then
        prj="$(pwd)";
    fi;
    echo "Setting project for $(basename $venv) to $prj";
    echo "$prj" > "$venv/$VIRTUALENVWRAPPER_PROJECT_FILENAME"
}
showvirtualenv () 
{ 
    typeset env_name="$1";
    if [ -z "$env_name" ]; then
        if [ -z "$VIRTUAL_ENV" ]; then
            echo "showvirtualenv [env]";
            return 1;
        fi;
        env_name=$(basename "$VIRTUAL_ENV");
    fi;
    virtualenvwrapper_run_hook "get_env_details" "$env_name";
    echo
}
toggleglobalsitepackages () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset no_global_site_packages_file="`virtualenvwrapper_get_site_packages_dir`/../no-global-site-packages.txt";
    if [ -f $no_global_site_packages_file ]; then
        rm $no_global_site_packages_file;
        [ "$1" = "-q" ] || echo "Enabled global site-packages";
    else
        touch $no_global_site_packages_file;
        [ "$1" = "-q" ] || echo "Disabled global site-packages";
    fi
}
verify_package_pgp () 
{ 
    if "${rvm_gpg_command}" --verify "$2" "$1"; then
        rvm_log "GPG verified '$1'";
    else
        \typeset _ret=$?;
        rvm_error "Warning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found. Assuming you trust Michal Papis import the mpapis public key (downloading the signatures).

GPG signature verification failed for '$1' - '$3'! Try to install GPG v2 and then fetch the public key:

    ${SUDO_USER:+sudo }${rvm_gpg_command##*/} --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3

or if it fails:

    command curl -sSL https://rvm.io/mpapis.asc | ${SUDO_USER:+sudo }${rvm_gpg_command##*/} --import -

the key can be compared with:

    https://rvm.io/mpapis.asc
    https://keybase.io/mpapis

NOTE: GPG version 2.1.17 have a bug which cause failures during fetching keys from remote server. Please downgrade or upgrade to newer version (if available) or use the second method described above.
";
        return _ret;
    fi
}
virtualenv_deactivate () 
{ 
    unset -f pydoc > /dev/null 2>&1;
    if ! [ -z "${_OLD_VIRTUAL_PATH+_}" ]; then
        PATH="$_OLD_VIRTUAL_PATH";
        export PATH;
        unset _OLD_VIRTUAL_PATH;
    fi;
    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ]; then
        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME";
        export PYTHONHOME;
        unset _OLD_VIRTUAL_PYTHONHOME;
    fi;
    if [ -n "${BASH-}" ] || [ -n "${ZSH_VERSION-}" ]; then
        hash -r 2> /dev/null;
    fi;
    if ! [ -z "${_OLD_VIRTUAL_PS1+_}" ]; then
        PS1="$_OLD_VIRTUAL_PS1";
        export PS1;
        unset _OLD_VIRTUAL_PS1;
    fi;
    unset VIRTUAL_ENV;
    if [ ! "${1-}" = "nondestructive" ]; then
        unset -f virtualenv_deactivate;
    fi
}
virtualenvwrapper_absolutepath () 
{ 
    if [ "$1" = "" ]; then
        return 1;
    else
        "$VIRTUALENVWRAPPER_PYTHON" -c "import os,sys; sys.stdout.write(os.path.abspath(\"$1\")+'\n')";
        return 0;
    fi
}
virtualenvwrapper_cd () 
{ 
    if [ -n "$BASH" ]; then
        builtin \cd "$@";
    else
        if [ -n "$ZSH_VERSION" ]; then
            builtin \cd "$@";
        else
            command \cd "$@";
        fi;
    fi
}
virtualenvwrapper_derive_workon_home () 
{ 
    typeset workon_home_dir="$WORKON_HOME";
    if [ "$workon_home_dir" = "" ]; then
        workon_home_dir="$HOME/.virtualenvs";
    fi;
    if echo "$workon_home_dir" | ( unset GREP_OPTIONS;
    command \grep '^[^/~]' > /dev/null ); then
        workon_home_dir="$HOME/$WORKON_HOME";
    fi;
    if echo "$workon_home_dir" | ( unset GREP_OPTIONS;
    command \egrep '([\$~]|//)' > /dev/null ); then
        workon_home_dir="$(virtualenvwrapper_expandpath "$workon_home_dir")";
    fi;
    echo "$workon_home_dir";
    return 0
}
virtualenvwrapper_expandpath () 
{ 
    if [ "$1" = "" ]; then
        return 1;
    else
        "$VIRTUALENVWRAPPER_PYTHON" -c "import os,sys; sys.stdout.write(os.path.normpath(os.path.expanduser(os.path.expandvars(\"$1\")))+'\n')";
        return 0;
    fi
}
virtualenvwrapper_get_python_version () 
{ 
    "$VIRTUAL_ENV/bin/python" -V 2>&1 | cut -f2 -d' ' | cut -f-2 -d.
}
virtualenvwrapper_get_site_packages_dir () 
{ 
    "$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/python" -c "import distutils; print(distutils.sysconfig.get_python_lib())"
}
virtualenvwrapper_initialize () 
{ 
    export WORKON_HOME="$(virtualenvwrapper_derive_workon_home)";
    virtualenvwrapper_verify_workon_home -q || return 1;
    if [ "$VIRTUALENVWRAPPER_HOOK_DIR" = "" ]; then
        export VIRTUALENVWRAPPER_HOOK_DIR="$WORKON_HOME";
    fi;
    virtualenvwrapper_run_hook "initialize";
    virtualenvwrapper_setup_tab_completion;
    return 0
}
virtualenvwrapper_load () 
{ 
    source "$VIRTUALENVWRAPPER_SCRIPT"
}
virtualenvwrapper_mkproject_help () 
{ 
    echo "Usage: mkproject [-t template] [virtualenv options] project_name";
    echo "";
    echo "Multiple templates may be selected.  They are applied in the order";
    echo "specified on the command line.";
    echo;
    echo "mkvirtualenv help:";
    echo;
    mkvirtualenv -h;
    echo;
    echo "Available project templates:";
    echo;
    "$VIRTUALENVWRAPPER_PYTHON" -c 'from virtualenvwrapper.hook_loader import main; main()' -l project.template
}
virtualenvwrapper_mktemp () 
{ 
    command \mktemp "$@"
}
virtualenvwrapper_mkvirtualenv_help () 
{ 
    echo "Usage: mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] env_name";
    echo;
    echo " -a project_path";
    echo;
    echo "    Provide a full path to a project directory to associate with";
    echo "    the new environment.";
    echo;
    echo " -i package";
    echo;
    echo "    Install a package after the environment is created.";
    echo "    This option may be repeated.";
    echo;
    echo " -r requirements_file";
    echo;
    echo "    Provide a pip requirements file to install a base set of packages";
    echo "    into the new environment.";
    echo;
    echo 'virtualenv help:';
    echo;
    "$VIRTUALENVWRAPPER_VIRTUALENV" $@
}
virtualenvwrapper_run_hook () 
{ 
    typeset hook_script;
    typeset result;
    hook_script="$(virtualenvwrapper_tempfile ${1}-hook)" || return 1;
    ( cd "$WORKON_HOME" && "$VIRTUALENVWRAPPER_PYTHON" -m 'virtualenvwrapper.hook_loader' $HOOK_VERBOSE_OPTION --script "$hook_script" "$@" );
    result=$?;
    if [ $result -eq 0 ]; then
        if [ ! -f "$hook_script" ]; then
            echo "ERROR: virtualenvwrapper_run_hook could not find temporary file $hook_script" 1>&2;
            command \rm -f "$hook_script";
            return 2;
        fi;
        source "$hook_script";
    else
        if [ "${1}" = "initialize" ]; then
            cat - 1>&2  <<EOF
virtualenvwrapper.sh: There was a problem running the initialization hooks. 

If Python could not import the module virtualenvwrapper.hook_loader,
check that virtualenv has been installed for
VIRTUALENVWRAPPER_PYTHON=$VIRTUALENVWRAPPER_PYTHON and that PATH is
set properly.
EOF

        fi;
    fi
    command \rm -f "$hook_script";
    return $result
}
virtualenvwrapper_setup_lazy_completion () 
{ 
    if [ -n "$BASH" ]; then
        complete -o nospace -F virtualenvwrapper_load $(echo ${_VIRTUALENVWRAPPER_API});
    else
        if [ -n "$ZSH_VERSION" ]; then
            compctl -K virtualenvwrapper_load $(echo ${_VIRTUALENVWRAPPER_API});
        fi;
    fi
}
virtualenvwrapper_setup_lazy_loader () 
{ 
    typeset venvw_name;
    for venvw_name in $(echo ${_VIRTUALENVWRAPPER_API});
    do
        eval "
function $venvw_name {
	virtualenvwrapper_load
	${venvw_name} \"\$@\"
}
";
    done
}
virtualenvwrapper_setup_tab_completion () 
{ 
    if [ -n "$BASH" ]; then
        function _virtualenvs () 
        { 
            local cur="${COMP_WORDS[COMP_CWORD]}";
            COMPREPLY=($(compgen -W "`virtualenvwrapper_show_workon_options`" -- ${cur}))
        };
        function _cdvirtualenv_complete () 
        { 
            local cur="$2";
            COMPREPLY=($(cdvirtualenv && compgen -d -- "${cur}" ))
        };
        function _cdsitepackages_complete () 
        { 
            local cur="$2";
            COMPREPLY=($(cdsitepackages && compgen -d -- "${cur}" ))
        };
        complete -o nospace -F _cdvirtualenv_complete -S/ cdvirtualenv;
        complete -o nospace -F _cdsitepackages_complete -S/ cdsitepackages;
        complete -o default -o nospace -F _virtualenvs workon;
        complete -o default -o nospace -F _virtualenvs rmvirtualenv;
        complete -o default -o nospace -F _virtualenvs cpvirtualenv;
        complete -o default -o nospace -F _virtualenvs showvirtualenv;
    else
        if [ -n "$ZSH_VERSION" ]; then
            function _virtualenvs () 
            { 
                reply=($(virtualenvwrapper_show_workon_options))
            };
            function _cdvirtualenv_complete () 
            { 
                reply=($(cdvirtualenv && ls -d ${1}*))
            };
            function _cdsitepackages_complete () 
            { 
                reply=($(cdsitepackages && ls -d ${1}*))
            };
            compctl -K _virtualenvs workon rmvirtualenv cpvirtualenv showvirtualenv;
            compctl -K _cdvirtualenv_complete cdvirtualenv;
            compctl -K _cdsitepackages_complete cdsitepackages;
        fi;
    fi
}
virtualenvwrapper_show_workon_options () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    ( cd "$WORKON_HOME" && echo */$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate ) 2> /dev/null | command \sed "s|/$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate||g" | command \fmt -w 1 | ( unset GREP_OPTIONS;
    command \egrep -v '^\*$' ) 2> /dev/null
}
virtualenvwrapper_tempfile () 
{ 
    typeset suffix=${1:-hook};
    typeset file;
    file="$(virtualenvwrapper_mktemp -t virtualenvwrapper-$suffix-XXXXXXXXXX)";
    if [ $? -ne 0 ] || [ -z "$file" ] || [ ! -f "$file" ]; then
        echo "ERROR: virtualenvwrapper could not create a temporary file name." 1>&2;
        return 1;
    fi;
    echo $file;
    return 0
}
virtualenvwrapper_verify_active_environment () 
{ 
    if [ ! -n "${VIRTUAL_ENV}" ] || [ ! -d "${VIRTUAL_ENV}" ]; then
        echo "ERROR: no virtualenv active, or active virtualenv is missing" 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_project_home () 
{ 
    if [ -z "$PROJECT_HOME" ]; then
        echo "ERROR: Set the PROJECT_HOME shell variable to the name of the directory where projects should be created." 1>&2;
        return 1;
    fi;
    if [ ! -d "$PROJECT_HOME" ]; then
        [ "$1" != "-q" ] && echo "ERROR: Project directory '$PROJECT_HOME' does not exist.  Create it or set PROJECT_HOME to an existing directory." 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_resource () 
{ 
    typeset exe_path="$(command \which "$1" | (unset GREP_OPTIONS; command \grep -v "not found"))";
    if [ "$exe_path" = "" ]; then
        echo "ERROR: virtualenvwrapper could not find $1 in your path" 1>&2;
        return 1;
    fi;
    if [ ! -e "$exe_path" ]; then
        echo "ERROR: Found $1 in path as \"$exe_path\" but that does not exist" 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_virtualenv () 
{ 
    virtualenvwrapper_verify_resource $VIRTUALENVWRAPPER_VIRTUALENV
}
virtualenvwrapper_verify_virtualenv_clone () 
{ 
    virtualenvwrapper_verify_resource $VIRTUALENVWRAPPER_VIRTUALENV_CLONE
}
virtualenvwrapper_verify_workon_environment () 
{ 
    typeset env_name="$1";
    if [ ! -d "$WORKON_HOME/$env_name" ]; then
        echo "ERROR: Environment '$env_name' does not exist. Create it with 'mkvirtualenv $env_name'." 1>&2;
        return 1;
    fi;
    return 0
}
virtualenvwrapper_verify_workon_home () 
{ 
    RC=0;
    if [ ! -d "$WORKON_HOME/" ]; then
        if [ "$1" != "-q" ]; then
            echo "NOTE: Virtual environments directory $WORKON_HOME does not exist. Creating..." 1>&2;
        fi;
        mkdir -p "$WORKON_HOME";
        RC=$?;
    fi;
    return $RC
}
virtualenvwrapper_workon_help () 
{ 
    echo "Usage: workon env_name";
    echo "";
    echo "           Deactivate any currently activated virtualenv";
    echo "           and activate the named environment, triggering";
    echo "           any hooks in the process.";
    echo "";
    echo "       workon";
    echo "";
    echo "           Print a list of available environments.";
    echo "           (See also lsvirtualenv -b)";
    echo "";
    echo "       workon (-h|--help)";
    echo "";
    echo "           Show this help message.";
    echo ""
}
wipeenv () 
{ 
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_active_environment || return 1;
    typeset req_file="$(virtualenvwrapper_tempfile "requirements.txt")";
    pip freeze | egrep --color=auto -v '(distribute|wsgiref)' > "$req_file";
    if [ -n "$(cat "$req_file")" ]; then
        echo "Uninstalling packages:";
        cat "$req_file";
        echo;
        pip uninstall -y $(cat "$req_file" | sed 's/>/=/g' | cut -f1 -d=);
    else
        echo "Nothing to remove.";
    fi;
    rm -f "$req_file"
}
workon () 
{ 
    in_args=("$@");
    if [ -n "$ZSH_VERSION" ]; then
        i=1;
        tst="-le";
    else
        i=0;
        tst="-lt";
    fi;
    while [ $i $tst $# ]; do
        a="${in_args[$i]}";
        case "$a" in 
            -h | --help)
                virtualenvwrapper_workon_help;
                return 0
            ;;
        esac;
        i=$(( $i + 1 ));
    done;
    typeset env_name="$1";
    if [ "$env_name" = "" ]; then
        lsvirtualenv -b;
        return 1;
    fi;
    virtualenvwrapper_verify_workon_home || return 1;
    virtualenvwrapper_verify_workon_environment $env_name || return 1;
    activate="$WORKON_HOME/$env_name/$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate";
    if [ ! -f "$activate" ]; then
        echo "ERROR: Environment '$WORKON_HOME/$env_name' does not contain an activate script." 1>&2;
        return 1;
    fi;
    type deactivate > /dev/null 2>&1;
    if [ $? -eq 0 ]; then
        deactivate;
        unset -f deactivate > /dev/null 2>&1;
    fi;
    virtualenvwrapper_run_hook "pre_activate" "$env_name";
    source "$activate";
    virtualenvwrapper_original_deactivate=`typeset -f deactivate | sed 's/deactivate/virtualenv_deactivate/g'`;
    eval "$virtualenvwrapper_original_deactivate";
    unset -f deactivate > /dev/null 2>&1;
    eval 'deactivate () {
        typeset env_postdeactivate_hook
        typeset old_env

        # Call the local hook before the global so we can undo
        # any settings made by the local postactivate first.
        virtualenvwrapper_run_hook "pre_deactivate"

        env_postdeactivate_hook="$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/postdeactivate"
        old_env=$(basename "$VIRTUAL_ENV")

        # Call the original function.
        virtualenv_deactivate $1

        virtualenvwrapper_run_hook "post_deactivate" "$old_env"

        if [ ! "$1" = "nondestructive" ]
        then
            # Remove this function
            unset -f virtualenv_deactivate >/dev/null 2>&1
            unset -f deactivate >/dev/null 2>&1
        fi

    }';
    virtualenvwrapper_run_hook "post_activate";
    return 0
}
